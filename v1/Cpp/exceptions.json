[
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::runtime_error(\"Error occurred\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Error occurred",
      "runtime_error",
      "std::exception",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is the correct way to declare a try block in C++?",
    "o": [
      "try { }",
      "try() { }",
      "try: { }",
      "try-block { }"
    ]
  },
  {
    "q": "What type of exception does 'std::out_of_range' represent in C++?",
    "o": [
      "It is a standard exception for accessing elements out of range in containers.",
      "It is a custom exception used to indicate a logic error.",
      "It represents a memory allocation failure.",
      "It is used for invalid input arguments."
    ]
  },
  {
    "q": "What is the purpose of the 'throw' keyword in C++ exception handling?",
    "o": [
      "It is used to throw an exception.",
      "It is used to catch an exception.",
      "It is used to define an exception class.",
      "It is used to terminate the program."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nvoid test() {\n    throw 42;\n}\n\nint main() {\n    try {\n        test();\n    } catch (int e) {\n        std::cout << e << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "42",
      "test()",
      "Nothing",
      "An error message"
    ]
  },
  {
    "q": "Which of the following is the correct syntax for creating a custom exception class in C++?",
    "o": [
      "class MyException : public std::exception { public: const char* what() const throw() { return \"My custom exception\"; } };",
      "class MyException : std::exception { public: const char* what() { return \"My custom exception\"; } };",
      "exception class MyException { public: const char* what() { return \"My custom exception\"; } };",
      "class MyException { public: const char* what() { return \"My custom exception\"; } };"
    ]
  },
  {
    "q": "Which of the following is a standard exception in C++?",
    "o": [
      "std::invalid_argument",
      "InvalidException",
      "ErrorException",
      "out_of_range_exception"
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nvoid test() {\n    throw std::logic_error(\"Logic error!\");\n}\n\nint main() {\n    try {\n        test();\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Logic error!",
      "std::logic_error",
      "Nothing",
      "An unexpected exception"
    ]
  },
  {
    "q": "Which of the following is the correct order for handling multiple exceptions in C++?",
    "o": [
      "Catch the most specific exception first, followed by more general ones.",
      "Catch the general exceptions first, followed by more specific ones.",
      "Catch all exceptions together.",
      "C++ does not support handling multiple exceptions."
    ]
  },
  {
    "q": "What does exception safety in C++ refer to?",
    "o": [
      "It refers to ensuring that resources are properly cleaned up in the event of an exception.",
      "It refers to handling exceptions in every function.",
      "It refers to ignoring exceptions.",
      "It is related to preventing stack overflows."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nvoid test() {\n    throw std::out_of_range(\"Out of range error!\");\n}\n\nint main() {\n    try {\n        test();\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Out of range error!",
      "std::out_of_range",
      "Nothing",
      "An error occurred"
    ]
  },
  {
    "q": "Which of the following C++ exception classes is used for memory allocation failures?",
    "o": [
      "std::bad_alloc",
      "std::memory_error",
      "std::out_of_memory",
      "std::alloc_error"
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw 10;\n    } catch (int e) {\n        std::cout << e << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "10",
      "Nothing",
      "Error",
      "Exception caught"
    ]
  },
  {
    "q": "What is the purpose of the 'catch' block in C++ exception handling?",
    "o": [
      "It is used to catch and handle exceptions thrown by the try block.",
      "It is used to throw exceptions.",
      "It is used to define custom exception types.",
      "It is used to terminate the program."
    ]
  },
  {
    "q": "Which of the following statements is true about exception handling in C++?",
    "o": [
      "A function that throws an exception must declare it with the 'throw' keyword in its signature.",
      "The 'throw' keyword must be used within a catch block.",
      "The 'catch' block is used to throw exceptions.",
      "An exception can only be caught by the first catch block."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nvoid test() {\n    throw std::runtime_error(\"Runtime error occurred\");\n}\n\nint main() {\n    try {\n        test();\n    } catch (const std::runtime_error& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Runtime error occurred",
      "test()",
      "Nothing",
      "An exception occurred"
    ]
  },
  {
    "q": "Which of the following is true about 'throw' in C++?",
    "o": [
      "'throw' is used to throw an exception in the try block.",
      "'throw' is used to catch exceptions.",
      "'throw' is used to define custom exceptions.",
      "'throw' is used to handle exceptions."
    ]
  },
  {
    "q": "Which C++ class is commonly used to handle invalid arguments in standard library functions?",
    "o": [
      "std::invalid_argument",
      "std::out_of_range",
      "std::logic_error",
      "std::runtime_error"
    ]
  },
  {
    "q": "What is the purpose of a 'noexcept' specifier in C++?",
    "o": [
      "It indicates that a function will not throw any exceptions.",
      "It indicates that a function will throw a specified exception.",
      "It allows a function to catch any type of exception.",
      "It forces a function to throw an exception."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::exception();\n    } catch (const std::exception& e) {\n        std::cout << \"Caught exception\" << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Caught exception",
      "Nothing",
      "std::exception",
      "An error occurred"
    ]
  },
  {
    "q": "Which of the following is correct about exception safety in C++?",
    "o": [
      "It refers to ensuring that operations are performed in a way that does not leave the program in an inconsistent state in case of an exception.",
      "It refers to preventing exceptions from being thrown in the program.",
      "It is the process of catching all exceptions.",
      "It is about terminating the program when an exception occurs."
    ]
  },
  {
    "q": "Which of the following is a valid syntax for creating a custom exception in C++?",
    "o": [
      "class MyException : public std::exception { public: const char* what() const throw() { return \"My custom exception\"; } };",
      "exception class MyException { public: const char* what() { return \"My custom exception\"; } };",
      "class MyException { public: const char* what() { return \"My custom exception\"; } };",
      "class MyException : std::exception { public: const char* what() { return \"My custom exception\"; } };"
    ]
  },
  {
    "q": "What happens if an exception is thrown outside a try block in C++?",
    "o": [
      "The program will terminate if no catch block is found.",
      "The exception will be ignored.",
      "The program will continue to execute normally.",
      "The exception will be caught by the first catch block."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::overflow_error(\"Overflow error\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Overflow error",
      "std::overflow_error",
      "Nothing",
      "An exception occurred"
    ]
  },
  {
    "q": "Which of the following types of exceptions does 'std::out_of_range' represent?",
    "o": [
      "It represents an exception that occurs when an index exceeds the valid range of elements in a container.",
      "It represents an exception that occurs when there is an error in memory allocation.",
      "It represents an exception for invalid function arguments.",
      "It represents a logic error in the program."
    ]
  },
  {
    "q": "Which of the following is true about custom exception classes in C++?",
    "o": [
      "Custom exceptions can be created by inheriting from the standard 'std::exception' class.",
      "Custom exceptions must inherit from 'std::runtime_error' only.",
      "Custom exceptions are automatically caught by catch blocks.",
      "Custom exceptions cannot be thrown in C++."
    ]
  },
  {
    "q": "What is the purpose of the 'noexcept' keyword in C++?",
    "o": [
      "It indicates that a function does not throw any exceptions.",
      "It throws an exception explicitly if the function is called.",
      "It marks the function to catch all exceptions.",
      "It indicates a function that handles exceptions."
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nvoid test() {\n    throw std::logic_error(\"Invalid logic\");\n}\n\nint main() {\n    try {\n        test();\n    } catch (const std::logic_error& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Invalid logic",
      "test()",
      "An error occurred",
      "Logic error"
    ]
  },
  {
    "q": "Which of the following statements about exception handling in C++ is correct?",
    "o": [
      "A function must declare the exceptions it might throw using the 'throw' specifier.",
      "Exceptions in C++ must always be handled within the same function they are thrown.",
      "The 'try' block should always be followed by a 'catch' block in C++.",
      "C++ does not support exception handling."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw 'A';\n    } catch (char e) {\n        std::cout << e << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "A",
      "char exception",
      "Nothing",
      "An error occurred"
    ]
  },
  {
    "q": "Which of the following exception classes is used to represent errors in input/output operations in C++?",
    "o": [
      "std::ios_base::failure",
      "std::invalid_argument",
      "std::out_of_range",
      "std::runtime_error"
    ]
  },
  {
    "q": "Which of the following is true about exception handling in C++ with multiple 'catch' blocks?",
    "o": [
      "The most specific exception should be caught first, followed by more general exceptions.",
      "All exceptions should be caught by a single catch block.",
      "The 'catch' blocks should be ordered randomly.",
      "The first 'catch' block should always catch any exception."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::runtime_error(\"Error\");\n    } catch (...) {\n        std::cout << \"Unknown exception\" << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Unknown exception",
      "Error",
      "An exception occurred",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is a best practice when handling exceptions in C++?",
    "o": [
      "Catch exceptions by reference to avoid slicing and ensure polymorphism.",
      "Always catch exceptions by value.",
      "Throw exceptions without catching them.",
      "Catch all exceptions as 'std::exception' only."
    ]
  },
  {
    "q": "What does the 'throw' statement do in C++?",
    "o": [
      "It throws an exception that can be caught by a catch block.",
      "It terminates the program immediately.",
      "It catches an exception that was thrown.",
      "It handles an exception."
    ]
  },
  {
    "q": "Which of the following standard exception classes is used for errors related to function arguments in C++?",
    "o": [
      "std::invalid_argument",
      "std::out_of_range",
      "std::runtime_error",
      "std::bad_alloc"
    ]
  },
  {
    "q": "What happens if an exception is thrown but not caught within the same function in C++?",
    "o": [
      "The exception propagates to the calling function or terminates the program if uncaught.",
      "The program continues executing normally.",
      "The exception is ignored and the program finishes.",
      "The program enters an infinite loop."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::bad_alloc();\n    } catch (const std::bad_alloc& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "std::bad_alloc",
      "Bad allocation error",
      "An allocation error occurred",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following exception classes is used to represent errors related to logic mistakes in C++?",
    "o": [
      "std::logic_error",
      "std::runtime_error",
      "std::invalid_argument",
      "std::overflow_error"
    ]
  },
  {
    "q": "What happens when an exception is thrown in a constructor in C++?",
    "o": [
      "The constructor fails, and the object is not created.",
      "The exception is caught automatically.",
      "The constructor proceeds and handles the exception.",
      "The program crashes immediately."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::range_error(\"Out of range\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Out of range",
      "std::range_error",
      "An error occurred",
      "Nothing"
    ]
  },
  {
    "q": "What is the purpose of exception safety in C++?",
    "o": [
      "To ensure that exceptions do not leave the program in an inconsistent state.",
      "To prevent the program from throwing exceptions.",
      "To automatically handle exceptions without a catch block.",
      "To terminate the program when an exception occurs."
    ]
  },
  {
    "q": "Which of the following is true about exception handling in C++?",
    "o": [
      "Only one 'catch' block can handle a specific exception type.",
      "A single catch block can handle multiple exception types.",
      "C++ does not support multiple 'catch' blocks.",
      "The 'catch' block must always come after the 'throw' block."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw 5;\n    } catch (int e) {\n        std::cout << e << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "5",
      "Nothing",
      "An exception occurred",
      "Error"
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::out_of_range(\"Index out of range\");\n    } catch (const std::out_of_range& e) {\n        std::cout << \"Caught: \" << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Caught: Index out of range",
      "std::out_of_range",
      "Index out of range",
      "An error occurred"
    ]
  },
  {
    "q": "Which of the following is correct about custom exception handling in C++?",
    "o": [
      "You can create custom exceptions by inheriting from the std::exception class.",
      "Custom exceptions must be handled by the system automatically.",
      "Custom exceptions can only be thrown using the 'throw' keyword.",
      "You cannot create custom exceptions in C++."
    ]
  },
  {
    "q": "What is the purpose of 'throw' in C++ exception handling?",
    "o": [
      "It is used to throw an exception.",
      "It is used to catch an exception.",
      "It is used to declare the type of exception.",
      "It is used to define an exception class."
    ]
  },
  {
    "q": "Which of the following is true about exception propagation in C++?",
    "o": [
      "If an exception is thrown and not caught in a function, it propagates to the calling function.",
      "Once an exception is thrown, it cannot be propagated.",
      "The program automatically handles exception propagation.",
      "All exceptions must be caught in the function where they are thrown."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::bad_cast();\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "std::bad_cast",
      "Bad cast error",
      "An exception occurred",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following exception types is used to indicate invalid or out-of-range access in C++ containers?",
    "o": [
      "std::out_of_range",
      "std::logic_error",
      "std::invalid_argument",
      "std::overflow_error"
    ]
  },
  {
    "q": "Which of the following statements about C++ exception handling is correct?",
    "o": [
      "You can catch exceptions by value, reference, or pointer.",
      "C++ exception handling only works with classes derived from std::exception.",
      "Exception handling in C++ requires a return type for the 'catch' block.",
      "Exceptions in C++ can only be caught in the main function."
    ]
  },
  {
    "q": "What is the behavior when a destructor throws an exception in C++?",
    "o": [
      "If a destructor throws an exception during object destruction, the program will terminate.",
      "The exception is caught by the destructor automatically.",
      "The exception is ignored and the object continues destruction.",
      "C++ will automatically handle the exception and continue executing."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::underflow_error(\"Underflow error\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Underflow error",
      "std::underflow_error",
      "An error occurred",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following exceptions is thrown when attempting to access an invalid memory address in C++?",
    "o": [
      "std::bad_access",
      "std::out_of_range",
      "std::invalid_argument",
      "std::bad_alloc"
    ]
  },
  {
    "q": "What is the purpose of exception safety in C++?",
    "o": [
      "To ensure that operations are performed without causing program inconsistencies when an exception is thrown.",
      "To prevent exceptions from being thrown in the program.",
      "To automatically handle and recover from exceptions.",
      "To terminate the program when an exception occurs."
    ]
  },
  {
    "q": "What happens when an exception is thrown inside a destructor in C++?",
    "o": [
      "If an exception is thrown during the destructor execution, it will terminate the program unless handled by a catch block.",
      "The exception is automatically caught by the system.",
      "The program continues and ignores the exception.",
      "The exception is thrown again to the caller."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw 3.14;\n    } catch (float e) {\n        std::cout << e << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "3.14",
      "float exception",
      "An error occurred",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following exceptions is thrown when a function encounters an argument that it cannot handle in C++?",
    "o": [
      "std::invalid_argument",
      "std::overflow_error",
      "std::runtime_error",
      "std::out_of_range"
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::runtime_error(\"Runtime exception\");\n    } catch (const std::exception& e) {\n        std::cout << \"Caught exception: \" << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Caught exception: Runtime exception",
      "Runtime exception",
      "Caught exception",
      "std::runtime_error"
    ]
  },
  {
    "q": "Which of the following exception classes is used for problems related to memory allocation in C++?",
    "o": [
      "std::bad_alloc",
      "std::runtime_error",
      "std::out_of_range",
      "std::invalid_argument"
    ]
  },
  {
    "q": "Which of the following statements about exception handling in C++ is true?",
    "o": [
      "Exception handling allows you to transfer control to the appropriate catch block when an error occurs.",
      "Exceptions in C++ must be caught by value, not reference.",
      "A catch block can catch exceptions only of the same type as the thrown exception.",
      "C++ does not support catching exceptions."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::overflow_error(\"Overflow detected\");\n    } catch (const std::overflow_error& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Overflow detected",
      "std::overflow_error",
      "An error occurred",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is true regarding exception handling in C++?",
    "o": [
      "The catch block can be used to handle exceptions and recover from errors.",
      "All exceptions must be caught in the same function where they are thrown.",
      "Exceptions are automatically handled in C++ without requiring a catch block.",
      "You cannot throw custom exceptions in C++."
    ]
  },
  {
    "q": "What does the 'throw' keyword do in C++?",
    "o": [
      "It is used to throw an exception from a function or block of code.",
      "It is used to catch exceptions.",
      "It is used to handle exceptions in the catch block.",
      "It is used to terminate a program when an exception occurs."
    ]
  },
  {
    "q": "Which of the following is the most appropriate exception class to use when accessing an element beyond the valid range of an array in C++?",
    "o": [
      "std::out_of_range",
      "std::invalid_argument",
      "std::runtime_error",
      "std::overflow_error"
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::logic_error(\"Logic error occurred\");\n    } catch (const std::logic_error& e) {\n        std::cout << \"Caught: \" << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Caught: Logic error occurred",
      "Logic error occurred",
      "std::logic_error",
      "An exception occurred"
    ]
  },
  {
    "q": "Which of the following is true about custom exception handling in C++?",
    "o": [
      "Custom exceptions can be created by inheriting from the std::exception class and overriding the 'what()' method.",
      "Custom exceptions must always be derived from std::runtime_error.",
      "Custom exceptions can only be used with the 'throw' keyword.",
      "Custom exceptions are automatically handled by the C++ runtime."
    ]
  },
  {
    "q": "Which of the following exception classes is used for errors related to I/O operations in C++?",
    "o": [
      "std::ios_base::failure",
      "std::invalid_argument",
      "std::runtime_error",
      "std::bad_alloc"
    ]
  },
  {
    "q": "What will happen if an exception is thrown in a 'catch' block in C++?",
    "o": [
      "The exception will propagate to the next outer try-catch block, if any.",
      "The program will terminate immediately.",
      "The exception will be ignored and the program will continue.",
      "The exception will be caught by the same catch block."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::bad_exception();\n    } catch (const std::bad_exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "std::bad_exception",
      "An exception occurred",
      "bad_exception error",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is the correct way to define a custom exception class in C++?",
    "o": [
      "class MyException : public std::exception { public: const char* what() const noexcept override { return \"My exception occurred\"; } };",
      "class MyException : public std::runtime_error { public: const char* what() const noexcept { return \"My exception occurred\"; } };",
      "class MyException { public: void what() { return \"My exception occurred\"; } };",
      "class MyException : public std::logic_error { public: const char* what() { return \"My exception occurred\"; } };"
    ]
  },
  {
    "q": "What is the purpose of 'std::terminate' in C++ exception handling?",
    "o": [
      "It is called when no matching catch block is found and the program is about to terminate.",
      "It is used to automatically catch all exceptions in the program.",
      "It throws an exception when a runtime error occurs.",
      "It catches and handles all thrown exceptions."
    ]
  },
  {
    "q": "What is the behavior when an exception is thrown from a function without being caught?",
    "o": [
      "The exception propagates to the caller until it is caught or the program terminates.",
      "The exception is ignored and the program continues normally.",
      "The exception is caught automatically by the compiler.",
      "The function execution is aborted, and no further code is executed."
    ]
  },
  {
    "q": "Which of the following statements is true about exception handling in C++?",
    "o": [
      "Exception handling in C++ is done using 'try', 'catch', and 'throw' blocks.",
      "C++ supports automatic handling of exceptions without the need for 'catch' blocks.",
      "You can only throw exceptions of type 'std::exception' in C++.",
      "Once an exception is thrown, the program terminates immediately unless caught."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw 100;\n    } catch (int e) {\n        std::cout << e << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "100",
      "An exception occurred",
      "int exception",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following standard exception classes is used to represent an error that occurs during the program’s execution?",
    "o": [
      "std::runtime_error",
      "std::bad_alloc",
      "std::invalid_argument",
      "std::overflow_error"
    ]
  },
  {
    "q": "What is the purpose of the 'noexcept' specifier in C++?",
    "o": [
      "It specifies that a function does not throw any exceptions.",
      "It is used to indicate that a function will always throw an exception.",
      "It marks a function to handle exceptions within it.",
      "It ensures that a function catches all exceptions automatically."
    ]
  },
  {
    "q": "What will happen if a destructor throws an exception in C++?",
    "o": [
      "The program will terminate unless the exception is caught by another catch block.",
      "The exception will be caught automatically and handled.",
      "The program continues execution normally, ignoring the exception.",
      "The exception is logged, and the program proceeds."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::out_of_range(\"Out of range exception\");\n    } catch (const std::out_of_range& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Out of range exception",
      "std::out_of_range",
      "Out of range",
      "An exception occurred"
    ]
  },
  {
    "q": "Which of the following is true about exception handling in C++?",
    "o": [
      "C++ allows throwing exceptions of any type, including primitive types.",
      "Only objects of class types can be thrown as exceptions.",
      "Exceptions in C++ must be derived from std::exception.",
      "Exceptions must always be caught in the same function in which they are thrown."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw 42;\n    } catch (int e) {\n        std::cout << \"Caught exception: \" << e << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Caught exception: 42",
      "42",
      "int exception",
      "An error occurred"
    ]
  },
  {
    "q": "What is the role of the 'throw' keyword in C++?",
    "o": [
      "It is used to throw an exception explicitly.",
      "It is used to handle exceptions.",
      "It is used to define an exception handler.",
      "It terminates the program immediately."
    ]
  },
  {
    "q": "Which of the following exception types is thrown when a program attempts to divide by zero in C++?",
    "o": [
      "std::domain_error",
      "std::invalid_argument",
      "std::overflow_error",
      "std::runtime_error"
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::ios_base::failure(\"File not found\");\n    } catch (const std::ios_base::failure& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "File not found",
      "std::ios_base::failure",
      "I/O failure",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is true about exception handling in C++?",
    "o": [
      "Multiple catch blocks can be used to handle different types of exceptions.",
      "Exception handling is not supported in C++.",
      "C++ exceptions can only be caught by reference.",
      "The throw keyword can only throw objects derived from std::exception."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::logic_error(\"Logic error\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Logic error",
      "std::logic_error",
      "An error occurred",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is true about exception handling in C++?",
    "o": [
      "Exception handling in C++ is done using 'try', 'catch', and 'throw' blocks.",
      "C++ uses 'catch' blocks to throw exceptions.",
      "In C++, exceptions cannot be caught or thrown.",
      "Exception handling in C++ is not supported for custom exceptions."
    ]
  },
  {
    "q": "What will happen if an exception is thrown inside a 'catch' block in C++?",
    "o": [
      "The exception will propagate to the next outer try-catch block if one exists.",
      "The program will terminate immediately.",
      "The exception will be automatically handled and ignored.",
      "The exception will be re-thrown in the same catch block."
    ]
  },
  {
    "q": "What is the correct syntax for throwing an exception in C++?",
    "o": [
      "throw exception_type(\"message\");",
      "throw (exception_type) \"message\";",
      "throw exception_type:message;",
      "throw new exception_type(\"message\");"
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::runtime_error(\"Runtime error\");\n    } catch (const std::runtime_error& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Runtime error",
      "std::runtime_error",
      "An error occurred",
      "Runtime exception"
    ]
  },
  {
    "q": "Which of the following is the correct way to define a custom exception class that inherits from std::exception in C++?",
    "o": [
      "class MyException : public std::exception { public: const char* what() const noexcept override { return \"My custom exception\"; } };",
      "class MyException : public std::logic_error { public: const char* what() { return \"My custom exception\"; } };",
      "class MyException { public: const char* what() { return \"My custom exception\"; } };",
      "class MyException : public std::exception { public: void what() { return \"My custom exception\"; } };"
    ]
  },
  {
    "q": "What will happen if no exception is thrown inside the 'try' block in C++?",
    "o": [
      "The catch block will be skipped.",
      "The program will terminate.",
      "The catch block will automatically execute.",
      "The program will output a message indicating no exception."
    ]
  },
  {
    "q": "Which of the following is a standard exception class in C++ that indicates invalid arguments were passed to a function?",
    "o": [
      "std::invalid_argument",
      "std::out_of_range",
      "std::overflow_error",
      "std::domain_error"
    ]
  },
  {
    "q": "What does the 'noexcept' specifier do in C++?",
    "o": [
      "Indicates that a function does not throw any exceptions.",
      "Ensures that a function catches all exceptions.",
      "Marks a function to throw exceptions if needed.",
      "Automatically handles exceptions within the function."
    ]
  },
  {
    "q": "What is the result when an exception is thrown from a constructor in C++?",
    "o": [
      "The constructor call is aborted, and any partially constructed objects are destroyed.",
      "The exception is ignored, and the object is created.",
      "The constructor continues to execute even after the exception is thrown.",
      "The exception is automatically caught by a destructor."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::overflow_error(\"Overflow error\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Overflow error",
      "std::overflow_error",
      "An error occurred",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is true about the 'catch' block in C++?",
    "o": [
      "It can catch exceptions of different types using multiple catch blocks.",
      "It must always be followed by a 'try' block.",
      "It catches only the most specific exceptions.",
      "You cannot use multiple catch blocks in C++."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::bad_alloc();\n    } catch (const std::bad_alloc& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "std::bad_alloc",
      "Memory allocation failed",
      "An error occurred",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is true about exception handling in C++?",
    "o": [
      "Exception handling can be used to recover from errors and maintain the program's stability.",
      "You must always throw an exception from a function.",
      "C++ does not support handling multiple types of exceptions.",
      "Once an exception is caught, it cannot be rethrown."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::exception();\n    } catch (const std::exception& e) {\n        std::cout << \"Caught exception: \" << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Caught exception: std::exception",
      "std::exception",
      "Caught exception",
      "An exception occurred"
    ]
  },
  {
    "q": "What is the behavior of a program if an exception is thrown during the execution of a 'catch' block in C++?",
    "o": [
      "The exception will propagate to the next outer try-catch block if available.",
      "The program will immediately terminate.",
      "The exception will be ignored, and the program continues.",
      "The catch block will execute again."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::underflow_error(\"Underflow error\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Underflow error",
      "std::underflow_error",
      "An exception occurred",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is true about exception handling in C++?",
    "o": [
      "The 'throw' keyword is used to throw an exception.",
      "The 'catch' block can only catch exceptions of the same type as the thrown exception.",
      "Only objects derived from std::exception can be thrown.",
      "C++ allows you to catch exceptions using only one catch block."
    ]
  },
  {
    "q": "What happens if an exception is thrown and there is no matching catch block in C++?",
    "o": [
      "The program terminates by calling std::terminate.",
      "The exception is silently ignored and the program continues.",
      "The exception is automatically handled by C++.",
      "The program will restart from the beginning."
    ]
  },
  {
    "q": "Which of the following is the correct way to define a custom exception in C++?",
    "o": [
      "class MyException : public std::exception { public: const char* what() const noexcept override { return \"My custom exception\"; } };",
      "class MyException : public std::logic_error { public: const char* message() const { return \"My custom exception\"; } };",
      "class MyException : public std::runtime_error { public: std::string what() { return \"My custom exception\"; } };",
      "class MyException { public: const char* message() const { return \"My custom exception\"; } };"
    ]
  },
  {
    "q": "What is the behavior when an exception is thrown from a destructor in C++?",
    "o": [
      "The program terminates unless the exception is caught by another catch block.",
      "The destructor will continue executing even after the exception is thrown.",
      "The exception will be silently ignored.",
      "The exception will be caught automatically by the catch block."
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::invalid_argument(\"Invalid argument\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Invalid argument",
      "std::invalid_argument",
      "An error occurred",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following statements about exception handling in C++ is true?",
    "o": [
      "Multiple catch blocks can be used to handle different types of exceptions.",
      "You must use a 'catch' block for every 'try' block.",
      "C++ exceptions can only be caught by value, not by reference.",
      "C++ does not allow catching exceptions of primitive types."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::overflow_error(\"Overflow error\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Overflow error",
      "std::overflow_error",
      "An exception occurred",
      "Overflow exception"
    ]
  },
  {
    "q": "Which of the following is an example of exception safety in C++?",
    "o": [
      "Ensuring that a function does not leave the program in an inconsistent state if an exception is thrown.",
      "Catching all exceptions and handling them immediately.",
      "Throwing an exception if a function fails to execute.",
      "Using 'noexcept' to mark functions that never throw exceptions."
    ]
  },
  {
    "q": "What is the purpose of the 'throw' expression in C++ exception handling?",
    "o": [
      "It is used to throw an exception explicitly from a function or block.",
      "It is used to catch exceptions thrown by other functions.",
      "It marks a function that can handle exceptions.",
      "It ensures that an exception will not be thrown."
    ]
  },
  {
    "q": "What will happen if a function declared with 'noexcept' throws an exception in C++?",
    "o": [
      "The program will call std::terminate and terminate the program.",
      "The exception will be caught automatically by the system.",
      "The function will silently handle the exception.",
      "The exception will be propagated and handled in a catch block."
    ]
  },
  {
    "q": "Which of the following is true about the exception handling mechanism in C++?",
    "o": [
      "C++ supports both synchronous and asynchronous exception handling.",
      "Once an exception is thrown, it cannot be caught in C++.",
      "A function can throw multiple exceptions of the same type.",
      "Exceptions can only be thrown from function calls."
    ]
  },
  {
    "q": "What is the result of throwing an exception inside a catch block in C++?",
    "o": [
      "The exception will propagate to the next outer try-catch block, if any.",
      "The catch block will automatically catch the new exception.",
      "The program will continue execution after the catch block.",
      "The exception will be logged and the program will continue."
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::ios_base::failure(\"I/O operation failed\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "I/O operation failed",
      "std::ios_base::failure",
      "I/O error",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is an example of a standard exception in C++?",
    "o": [
      "std::out_of_range",
      "std::my_exception",
      "std::custom_error",
      "std::not_found"
    ]
  },
  {
    "q": "What will happen if a function throws an exception that is not caught in C++?",
    "o": [
      "The program will call std::terminate and terminate the program.",
      "The exception will be ignored and the program will continue.",
      "The program will automatically catch and handle the exception.",
      "The function will silently return with an error."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::bad_cast();\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "std::bad_cast",
      "Bad cast exception",
      "Casting error",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following statements about exception handling in C++ is correct?",
    "o": [
      "A 'catch' block can catch exceptions by reference, which is the most efficient way.",
      "You cannot catch exceptions by reference in C++.",
      "A 'catch' block must always be preceded by a 'try' block in C++.",
      "The 'throw' keyword must be used to catch an exception."
    ]
  },
  {
    "q": "What is the result of throwing an exception from a function marked 'noexcept' in C++?",
    "o": [
      "The program will call std::terminate and the program will terminate.",
      "The exception will be ignored and execution will continue.",
      "The function will handle the exception and return normally.",
      "The exception will be caught automatically by the catch block."
    ]
  },
  {
    "q": "Which of the following is true about exception safety in C++?",
    "o": [
      "A function is exception-safe if it ensures no resource leaks or undefined behavior when an exception is thrown.",
      "Exception safety means that all exceptions must be caught inside the function.",
      "A function is exception-safe if it can throw multiple exceptions.",
      "Exception safety is not a concern in C++."
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::range_error(\"Range error\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Range error",
      "std::range_error",
      "An error occurred",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is a valid way to catch exceptions of different types in C++?",
    "o": [
      "By using multiple 'catch' blocks, each handling a different exception type.",
      "By using a single 'catch' block with a universal reference.",
      "By using a single 'catch' block with multiple exception types listed.",
      "By using 'catch(...)' to catch all exceptions."
    ]
  },
  {
    "q": "What happens if an exception is thrown from the destructor of an object in C++?",
    "o": [
      "The program will call std::terminate, and the program will terminate.",
      "The exception is automatically caught by the catch block.",
      "The destructor will complete its execution after throwing the exception.",
      "The exception will be ignored and the object will still be destroyed."
    ]
  },
  {
    "q": "What is the purpose of using the 'noexcept' specifier in C++?",
    "o": [
      "It marks functions that are not supposed to throw exceptions.",
      "It allows functions to catch exceptions without terminating the program.",
      "It forces functions to catch exceptions and handle them.",
      "It makes the function throw exceptions automatically if necessary."
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::out_of_range(\"Out of range error\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Out of range error",
      "std::out_of_range",
      "Out of range exception",
      "An error occurred"
    ]
  },
  {
    "q": "Which of the following is an example of a standard exception in C++?",
    "o": [
      "std::runtime_error",
      "std::exception_error",
      "std::custom_exception",
      "std::user_error"
    ]
  },
  {
    "q": "What is the behavior of the program when an exception is thrown but not caught in C++?",
    "o": [
      "The program will terminate by calling std::terminate.",
      "The program will ignore the exception and continue execution.",
      "The program will catch the exception automatically.",
      "The exception will be logged but not handled."
    ]
  },
  {
    "q": "Which of the following is a valid way to define a custom exception class in C++?",
    "o": [
      "class MyException : public std::exception { public: const char* what() const noexcept override { return \"My custom exception\"; } };",
      "class MyException : public std::exception { void message() { return \"My custom exception\"; } };",
      "class MyException { public: const char* what() { return \"My custom exception\"; } };",
      "class MyException : public std::runtime_error { public: const char* message() { return \"My custom exception\"; } };"
    ]
  },
  {
    "q": "What is the result of throwing an exception from a 'catch' block in C++?",
    "o": [
      "The exception will propagate to the next outer 'try' block.",
      "The exception will be caught by the same 'catch' block.",
      "The program will terminate immediately.",
      "The exception will be ignored, and the program will continue."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::logic_error(\"Logic error\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Logic error",
      "std::logic_error",
      "An error occurred",
      "Nothing"
    ]
  },
  {
    "q": "What happens when an exception is thrown inside a constructor in C++?",
    "o": [
      "The constructor's execution is aborted, and the object is not created.",
      "The exception is automatically handled by the destructor.",
      "The program will attempt to handle the exception and continue.",
      "The constructor will complete execution after the exception is thrown."
    ]
  },
  {
    "q": "Which of the following is true about custom exception classes in C++?",
    "o": [
      "Custom exceptions should inherit from std::exception or one of its derived classes.",
      "Custom exceptions can be defined without inheriting from any class.",
      "Custom exceptions are not allowed in C++.",
      "Custom exceptions must always be caught by value."
    ]
  },
  {
    "q": "What is the result of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::invalid_argument(\"Invalid argument error\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Invalid argument error",
      "std::invalid_argument",
      "Argument error",
      "Nothing"
    ]
  },
  {
    "q": "What is the behavior of the 'catch' block when it catches an exception in C++?",
    "o": [
      "It handles the exception and allows the program to continue.",
      "It ignores the exception and allows the program to continue without any change.",
      "It causes the program to terminate immediately.",
      "It modifies the exception and rethrows it."
    ]
  },
  {
    "q": "Which of the following is true about exception handling in C++?",
    "o": [
      "The 'throw' keyword is used to throw an exception from a function.",
      "You cannot catch an exception inside a 'catch' block if it's already been caught by another block.",
      "A 'catch' block must be preceded by a return statement.",
      "C++ exceptions cannot be caught by reference."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::overflow_error(\"Overflow occurred\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Overflow occurred",
      "std::overflow_error",
      "Overflow exception",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following statements about the 'try' block in C++ is true?",
    "o": [
      "A 'try' block can contain any code that may throw exceptions.",
      "A 'try' block can only be used to handle runtime errors.",
      "A 'try' block must always be followed by a 'return' statement.",
      "A 'try' block can only handle exceptions thrown by functions."
    ]
  },
  {
    "q": "What happens when an exception is thrown, but no 'catch' block exists to handle it in C++?",
    "o": [
      "The program terminates by calling std::terminate.",
      "The exception is silently ignored, and the program continues.",
      "The exception is handled by the next 'catch' block if one exists.",
      "The program attempts to handle the exception after some time."
    ]
  },
  {
    "q": "What is the behavior when an exception is thrown inside a 'catch' block in C++?",
    "o": [
      "The exception is propagated to the outer 'try-catch' block.",
      "The program continues executing normally after the 'catch' block.",
      "The exception is caught again in the same 'catch' block.",
      "The program will terminate immediately."
    ]
  },
  {
    "q": "Which of the following exception types is part of the C++ standard library?",
    "o": [
      "std::logic_error",
      "std::user_error",
      "std::system_error",
      "std::fatal_exception"
    ]
  },
  {
    "q": "Which of the following is the correct way to define a custom exception in C++?",
    "o": [
      "class MyException : public std::exception { public: const char* what() const noexcept override { return \"My custom exception\"; } };",
      "class MyException : public std::exception { public: void what() { return \"My custom exception\"; } };",
      "class MyException { public: const char* what() { return \"My custom exception\"; } };",
      "class MyException : public std::runtime_error { public: const char* what() { return \"My custom exception\"; } };"
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::range_error(\"Range error occurred\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Range error occurred",
      "std::range_error",
      "Range error",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is an example of a C++ standard exception class?",
    "o": [
      "std::runtime_error",
      "std::user_error",
      "std::fatal_error",
      "std::my_error"
    ]
  },
  {
    "q": "What will happen if a function marked with 'noexcept' throws an exception in C++?",
    "o": [
      "The program will call std::terminate and terminate the program.",
      "The exception will be caught automatically by the system.",
      "The exception will be handled by the function that called it.",
      "The function will handle the exception and return normally."
    ]
  },
  {
    "q": "Which of the following statements about exception propagation in C++ is true?",
    "o": [
      "An exception propagates up the call stack until it is caught by a matching catch block.",
      "An exception propagates down the call stack until it is caught.",
      "An exception is caught only if it matches the exact type of the thrown object.",
      "An exception cannot propagate past the first catch block."
    ]
  },
  {
    "q": "What happens when a destructor throws an exception in C++?",
    "o": [
      "The program terminates immediately.",
      "The exception is ignored, and the program continues.",
      "The exception is handled by the catch block.",
      "The destructor will continue executing after the exception."
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::ios_base::failure(\"I/O operation failed\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "I/O operation failed",
      "std::ios_base::failure",
      "I/O error",
      "Nothing"
    ]
  },
  {
    "q": "What will be the behavior of the program if an exception is thrown inside a try block but is not caught by a corresponding catch block in C++?",
    "o": [
      "The program will terminate by calling std::terminate.",
      "The program will continue execution as if no exception was thrown.",
      "The program will attempt to catch the exception from the global scope.",
      "The exception will be logged and ignored."
    ]
  },
  {
    "q": "Which of the following is true about throwing exceptions in C++?",
    "o": [
      "Any type of object can be thrown as an exception in C++.",
      "Only exceptions of type std::exception can be thrown.",
      "C++ only allows throwing exceptions of primitive data types.",
      "C++ does not allow throwing exceptions."
    ]
  },
  {
    "q": "What is the purpose of the 'throw' keyword in C++?",
    "o": [
      "It is used to throw an exception from a function or block.",
      "It is used to define a custom exception class.",
      "It is used to catch exceptions from a try block.",
      "It is used to terminate the program on error."
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::underflow_error(\"Underflow occurred\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Underflow occurred",
      "std::underflow_error",
      "Underflow exception",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is true about exception handling in C++?",
    "o": [
      "A function must declare that it may throw exceptions using the 'throw' specifier if it might throw one.",
      "C++ does not support throwing exceptions of custom types.",
      "The 'try' block must contain at least one 'catch' block.",
      "Exception handling in C++ is not recommended because it slows down program execution."
    ]
  },
  {
    "q": "What is the purpose of using exception handling in C++?",
    "o": [
      "To handle errors and exceptional conditions without terminating the program.",
      "To improve the performance of the program.",
      "To automatically fix bugs in the code.",
      "To prevent memory allocation errors."
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::bad_alloc();\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "std::bad_alloc",
      "Bad allocation error",
      "Memory allocation failed",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following statements is true about catching exceptions in C++?",
    "o": [
      "Exceptions should always be caught by reference to avoid object slicing.",
      "You cannot catch exceptions of type 'std::exception' in C++.",
      "The 'catch' block must always be placed inside a 'try' block.",
      "You can catch multiple exceptions of different types using one 'catch' block."
    ]
  },
  {
    "q": "What will happen if a function marked with 'noexcept' throws an exception in C++?",
    "o": [
      "The program will terminate by calling std::terminate.",
      "The exception will be caught and handled automatically.",
      "The exception will be propagated to the caller of the function.",
      "The program will continue executing without any issues."
    ]
  },
  {
    "q": "Which of the following C++ exception classes is used to represent an error caused by invalid arguments?",
    "o": [
      "std::invalid_argument",
      "std::out_of_range",
      "std::runtime_error",
      "std::ios_base::failure"
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::exception();\n    } catch (const std::exception& e) {\n        std::cout << \"Exception caught: \" << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Exception caught: std::exception",
      "Exception caught",
      "std::exception",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is an exception class used for logical errors in C++?",
    "o": [
      "std::logic_error",
      "std::overflow_error",
      "std::range_error",
      "std::ios_base::failure"
    ]
  },
  {
    "q": "What will happen if an exception is thrown inside a destructor in C++?",
    "o": [
      "The program will terminate immediately due to an unhandled exception in the destructor.",
      "The exception will be ignored, and the destructor will continue executing.",
      "The exception will be handled by the surrounding 'try-catch' block.",
      "The exception will be propagated to the next catch block."
    ]
  },
  {
    "q": "Which of the following is a valid approach for throwing a custom exception in C++?",
    "o": [
      "Throw an object of the custom exception class derived from std::exception.",
      "Throw a string literal.",
      "Throw a function pointer.",
      "Throw an integer value."
    ]
  },
  {
    "q": "Which of the following statements is true about exception handling with 'try' and 'catch' in C++?",
    "o": [
      "A 'catch' block can handle multiple types of exceptions if specified in the catch block.",
      "The 'try' block should not contain any code that does not throw an exception.",
      "The 'catch' block must always catch exceptions by value to avoid issues.",
      "You can only have one 'catch' block in a 'try-catch' construct."
    ]
  },
  {
    "q": "What is the behavior when an exception is thrown and not caught by any 'catch' block in C++?",
    "o": [
      "The program will call std::terminate and terminate.",
      "The program will continue executing after ignoring the exception.",
      "The exception will be logged but not handled.",
      "The program will pause until the exception is handled."
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::ios_base::failure(\"I/O failure\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "I/O failure",
      "std::ios_base::failure",
      "I/O error",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is true about exception safety in C++?",
    "o": [
      "A function is considered exception-safe if it guarantees no resource leaks or undefined behavior when an exception is thrown.",
      "Exception safety in C++ is a concern only for multi-threaded applications.",
      "A function is considered exception-safe if it catches all exceptions.",
      "The term 'exception-safe' means the program always recovers from an exception."
    ]
  },
  {
    "q": "What is the correct way to catch all exceptions in C++?",
    "o": [
      "catch(...)",
      "catch(std::exception& e)",
      "catch(Exception& e)",
      "catch(void)"
    ]
  },
  {
    "q": "What will happen if an exception is thrown in a constructor and not handled in C++?",
    "o": [
      "The object construction will be aborted, and the program will look for an outer exception handler.",
      "The constructor will return normally without any issues.",
      "The program will catch the exception and continue execution.",
      "The exception will be caught by the destructor."
    ]
  },
  {
    "q": "Which of the following is a standard exception class used to handle errors in input/output operations in C++?",
    "o": [
      "std::ios_base::failure",
      "std::input_error",
      "std::io_error",
      "std::system_error"
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::overflow_error(\"Overflow error occurred\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Overflow error occurred",
      "std::overflow_error",
      "Overflow exception",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following exception types can be used to handle runtime errors in C++?",
    "o": [
      "std::runtime_error",
      "std::bad_alloc",
      "std::ios_base::failure",
      "std::range_error"
    ]
  },
  {
    "q": "Which of the following is true about the 'catch' block in C++?",
    "o": [
      "A 'catch' block can catch exceptions of a specific type or its base type.",
      "A 'catch' block can only catch exceptions that match the type of the thrown object exactly.",
      "A 'catch' block can only catch exceptions of type std::exception.",
      "The 'catch' block must always follow a 'try' block with no intervening statements."
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::underflow_error(\"Underflow error occurred\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Underflow error occurred",
      "std::underflow_error",
      "Underflow exception",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is true about the 'throw' keyword in C++?",
    "o": [
      "The 'throw' keyword is used to explicitly throw exceptions from a function.",
      "The 'throw' keyword is used to handle exceptions thrown by other functions.",
      "The 'throw' keyword can only be used inside 'catch' blocks.",
      "The 'throw' keyword terminates the program immediately."
    ]
  },
  {
    "q": "What is the purpose of exception handling in C++?",
    "o": [
      "To handle unexpected errors or exceptional conditions without terminating the program.",
      "To improve the speed of the program's execution.",
      "To ensure all memory allocations are managed efficiently.",
      "To log errors without interrupting the program flow."
    ]
  },
  {
    "q": "What happens if an exception is thrown in a constructor but not caught in C++?",
    "o": [
      "The object construction is aborted, and the exception propagates to the calling code.",
      "The object is still constructed, but its state will be inconsistent.",
      "The exception is automatically handled by the compiler.",
      "The program terminates immediately."
    ]
  },
  {
    "q": "What is the behavior when a destructor throws an exception in C++?",
    "o": [
      "The exception is propagated to the calling function, and std::terminate is called if not handled.",
      "The exception is silently ignored, and the program continues executing.",
      "The destructor is aborted, but the exception is handled normally.",
      "The program terminates without any further action."
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::logic_error(\"Logic error occurred\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Logic error occurred",
      "std::logic_error",
      "Logic exception",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is a valid way to define a custom exception class in C++?",
    "o": [
      "class MyException : public std::exception { public: const char* what() const noexcept override { return \"Custom exception\"; } };",
      "class MyException { public: void what() { return \"Custom exception\"; } };",
      "class MyException : public std::runtime_error { public: const char* what() { return \"Custom exception\"; } };",
      "class MyException { public: const char* what() { return \"Custom exception\"; } };"
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::invalid_argument(\"Invalid argument error\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Invalid argument error",
      "std::invalid_argument",
      "Argument error",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following statements is true about exception handling in C++?",
    "o": [
      "A 'try' block must be followed by one or more 'catch' blocks.",
      "You can catch multiple types of exceptions in a single 'catch' block using 'or' conditions.",
      "C++ does not support the 'try-catch' mechanism.",
      "Exception handling in C++ is slower than in other languages."
    ]
  },
  {
    "q": "Which of the following is true about exception propagation in C++?",
    "o": [
      "Exceptions propagate up the call stack until they are caught by a matching 'catch' block.",
      "Exceptions propagate down the call stack until they are caught.",
      "Exceptions only propagate within the same function scope.",
      "Exceptions cannot propagate beyond the 'try' block."
    ]
  },
  {
    "q": "What is the result of throwing an exception in a function that is marked 'noexcept' in C++?",
    "o": [
      "The program terminates immediately by calling std::terminate.",
      "The exception is caught automatically by the system.",
      "The function will return without throwing the exception.",
      "The exception will be propagated to the calling function."
    ]
  },
  {
    "q": "Which of the following is the correct syntax for catching exceptions in C++?",
    "o": [
      "catch (const std::exception& e) { // code }",
      "catch { // code }",
      "catch (std::exception e) { // code }",
      "catch (std::exception& e) { // code }"
    ]
  },
  {
    "q": "Which of the following statements about exception safety in C++ is true?",
    "o": [
      "A function is considered exception-safe if it guarantees no resource leaks or undefined behavior when an exception is thrown.",
      "A function is exception-safe if it always catches and handles all exceptions.",
      "A function is exception-safe if it does not use 'throw' anywhere.",
      "A function is exception-safe if it throws exceptions with a specific type."
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::bad_alloc();\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "std::bad_alloc",
      "Bad allocation error",
      "Memory allocation failed",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following exception classes is used to represent errors in input/output operations in C++?",
    "o": [
      "std::ios_base::failure",
      "std::invalid_argument",
      "std::out_of_range",
      "std::range_error"
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::runtime_error(\"Runtime error\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Runtime error",
      "std::runtime_error",
      "Runtime exception",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following statements about the 'throw' keyword in C++ is true?",
    "o": [
      "The 'throw' keyword is used to explicitly throw exceptions in C++.",
      "The 'throw' keyword is used to catch exceptions in C++.",
      "The 'throw' keyword can only be used inside 'catch' blocks.",
      "The 'throw' keyword is used to define custom exception classes."
    ]
  },
  {
    "q": "What is the purpose of the 'noexcept' specifier in C++?",
    "o": [
      "It indicates that a function does not throw any exceptions.",
      "It allows a function to throw exceptions without specifying the types.",
      "It guarantees that the function will handle all exceptions internally.",
      "It is used to catch exceptions in a specific block."
    ]
  },
  {
    "q": "Which of the following is a valid exception class for handling input/output errors in C++?",
    "o": [
      "std::ios_base::failure",
      "std::input_error",
      "std::io_error",
      "std::system_error"
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::out_of_range(\"Out of range error\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Out of range error",
      "std::out_of_range",
      "Range error",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following exception types can be used to handle memory allocation failures in C++?",
    "o": [
      "std::bad_alloc",
      "std::overflow_error",
      "std::ios_base::failure",
      "std::invalid_argument"
    ]
  },
  {
    "q": "What happens if an exception is thrown inside a destructor in C++?",
    "o": [
      "The program calls std::terminate and terminates.",
      "The exception is caught automatically by the system.",
      "The exception is ignored, and the program continues.",
      "The exception is handled by the destructor's catch block."
    ]
  },
  {
    "q": "Which of the following C++ classes is derived from std::exception and used for invalid arguments?",
    "o": [
      "std::invalid_argument",
      "std::out_of_range",
      "std::range_error",
      "std::ios_base::failure"
    ]
  },
  {
    "q": "Which of the following is a correct way to declare a custom exception class in C++?",
    "o": [
      "class MyException : public std::exception { public: const char* what() const noexcept override { return \"Custom exception\"; } };",
      "class MyException { public: const char* what() { return \"Custom exception\"; } };",
      "class MyException : public std::runtime_error { public: const char* what() { return \"Custom exception\"; } };",
      "class MyException { public: const char* message; MyException() { message = \"Custom exception\"; } };"
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::logic_error(\"Logic error\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Logic error",
      "std::logic_error",
      "Logic exception",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following statements is true about exception handling in C++?",
    "o": [
      "A function that may throw an exception must declare it with the 'throw' keyword in its signature.",
      "You cannot catch exceptions by reference in C++.",
      "C++ supports multiple inheritance for exceptions.",
      "All exceptions must be caught by value."
    ]
  },
  {
    "q": "What happens if an exception is thrown in a function marked with 'noexcept' in C++?",
    "o": [
      "The program will terminate by calling std::terminate.",
      "The function will return without throwing the exception.",
      "The exception will be caught automatically by the compiler.",
      "The exception will be handled in the 'catch' block."
    ]
  },
  {
    "q": "Which of the following is true about exception propagation in C++?",
    "o": [
      "When an exception is thrown, it propagates up the call stack until it is caught.",
      "Exceptions are always caught within the same function where they are thrown.",
      "Exceptions propagate down the call stack.",
      "Exceptions cannot propagate across function boundaries."
    ]
  },
  {
    "q": "What is the result of catching an exception by value in C++?",
    "o": [
      "The exception object is copied, which may lead to object slicing if the type is derived.",
      "The exception object is passed by reference to avoid object slicing.",
      "The exception is ignored, and the program continues.",
      "The program terminates with an error."
    ]
  },
  {
    "q": "What is the purpose of the 'catch' block in C++ exception handling?",
    "o": [
      "The 'catch' block handles exceptions thrown by the 'try' block.",
      "The 'catch' block defines a custom exception class.",
      "The 'catch' block throws new exceptions.",
      "The 'catch' block guarantees that the program will terminate."
    ]
  },
  {
    "q": "Which of the following is true about catching multiple exceptions in C++?",
    "o": [
      "You can catch multiple types of exceptions in separate 'catch' blocks.",
      "You cannot catch exceptions of different types in C++.",
      "You must catch all exceptions in a single 'catch' block.",
      "C++ does not allow catching any exceptions."
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::out_of_range(\"Out of range\");\n    } catch (const std::out_of_range& e) {\n        std::cout << \"Caught: \" << e.what() << std::endl;\n    } catch (const std::exception& e) {\n        std::cout << \"Caught general exception\" << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Caught: Out of range",
      "Caught general exception",
      "Out of range",
      "Nothing"
    ]
  },
  {
    "q": "What is the behavior of exception handling when an exception is thrown from a destructor in C++?",
    "o": [
      "The program terminates immediately due to an unhandled exception in the destructor.",
      "The exception is silently ignored, and the program continues.",
      "The exception is propagated to the next catch block.",
      "The exception is automatically handled by C++."
    ]
  },
  {
    "q": "What is the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::invalid_argument(\"Invalid argument exception\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Invalid argument exception",
      "std::invalid_argument",
      "Argument exception",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is a standard exception type that can be thrown for errors involving the logic of the program?",
    "o": [
      "std::logic_error",
      "std::overflow_error",
      "std::bad_alloc",
      "std::invalid_argument"
    ]
  },
  {
    "q": "Which of the following statements about 'try' and 'catch' blocks is true in C++?",
    "o": [
      "A 'try' block must be followed by at least one 'catch' block.",
      "A 'catch' block can exist without a preceding 'try' block.",
      "Multiple 'try' blocks can be chained without a 'catch' block.",
      "Only one 'catch' block is allowed per 'try' block."
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::runtime_error(\"Runtime error\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Runtime error",
      "std::runtime_error",
      "Runtime exception",
      "Nothing"
    ]
  },
  {
    "q": "What is the result of catching a derived exception type in a base class 'catch' block in C++?",
    "o": [
      "The exception is handled by the base class catch block, and polymorphism is used.",
      "The exception will not be caught, and the program will terminate.",
      "Only base exceptions can be caught by base class catch blocks.",
      "The exception will be ignored by the base class catch block."
    ]
  },
  {
    "q": "Which of the following is true regarding the use of custom exception classes in C++?",
    "o": [
      "Custom exception classes should inherit from std::exception to ensure compatibility with standard exception handling.",
      "Custom exception classes cannot be used with the 'throw' keyword.",
      "Custom exception classes must be derived from std::runtime_error.",
      "Custom exception classes must provide a 'catch' block."
    ]
  },
  {
    "q": "What happens if an exception is thrown but not caught in C++?",
    "o": [
      "The program terminates, and std::terminate is called.",
      "The exception is ignored, and the program continues executing.",
      "The exception is caught by the default handler.",
      "The program enters an infinite loop."
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::out_of_range(\"Out of range exception\");\n    } catch (const std::out_of_range& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Out of range exception",
      "std::out_of_range",
      "Range exception",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following exception types is used for invalid memory access or allocation failure in C++?",
    "o": [
      "std::bad_alloc",
      "std::invalid_argument",
      "std::out_of_range",
      "std::overflow_error"
    ]
  },
  {
    "q": "Which of the following is a valid way to handle exceptions in C++ when multiple exceptions may be thrown?",
    "o": [
      "Use multiple 'catch' blocks to handle different exception types separately.",
      "Only one 'catch' block can be used, regardless of the number of exception types.",
      "The 'catch' block should be used to handle only one specific exception type.",
      "All exceptions must be caught by the same 'catch' block regardless of type."
    ]
  },
  {
    "q": "What is the purpose of the 'throw' keyword in C++ exception handling?",
    "o": [
      "The 'throw' keyword is used to throw an exception from within a function or block.",
      "The 'throw' keyword is used to catch an exception in a 'catch' block.",
      "The 'throw' keyword is used to define exception types in C++.",
      "The 'throw' keyword ensures that exceptions are logged in the program."
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::ios_base::failure(\"Input/output error\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Input/output error",
      "std::ios_base::failure",
      "I/O exception",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following exception types is used for out-of-bounds errors in C++?",
    "o": [
      "std::out_of_range",
      "std::invalid_argument",
      "std::range_error",
      "std::overflow_error"
    ]
  },
  {
    "q": "Which of the following is a benefit of exception safety in C++?",
    "o": [
      "It ensures that objects are left in a consistent state even when an exception is thrown.",
      "It guarantees that exceptions are caught and handled by the system automatically.",
      "It reduces the need for 'catch' blocks in the code.",
      "It improves program execution time by catching all exceptions."
    ]
  },
  {
    "q": "What is the purpose of the 'noexcept' operator in C++?",
    "o": [
      "It indicates that a function does not throw any exceptions.",
      "It is used to catch exceptions in a function.",
      "It tells the compiler to ignore all exceptions in the function.",
      "It marks a function as allowing exceptions."
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::bad_alloc();\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "std::bad_alloc",
      "Memory allocation failure",
      "Bad allocation",
      "Nothing"
    ]
  },
  {
    "q": "What is the purpose of exception chaining in C++?",
    "o": [
      "It allows one exception to be thrown while another is being caught, to provide more context.",
      "It ensures that exceptions are caught in the order in which they were thrown.",
      "It prevents exceptions from being thrown once they have been caught.",
      "It is used to convert one exception type into another."
    ]
  },
  {
    "q": "Which of the following is a feature of exception handling in C++?",
    "o": [
      "Exceptions provide a way to handle runtime errors and exceptional conditions.",
      "Exceptions are only used to handle syntax errors in the program.",
      "Exceptions automatically log all error messages to a file.",
      "Exception handling is not supported in C++."
    ]
  },
  {
    "q": "What happens when a function throws an exception and no matching catch block is found in C++?",
    "o": [
      "The exception propagates up the call stack until it is caught or the program terminates.",
      "The program halts, and the exception is automatically handled.",
      "The function returns, and the exception is ignored.",
      "The program continues executing normally without interruption."
    ]
  },
  {
    "q": "What is the behavior of a 'throw' expression inside a 'try' block in C++?",
    "o": [
      "It throws an exception that can be caught by a corresponding 'catch' block.",
      "It causes the program to exit immediately without throwing any exception.",
      "It ignores the exception and continues executing the code after the 'try' block.",
      "It prevents any other exceptions from being thrown inside the 'try' block."
    ]
  },
  {
    "q": "Which of the following is true about exception safety in C++?",
    "o": [
      "Exception safety ensures that a program remains in a valid state even after an exception is thrown.",
      "Exception safety guarantees that the program will always handle exceptions by terminating.",
      "Exception safety is not necessary when handling exceptions of basic types.",
      "Exception safety can only be used for custom exception types in C++."
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::invalid_argument(\"Invalid argument error\");\n    } catch (const std::invalid_argument& e) {\n        std::cout << e.what() << std::endl;\n    } catch (const std::exception& e) {\n        std::cout << \"Other error\" << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Invalid argument error",
      "Other error",
      "std::invalid_argument",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following exception types is used to signal that an operation has failed due to an invalid argument in C++?",
    "o": [
      "std::invalid_argument",
      "std::out_of_range",
      "std::logic_error",
      "std::overflow_error"
    ]
  },
  {
    "q": "Which of the following is a correct way to declare a custom exception class in C++?",
    "o": [
      "class MyException : public std::exception { public: const char* what() const noexcept override { return \"My custom exception\"; } };",
      "class MyException : public std::exception { public: void what() const { return \"My custom exception\"; } };",
      "class MyException { public: const char* message; MyException() { message = \"My custom exception\"; } };",
      "class MyException { public: MyException() { throw \"My custom exception\"; } };"
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?\n",
    "c": "#include <iostream>\n#include <stdexcept>\n\nint main() {\n    try {\n        throw std::overflow_error(\"Overflow error\");\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "Overflow error",
      "std::overflow_error",
      "Overflow exception",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is the correct syntax to catch an exception of type 'std::exception' in C++?",
    "o": [
      "catch (const std::exception& e)",
      "catch std::exception e",
      "catch (std::exception e)",
      "catch (std::exception* e)"
    ]
  },
  {
    "q": "Which of the following is the correct behavior when an exception is thrown in C++?",
    "o": [
      "The exception is propagated up the call stack until it is caught by a matching 'catch' block.",
      "The exception is automatically caught by the system and handled without the need for a 'catch' block.",
      "The exception is ignored, and the program continues execution from the point where it was thrown.",
      "The exception will automatically call the destructor of the object that threw it."
    ]
  },
  {
    "q": "What will happen if an exception is thrown inside a destructor in C++?",
    "o": [
      "The program will call std::terminate and exit immediately.",
      "The exception is ignored, and the destructor completes normally.",
      "The exception is handled by the nearest catch block.",
      "The exception is automatically passed to a custom exception handler."
    ]
  },
  {
    "q": "Which of the following is a valid reason to create a custom exception class in C++?",
    "o": [
      "To provide more specific error messages and behavior for certain exceptional conditions.",
      "To ensure that all exceptions are caught by the same handler.",
      "To make the program faster by reducing the number of thrown exceptions.",
      "To convert standard exception types into runtime errors."
    ]
  },
  {
    "q": "Which of the following is true about the 'throw' expression in C++?",
    "o": [
      "The 'throw' expression is used to throw exceptions in C++.",
      "The 'throw' expression is used to catch exceptions in C++.",
      "The 'throw' expression is used to define new exception types.",
      "The 'throw' expression is used to handle exceptions."
    ]
  },
  {
    "q": "What is the purpose of 'throw' expressions in C++ exception handling?",
    "o": [
      "To propagate exceptions from a function or block of code to be caught later.",
      "To catch all exceptions in the code.",
      "To suppress exceptions in the program.",
      "To convert exceptions into standard error messages."
    ]
  },
  {
    "q": "Which of the following exception types is used for errors that arise due to incorrect calculations or logic in C++?",
    "o": [
      "std::logic_error",
      "std::out_of_range",
      "std::invalid_argument",
      "std::bad_alloc"
    ]
  },
  {
    "q": "What happens when an exception is thrown but not caught in a C++ program?",
    "o": [
      "The program will terminate by calling std::terminate.",
      "The exception is ignored, and the program continues executing.",
      "The exception is automatically handled by the system.",
      "The program enters an infinite loop."
    ]
  },
  {
    "q": "Which of the following is true regarding exception handling in C++?",
    "o": [
      "Exception handling in C++ is based on 'try', 'catch', and 'throw' blocks.",
      "C++ does not support exception handling, and all errors must be handled manually.",
      "Exceptions are handled by setting error flags in C++.",
      "C++ provides a built-in function to automatically handle exceptions."
    ]
  },
  {
    "q": "Which of the following is the correct syntax to throw a custom exception in C++?",
    "o": [
      "throw MyException();",
      "throw (MyException);",
      "throw new MyException();",
      "throw MyException;"
    ]
  },
  {
    "q": "What happens when an exception is thrown inside a catch block in C++?",
    "o": [
      "The exception will propagate out of the current catch block to a higher-level handler.",
      "The exception is ignored and does not propagate.",
      "The program will terminate immediately.",
      "The exception will be caught again by the same catch block."
    ]
  },
  {
    "q": "Which of the following exception types is used to handle input/output errors in C++?",
    "o": [
      "std::ios_base::failure",
      "std::input_error",
      "std::bad_alloc",
      "std::invalid_argument"
    ]
  },
  {
    "q": "What is the output of the following code?\n",
    "c": "#include <iostream>\nint main() {\n    try {\n        int x = 0;\n        if (x == 0) throw \"ZeroDivisionError\";\n    } catch (const char* msg) {\n        std::cout << msg << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "ZeroDivisionError",
      "x is zero",
      "Exception caught",
      "Runtime error"
    ]
  },
  {
    "q": "Which of the following is a valid way to ensure strong exception safety in C++?",
    "o": [
      "Use copy-and-swap idiom during assignment operations.",
      "Avoid using destructors in classes.",
      "Catch all exceptions using catch(...) only.",
      "Disable all throw statements."
    ]
  },
  {
    "q": "What will be printed by the following code?\n",
    "c": "#include <iostream>\n#include <exception>\nvoid risky() { throw std::logic_error(\"Bad logic!\"); }\nint main() {\n    try {\n        risky();\n    } catch (std::logic_error &e) {\n        std::cout << e.what();\n    }\n}",
    "o": [
      "Bad logic!",
      "Exception occurred",
      "std::logic_error",
      "Logic error caught"
    ]
  },
  {
    "q": "Which of the following can be used to catch any kind of exception?",
    "o": [
      "catch(...)",
      "catch(int)",
      "catch(std::exception&)",
      "catch(std::runtime_error&)"
    ]
  },
  {
    "q": "Why is it recommended to catch exceptions by reference in C++?",
    "o": [
      "To avoid slicing and improve performance.",
      "To allow copying of exception objects.",
      "To ensure the object is destroyed after catching.",
      "To disable throwing new exceptions."
    ]
  },
  {
    "q": "What is the main advantage of defining custom exception classes?",
    "o": [
      "To provide more descriptive and type-specific error handling.",
      "To replace all standard exceptions.",
      "To avoid using try-catch blocks.",
      "To eliminate exception propagation."
    ]
  },
  {
    "q": "What is the output of the following code?\n",
    "c": "#include <iostream>\n#include <stdexcept>\nclass MyException : public std::runtime_error {\npublic:\n    MyException() : std::runtime_error(\"Custom error!\") {}\n};\nint main() {\n    try {\n        throw MyException();\n    } catch (std::exception &e) {\n        std::cout << e.what();\n    }\n}",
    "o": [
      "Custom error!",
      "Exception caught",
      "MyException",
      "runtime_error"
    ]
  },
  {
    "q": "Which standard exception is typically thrown when accessing beyond array bounds?",
    "o": [
      "std::out_of_range",
      "std::overflow_error",
      "std::logic_error",
      "std::length_error"
    ]
  },
  {
    "q": "Which of the following C++ constructs can cause an exception to be thrown?",
    "o": [
      "new operator (on allocation failure)",
      "sizeof operator",
      "delete operator",
      "cout statement"
    ]
  },
  {
    "q": "How do you ensure basic exception safety in C++?",
    "o": [
      "Ensure no resources leak even if exceptions are thrown.",
      "Prevent all exceptions using compiler settings.",
      "Avoid all try-catch blocks.",
      "Use dynamic_cast to detect exceptions early."
    ]
  },
  {
    "q": "What will be the output of the following code?\n",
    "c": "#include <iostream>\nint main() {\n    try {\n        throw 100;\n    } catch (int e) {\n        std::cout << \"Caught: \" << e;\n    }\n}",
    "o": [
      "Caught: 100",
      "Exception caught",
      "100",
      "int error"
    ]
  },
  {
    "q": "Which standard exception class serves as the base for all other standard exception types?",
    "o": [
      "std::exception",
      "std::logic_error",
      "std::runtime_error",
      "std::bad_exception"
    ]
  },
  {
    "q": "Which of the following statements is true about exception propagation in C++?",
    "o": [
      "An uncaught exception propagates up the call stack until a matching catch is found.",
      "Exceptions are automatically logged before being caught.",
      "C++ exceptions stop at the first function level.",
      "Exception propagation does not occur with standard exceptions."
    ]
  },
  {
    "q": "What is the use of noexcept in C++?",
    "o": [
      "To specify that a function does not throw exceptions.",
      "To throw exceptions with a special syntax.",
      "To handle exceptions more efficiently.",
      "To suppress all runtime errors."
    ]
  },
  {
    "q": "How would you define a simple custom exception that extends std::exception?",
    "o": [
      "class MyEx : public std::exception { const char* what() const noexcept override { return \"error\"; } };",
      "class MyEx : public std::exception { const char* error() const { return \"error\"; } };",
      "class MyEx { void print() { std::cout << \"error\"; } };",
      "class MyEx : public std::logic_error { };"
    ]
  },
  {
    "q": "What kind of errors does std::runtime_error handle?",
    "o": [
      "Errors detectable only during runtime like I/O issues.",
      "Errors that can be checked at compile-time.",
      "Only memory-related errors.",
      "Type conversion errors."
    ]
  },
  {
    "q": "Which of the following is an example of a logic error exception?",
    "o": [
      "std::domain_error",
      "std::overflow_error",
      "std::ios_base::failure",
      "std::bad_alloc"
    ]
  },
  {
    "q": "What will happen if an exception is thrown but not caught in any catch block?",
    "o": [
      "The program calls std::terminate and aborts.",
      "The program automatically creates a default catch block.",
      "It logs the error and continues.",
      "Nothing happens; the program ignores the exception."
    ]
  },
  {
    "q": "Which mechanism is used to prevent resource leaks when an exception is thrown?",
    "o": [
      "RAII (Resource Acquisition Is Initialization)",
      "Manual garbage collection",
      "Global try-catch block",
      "Stack unwinding prevention"
    ]
  },
  {
    "q": "Which of the following statements about 'catch' blocks is true in C++?",
    "o": [
      "Multiple catch blocks can be used to handle different types of exceptions.",
      "Only one catch block is allowed per try block.",
      "Catch blocks cannot handle standard exceptions.",
      "Catch blocks must always catch exceptions by value."
    ]
  },
  {
    "q": "What is the primary purpose of using the 'noexcept' specifier in C++?",
    "o": [
      "To declare that a function does not throw exceptions.",
      "To catch exceptions silently.",
      "To ignore all thrown exceptions in a function.",
      "To define custom exception types."
    ]
  },
  {
    "q": "Which standard exception is thrown when an operation causes a numeric overflow?",
    "o": [
      "std::overflow_error",
      "std::logic_error",
      "std::domain_error",
      "std::length_error"
    ]
  },
  {
    "q": "What is the output of this C++ code snippet?\n",
    "c": "#include <iostream>\n#include <exception>\nint main() {\n    try {\n        throw std::bad_alloc();\n    } catch (std::bad_alloc& e) {\n        std::cout << \"Allocation failed: \" << e.what();\n    }\n}",
    "o": [
      "Allocation failed: std::bad_alloc",
      "Memory allocation error",
      "std::bad_alloc caught",
      "Exception thrown"
    ]
  },
  {
    "q": "Why is stack unwinding important during exception handling in C++?",
    "o": [
      "It ensures destructors are called for local objects when an exception is thrown.",
      "It prevents exceptions from propagating outside the try block.",
      "It ignores thrown exceptions to maintain program stability.",
      "It catches exceptions at compile time."
    ]
  },
  {
    "q": "Which of the following types of exception safety guarantees that no side effects will occur if an exception is thrown?",
    "o": [
      "Strong exception safety",
      "Basic exception safety",
      "No-throw guarantee",
      "Weak exception safety"
    ]
  },
  {
    "q": "Which keyword is used in C++ to signal an exceptional condition manually?",
    "o": [
      "throw",
      "catch",
      "try",
      "signal"
    ]
  },
  {
    "q": "What is the output of the following C++ code?\n",
    "c": "#include <iostream>\nclass MyError {};\nint main() {\n    try {\n        throw MyError();\n    } catch (...) {\n        std::cout << \"Unknown exception caught\";\n    }\n}",
    "o": [
      "Unknown exception caught",
      "MyError exception",
      "Error thrown",
      "Exception handled"
    ]
  },
  {
    "q": "Which of the following standard exceptions is used when a pointer or object is not properly initialized?",
    "o": [
      "std::logic_error",
      "std::underflow_error",
      "std::out_of_range",
      "std::range_error"
    ]
  },
  {
    "q": "When is it necessary to define a custom exception class in C++?",
    "o": [
      "When existing standard exceptions don't convey enough context for a specific error.",
      "When trying to replace all STL exceptions.",
      "When handling hardware-level errors.",
      "To override the throw keyword."
    ]
  },
  {
    "q": "What will happen in the following code?\n",
    "c": "#include <iostream>\nvoid test() noexcept {\n    throw 10;\n}\nint main() {\n    test();\n}",
    "o": [
      "The program calls std::terminate due to noexcept violation.",
      "The exception is caught automatically.",
      "Compilation error occurs due to throw in noexcept.",
      "The program prints 10."
    ]
  },
  {
    "q": "Which C++ exception class should be used to signal errors during input/output operations?",
    "o": [
      "std::ios_base::failure",
      "std::invalid_argument",
      "std::domain_error",
      "std::bad_typeid"
    ]
  },
  {
    "q": "What does the ellipsis (...) mean in a catch block?",
    "o": [
      "It catches any exception of any type.",
      "It declares a variadic catch function.",
      "It throws all exceptions to another handler.",
      "It suppresses exception messages."
    ]
  },
  {
    "q": "Which exception class is used when a dynamic cast fails with references?",
    "o": [
      "std::bad_cast",
      "std::bad_alloc",
      "std::bad_typeid",
      "std::domain_error"
    ]
  },
  {
    "q": "Which of the following describes the 'basic exception safety' guarantee?",
    "o": [
      "Resources are not leaked, but data may be in an indeterminate valid state.",
      "No side effects will occur.",
      "Program continues execution from point of exception.",
      "All exceptions are automatically ignored."
    ]
  },
  {
    "q": "Which of the following is thrown when typeid is used on a null pointer to a polymorphic type?",
    "o": [
      "std::bad_typeid",
      "std::bad_cast",
      "std::invalid_argument",
      "std::range_error"
    ]
  },
  {
    "q": "What happens if a C++ function declares 'noexcept' and throws an exception?",
    "o": [
      "The program will call std::terminate.",
      "The compiler ignores the throw.",
      "The exception will be caught normally.",
      "The function becomes constexpr."
    ]
  },
  {
    "q": "How can RAII help with exception safety in C++?",
    "o": [
      "By tying resource management to object lifetime, ensuring cleanup on exception.",
      "By skipping destructors on exception.",
      "By avoiding the need for try-catch blocks.",
      "By preventing all exceptions at compile-time."
    ]
  },
  {
    "q": "Which standard exception would best describe a situation where an argument is outside the valid range?",
    "o": [
      "std::out_of_range",
      "std::length_error",
      "std::overflow_error",
      "std::range_error"
    ]
  },
  {
    "q": "What is the most appropriate reason to use 'catch(const std::exception& e)' instead of 'catch(std::exception e)'?",
    "o": [
      "To avoid object slicing and unnecessary copies.",
      "To make the exception handler more flexible.",
      "To convert runtime exceptions into compile-time.",
      "To handle memory leaks safely."
    ]
  },
  {
    "q": "What is the role of the 'throw' keyword in C++ exception handling?",
    "o": [
      "It signals the occurrence of an exceptional condition.",
      "It defines a block of code to catch exceptions.",
      "It terminates the program upon error.",
      "It prevents exceptions from propagating."
    ]
  },
  {
    "q": "What will the following C++ program output?\n",
    "c": "#include <iostream>\nint main() {\n    try {\n        std::string().at(1);\n    } catch (const std::out_of_range &e) {\n        std::cout << \"Caught: \" << e.what();\n    }\n}",
    "o": [
      "Caught: basic_string::at: __n (which is 1) >= this->size()",
      "Caught: out_of_range exception",
      "Caught exception",
      "Index out of range"
    ]
  },
  {
    "q": "Which of the following best defines the strong exception safety guarantee?",
    "o": [
      "Operations have no side effects if an exception is thrown.",
      "The program catches all exceptions with catch(...).",
      "Only standard exceptions are allowed.",
      "All exceptions are rethrown after being caught."
    ]
  },
  {
    "q": "What is the correct way to define a function that throws a custom exception?",
    "o": [
      "void func() { throw MyCustomException(); }",
      "void func() throw MyCustomException;",
      "void func() catch(MyCustomException);",
      "void func() throw();"
    ]
  },
  {
    "q": "Which of these best explains why slicing occurs in exception handling?",
    "o": [
      "When exception objects are caught by value, their derived parts are sliced off.",
      "When a catch block uses catch(...).",
      "When exceptions are thrown without specifying the type.",
      "When memory is not allocated properly."
    ]
  },
  {
    "q": "What is the output of this code?\n",
    "c": "#include <iostream>\nclass MyEx {};\nint main() {\n    try {\n        throw MyEx();\n        std::cout << \"After throw\";\n    } catch (MyEx&) {\n        std::cout << \"Caught MyEx\";\n    }\n}",
    "o": [
      "Caught MyEx",
      "After throw",
      "Exception thrown",
      "Caught: MyEx"
    ]
  },
  {
    "q": "Which exception is used to indicate a length-related constraint was violated?",
    "o": [
      "std::length_error",
      "std::out_of_range",
      "std::range_error",
      "std::overflow_error"
    ]
  },
  {
    "q": "How is exception propagation handled in nested function calls?",
    "o": [
      "An exception moves up the call stack until caught by a matching catch block.",
      "An exception must be caught in the same function where it’s thrown.",
      "Only standard exceptions can propagate.",
      "Nested functions must use try-catch-finally."
    ]
  },
  {
    "q": "What happens if no catch block matches a thrown exception?",
    "o": [
      "std::terminate is called and the program aborts.",
      "The compiler resolves it at runtime.",
      "The exception is logged and ignored.",
      "A default exception handler takes over."
    ]
  },
  {
    "q": "How do destructors interact with exceptions in C++?",
    "o": [
      "Destructors are called automatically during stack unwinding.",
      "Destructors must be called manually if exceptions occur.",
      "Destructors are skipped during exceptions.",
      "C++ does not call destructors when exceptions occur."
    ]
  },
  {
    "q": "Which of the following is an example of throwing a standard exception object?",
    "o": [
      "throw std::invalid_argument(\"Invalid input\");",
      "throw \"Invalid input\";",
      "catch(std::exception& e) { }",
      "throw new std::invalid_argument;"
    ]
  },
  {
    "q": "Why should exceptions typically be caught by reference?",
    "o": [
      "To avoid slicing and unnecessary copying.",
      "To ensure automatic memory allocation.",
      "To convert checked exceptions to unchecked.",
      "To throw additional exceptions."
    ]
  },
  {
    "q": "What is the output of the following program?\n",
    "c": "#include <iostream>\n#include <stdexcept>\nint main() {\n    try {\n        throw std::range_error(\"Range error\");\n    } catch (std::exception &e) {\n        std::cout << e.what();\n    }\n}",
    "o": [
      "Range error",
      "Caught range_error",
      "Exception: std::range_error",
      "std::exception"
    ]
  },
  {
    "q": "Which C++ feature helps ensure no resources are leaked when an exception occurs?",
    "o": [
      "RAII (Resource Acquisition Is Initialization)",
      "The noexcept specifier",
      "Global catch blocks",
      "The delete operator"
    ]
  },
  {
    "q": "Which of the following is NOT a direct subclass of std::exception?",
    "o": [
      "std::overflow_error",
      "std::bad_alloc",
      "std::domain_error",
      "std::ios_base::failure"
    ]
  },
  {
    "q": "How is 'no-throw guarantee' different from 'strong exception safety'?",
    "o": [
      "No-throw guarantees that an operation will never throw, unlike strong safety.",
      "Strong safety prevents all exceptions.",
      "No-throw allows some exceptions to escape.",
      "They are the same in behavior."
    ]
  },
  {
    "q": "In what situation would std::bad_alloc be thrown?",
    "o": [
      "When dynamic memory allocation fails.",
      "When an invalid type conversion is attempted.",
      "When opening a file that doesn’t exist.",
      "When accessing an invalid iterator."
    ]
  },
  {
    "q": "How does catch(...) behave differently from other catch statements?",
    "o": [
      "It catches any exception type.",
      "It logs and ignores the exception.",
      "It rethrows the exception automatically.",
      "It is only used in destructors."
    ]
  },
  {
    "q": "Which of the following is true about exception handling in constructors?",
    "o": [
      "If an exception is thrown, the object is not constructed.",
      "Constructors cannot throw exceptions.",
      "Exceptions in constructors must be ignored.",
      "catch blocks cannot be used inside constructors."
    ]
  },
  {
    "q": "Which of the following helps implement exception-safe code by committing changes only if all operations succeed?",
    "o": [
      "Transactional design pattern",
      "Pointer arithmetic",
      "Using macros for error codes",
      "Avoiding all exceptions"
    ]
  },
  {
    "q": "Which C++ standard exception class is most appropriate to use when a function receives an invalid value?",
    "o": [
      "std::invalid_argument",
      "std::logic_error",
      "std::domain_error",
      "std::length_error"
    ]
  },
  {
    "q": "Which of the following keywords is used to re-throw the current exception inside a catch block?",
    "o": [
      "throw;",
      "rethrow;",
      "catch;",
      "throw again;"
    ]
  },
  {
    "q": "What happens when an exception is thrown in a constructor and not caught?",
    "o": [
      "The object is not created and memory is released.",
      "The object is partially constructed.",
      "The program ignores the exception.",
      "Destructor is called for the partially constructed object."
    ]
  },
  {
    "q": "What is the output of the following code?\n",
    "c": "#include <iostream>\nint main() {\n    try {\n        throw 'x';\n    } catch (int) {\n        std::cout << \"Caught int\";\n    } catch (...) {\n        std::cout << \"Caught unknown\";\n    }\n}",
    "o": [
      "Caught unknown",
      "Caught int",
      "Caught x",
      "No output"
    ]
  },
  {
    "q": "Which C++ feature allows safe resource cleanup when an exception is thrown?",
    "o": [
      "Destructors with RAII",
      "Global exception handling",
      "Macros",
      "assert statements"
    ]
  },
  {
    "q": "How do you declare a custom exception class that inherits from std::exception?",
    "o": [
      "class MyException : public std::exception { };",
      "class MyException extends std::exception { };",
      "class MyException inherits std::exception { };",
      "exception MyException { };"
    ]
  },
  {
    "q": "What will the following code output?\n",
    "c": "#include <iostream>\nclass A { public: ~A() { std::cout << \"Destructor\"; } };\nint main() {\n    try {\n        A a;\n        throw 5;\n    } catch (...) {}\n}",
    "o": [
      "Destructor",
      "5",
      "Caught",
      "No output"
    ]
  },
  {
    "q": "Which of the following can be used to catch exceptions of any type?",
    "o": [
      "catch(...)",
      "catch(any)",
      "catch(std::any_exception)",
      "catch(*)"
    ]
  },
  {
    "q": "What happens if an exception is thrown from a destructor during stack unwinding?",
    "o": [
      "std::terminate is called",
      "The destructor is skipped",
      "It is caught automatically",
      "It restarts the program"
    ]
  },
  {
    "q": "Which function is called when a thrown exception is not caught anywhere in the program?",
    "o": [
      "std::terminate",
      "std::exit",
      "std::abort",
      "std::close"
    ]
  },
  {
    "q": "What is the primary role of the std::exception base class?",
    "o": [
      "To provide a polymorphic interface for all standard exceptions",
      "To allow user-defined error codes",
      "To enable automatic memory management",
      "To ensure compile-time error checks"
    ]
  },
  {
    "q": "How can you ensure basic exception safety in code modifying a container?",
    "o": [
      "Ensure that resources are not leaked and the object remains valid",
      "Catch all exceptions using catch(...)",
      "Avoid using STL containers",
      "Use pointers instead of objects"
    ]
  },
  {
    "q": "Which of the following best describes exception neutrality in template functions?",
    "o": [
      "Template functions should not catch exceptions they do not understand.",
      "Templates must use only standard exceptions.",
      "Templates should ignore exceptions to compile faster.",
      "Templates should always use try-catch-finally."
    ]
  },
  {
    "q": "Which of these exceptions is thrown when a program attempts a typeid on a null pointer to a polymorphic type?",
    "o": [
      "std::bad_typeid",
      "std::bad_cast",
      "std::runtime_error",
      "std::invalid_argument"
    ]
  },
  {
    "q": "Which type of exception safety ensures that an operation completes successfully or has no side effects?",
    "o": [
      "Strong exception safety",
      "Basic exception safety",
      "No-fail safety",
      "Weak exception safety"
    ]
  },
  {
    "q": "Which of the following is considered unsafe in exception handling?",
    "o": [
      "Throwing an exception from a destructor during stack unwinding",
      "Catching exceptions by reference",
      "Throwing custom exceptions",
      "Using catch(...) as a last resort"
    ]
  },
  {
    "q": "What does the 'what()' method of std::exception return?",
    "o": [
      "A C-style string describing the exception",
      "The line number of the exception",
      "A pointer to the exception object",
      "The exception type name"
    ]
  },
  {
    "q": "What is the correct way to catch a custom exception called MyException?",
    "o": [
      "catch (const MyException& e)",
      "catch MyException",
      "catch (&MyException)",
      "catch (MyException e*)"
    ]
  },
  {
    "q": "What is the correct behavior of this code?\n",
    "c": "#include <iostream>\nint main() {\n    try {\n        throw std::logic_error(\"Logic issue\");\n    } catch (const std::runtime_error& e) {\n        std::cout << e.what();\n    } catch (...) {\n        std::cout << \"Fallback\";\n    }\n}",
    "o": [
      "Fallback",
      "Logic issue",
      "Caught runtime_error",
      "Compilation error"
    ]
  },
  {
    "q": "What is the recommended way to report an error in modern C++?",
    "o": [
      "Throw an exception derived from std::exception",
      "Use exit(1)",
      "Print error to std::cout",
      "Return -1"
    ]
  },
  {
    "q": "What will the following code output?\n",
    "c": "#include <iostream>\nint main() {\n    try {\n        int* ptr = nullptr;\n        if (!ptr) throw \"Null Pointer\";\n    } catch (const char* msg) {\n        std::cout << msg;\n    }\n}",
    "o": [
      "Null Pointer",
      "Segmentation Fault",
      "Caught Exception",
      "Runtime Error"
    ]
  },
  {
    "q": "Which standard C++ exception is used to indicate arithmetic overflows?",
    "o": [
      "std::overflow_error",
      "std::range_error",
      "std::logic_error",
      "std::runtime_error"
    ]
  },
  {
    "q": "What is the result of throwing an exception from a constructor?",
    "o": [
      "The object is not created and the destructor is not called",
      "The constructor retries automatically",
      "The program enters an infinite loop",
      "The object is created in incomplete state"
    ]
  },
  {
    "q": "Which of the following would best support writing exception-safe code?",
    "o": [
      "Using smart pointers and RAII",
      "Avoiding destructors",
      "Catching all exceptions by value",
      "Avoiding try-catch blocks"
    ]
  },
  {
    "q": "What is the output of the following code?\n",
    "c": "#include <iostream>\n#include <stdexcept>\nint main() {\n    try {\n        throw std::invalid_argument(\"Invalid!\");\n    } catch (std::logic_error& e) {\n        std::cout << e.what();\n    }\n}",
    "o": [
      "Invalid!",
      "Logic error",
      "Caught logic_error",
      "Invalid argument thrown"
    ]
  },
  {
    "q": "What does 'exception safety' primarily aim to protect?",
    "o": [
      "Program state and resource integrity during exceptions",
      "Faster execution time",
      "Reducing memory usage",
      "Simplifying error messages"
    ]
  },
  {
    "q": "Which class hierarchy does std::runtime_error belong to?",
    "o": [
      "std::exception > std::logic_error > std::runtime_error",
      "std::exception > std::runtime_error",
      "std::runtime_error > std::logic_error",
      "std::logic_error > std::exception"
    ]
  },
  {
    "q": "What happens if a standard exception is caught by value?",
    "o": [
      "It may cause object slicing",
      "It performs deep copy",
      "The exception is ignored",
      "The type is upgraded to base"
    ]
  },
  {
    "q": "Why is catching exceptions by reference preferred?",
    "o": [
      "To avoid object slicing and overhead",
      "To improve exception polymorphism",
      "To prevent memory leaks",
      "To make code shorter"
    ]
  },
  {
    "q": "What will the following code output?\n",
    "c": "#include <iostream>\nvoid risky() { throw 100; }\nint main() {\n    try {\n        risky();\n    } catch (int x) {\n        std::cout << \"Caught: \" << x;\n    }\n}",
    "o": [
      "Caught: 100",
      "Caught: 0",
      "Exception thrown",
      "Caught int exception"
    ]
  },
  {
    "q": "What is the best practice when writing destructors in C++ regarding exceptions?",
    "o": [
      "Destructors should not throw exceptions",
      "Destructors must throw at least one exception",
      "Destructors should throw only custom exceptions",
      "Use 'throw()' to guarantee exception safety"
    ]
  },
  {
    "q": "Which of the following would best demonstrate strong exception safety?",
    "o": [
      "Using temporary objects and commit on success",
      "Catching exceptions globally only",
      "Returning nullptr on failure",
      "Avoiding object construction in functions"
    ]
  },
  {
    "q": "Which exception is used for dynamic_cast failures on references?",
    "o": [
      "std::bad_cast",
      "std::bad_typeid",
      "std::bad_alloc",
      "std::bad_function_call"
    ]
  },
  {
    "q": "What will the output be?\n",
    "c": "#include <iostream>\nclass X { public: ~X() { std::cout << \"~X \"; } };\nint main() {\n    try {\n        X x;\n        throw std::runtime_error(\"Oops\");\n    } catch (...) {\n        std::cout << \"Caught!\";\n    }\n}",
    "o": [
      "~X Caught!",
      "Caught!",
      "~X Oops",
      "Caught! ~X"
    ]
  },
  {
    "q": "What is the primary use of the noexcept specifier?",
    "o": [
      "To indicate a function does not throw exceptions",
      "To make a function thread-safe",
      "To enable inline optimization",
      "To silence compile-time warnings"
    ]
  },
  {
    "q": "Which standard exception indicates an issue with allocating memory?",
    "o": [
      "std::bad_alloc",
      "std::bad_cast",
      "std::invalid_argument",
      "std::length_error"
    ]
  },
  {
    "q": "Which of the following code snippets correctly defines and throws a custom exception?",
    "o": [
      "class MyEx : public std::exception {}; throw MyEx();",
      "throw class MyEx : public std::exception {};",
      "throw std::exception MyEx();",
      "MyEx : exception {}; throw MyEx();"
    ]
  },
  {
    "q": "What will this program print?\n",
    "c": "#include <iostream>\n#include <stdexcept>\nvoid test() { throw std::logic_error(\"Logic\"); }\nint main() {\n    try { test(); } catch (const std::runtime_error& e) {\n        std::cout << \"Runtime\";\n    } catch (...) {\n        std::cout << \"Fallback\";\n    }\n}",
    "o": [
      "Fallback",
      "Logic",
      "Runtime",
      "Caught std::logic_error"
    ]
  },
  {
    "q": "How does RAII help with exception safety?",
    "o": [
      "It ensures resources are cleaned up automatically via destructors",
      "It disables exceptions in constructors",
      "It avoids using the heap",
      "It converts exceptions to error codes"
    ]
  },
  {
    "q": "What is the purpose of a catch block with no parameter (i.e., catch(...))?",
    "o": [
      "To catch all exceptions regardless of type",
      "To catch only standard exceptions",
      "To catch only custom exceptions",
      "To prevent stack unwinding"
    ]
  },
  {
    "q": "What is the output of the following code?\n",
    "c": "#include <iostream>\nint main() {\n    try {\n        throw std::string(\"Error\");\n    } catch (std::string& e) {\n        std::cout << e;\n    }\n}",
    "o": [
      "Error",
      "Caught",
      "Exception",
      "Runtime"
    ]
  },
  {
    "q": "Which keyword is used to indicate an exception in C++?",
    "o": [
      "throw",
      "raise",
      "except",
      "signal"
    ]
  },
  {
    "q": "Which of the following standard exceptions derives directly from std::logic_error?",
    "o": [
      "std::domain_error",
      "std::runtime_error",
      "std::bad_alloc",
      "std::exception"
    ]
  },
  {
    "q": "What does the noexcept specifier tell the compiler?",
    "o": [
      "That the function does not throw exceptions",
      "That the function throws any exception",
      "That the function only throws runtime_error",
      "That the function catches all exceptions"
    ]
  },
  {
    "q": "Which of the following would best demonstrate the 'no-throw guarantee' in exception safety?",
    "o": [
      "A function that guarantees not to throw any exception under any condition",
      "A function that restores the object to a valid state",
      "A function that may throw but does not leak",
      "A function that catches all errors"
    ]
  },
  {
    "q": "Which standard exception is thrown on a failed dynamic_cast with references?",
    "o": [
      "std::bad_cast",
      "std::bad_typeid",
      "std::bad_alloc",
      "std::overflow_error"
    ]
  },
  {
    "q": "Which mechanism guarantees that destructors are called when exceptions are thrown?",
    "o": [
      "Stack unwinding",
      "Manual memory management",
      "Explicit destructor calls",
      "Garbage collection"
    ]
  },
  {
    "q": "What is the base class of all standard exception classes in C++?",
    "o": [
      "std::exception",
      "std::runtime_error",
      "std::logic_error",
      "std::bad_exception"
    ]
  },
  {
    "q": "Which statement about the std::bad_alloc exception is true?",
    "o": [
      "It is thrown when dynamic memory allocation fails",
      "It is used to detect bad input",
      "It is thrown during pointer dereferencing",
      "It is a logic error"
    ]
  },
  {
    "q": "What is the correct way to throw an integer exception in C++?",
    "o": [
      "throw 5;",
      "throw int = 5;",
      "int ex = 5; throw(ex);",
      "throw new int(5);"
    ]
  },
  {
    "q": "What happens if no catch block is able to handle a thrown exception?",
    "o": [
      "std::terminate is called",
      "The exception is ignored",
      "The exception is caught automatically",
      "The program pauses for user input"
    ]
  },
  {
    "q": "What is the output of this program?\n",
    "c": "#include <iostream>\n#include <stdexcept>\nint main() {\n    try {\n        throw std::out_of_range(\"Out of range\");\n    } catch (const std::exception& e) {\n        std::cout << e.what();\n    }\n}",
    "o": [
      "Out of range",
      "Exception",
      "Caught",
      "std::exception"
    ]
  },
  {
    "q": "Which exception is thrown by new when memory allocation fails?",
    "o": [
      "std::bad_alloc",
      "std::bad_exception",
      "std::overflow_error",
      "std::range_error"
    ]
  },
  {
    "q": "Which exception is thrown when using typeid on a null pointer to a polymorphic type?",
    "o": [
      "std::bad_typeid",
      "std::bad_cast",
      "std::invalid_argument",
      "std::runtime_error"
    ]
  },
  {
    "q": "What will this code output?\n",
    "c": "#include <iostream>\nclass MyException : public std::exception {\npublic:\n    const char* what() const noexcept override {\n        return \"MyException occurred\";\n    }\n};\nint main() {\n    try { throw MyException(); } catch (const std::exception& e) {\n        std::cout << e.what();\n    }\n}",
    "o": [
      "MyException occurred",
      "Exception",
      "Caught exception",
      "Unknown error"
    ]
  },
  {
    "q": "Which of these represents the best practice for defining a custom exception class?",
    "o": [
      "Inherit from std::exception and override what()",
      "Use a struct with public message",
      "Use a global string variable",
      "Define an int code"
    ]
  },
  {
    "q": "Which of these is used to catch all exceptions regardless of type?",
    "o": [
      "catch(...)",
      "catch()",
      "catch(any)",
      "catch(*)"
    ]
  },
  {
    "q": "Which of the following exception guarantees is the weakest?",
    "o": [
      "Basic guarantee",
      "Strong guarantee",
      "No-throw guarantee",
      "Commit-or-rollback guarantee"
    ]
  },
  {
    "q": "Why should exceptions generally be caught by reference?",
    "o": [
      "To preserve polymorphism and avoid slicing",
      "To avoid compiler errors",
      "To pass exception by copy",
      "To allow multiple exceptions to be caught"
    ]
  },
  {
    "q": "Which of the following correctly catches a standard exception by reference?",
    "o": [
      "catch (const std::exception& e)",
      "catch (std::exception e)",
      "catch (exception e)",
      "catch (std::exception* e)"
    ]
  },
  {
    "q": "What is the result of throwing an exception inside a catch block?",
    "o": [
      "It can be caught by an outer try block",
      "It is ignored",
      "The program terminates immediately",
      "It causes stack corruption"
    ]
  },
  {
    "q": "Which of the following correctly throws a user-defined exception class?",
    "o": [
      "throw MyException();",
      "throw new MyException();",
      "MyException.throw();",
      "raise MyException;"
    ]
  },
  {
    "q": "Which C++ feature ensures that local objects are destroyed properly when an exception is thrown?",
    "o": [
      "Stack unwinding",
      "Manual cleanup",
      "RAII macros",
      "Memory leak detection"
    ]
  },
  {
    "q": "What does this code output?\n",
    "c": "#include <iostream>\nint main() {\n    try {\n        throw 42;\n    } catch (double d) {\n        std::cout << d;\n    } catch (...) {\n        std::cout << \"Default\";\n    }\n}",
    "o": [
      "Default",
      "42",
      "0",
      "Unhandled"
    ]
  },
  {
    "q": "What is the purpose of std::exception::what()?",
    "o": [
      "It returns a C-string describing the exception",
      "It throws the exception",
      "It logs the exception",
      "It returns an error code"
    ]
  },
  {
    "q": "What happens if an exception is thrown in a constructor and not caught inside it?",
    "o": [
      "The destructor is not called for that object",
      "The program crashes",
      "The object is partially created",
      "The destructor is always called"
    ]
  },
  {
    "q": "Which of the following correctly defines a custom exception with a message?",
    "o": [
      "class MyEx : public std::exception { const char* what() const noexcept override { return \"Error!\"; } };",
      "class MyEx { std::string what() { return \"Error!\"; } };",
      "throw exception(\"Error!\");",
      "std::runtime_error e = new MyEx();"
    ]
  },
  {
    "q": "What is the best way to ensure strong exception safety?",
    "o": [
      "Use copy-and-swap idiom",
      "Avoid dynamic allocation",
      "Use catch(...) liberally",
      "Use global variables"
    ]
  },
  {
    "q": "Which exception type is best for representing logic errors in code?",
    "o": [
      "std::logic_error",
      "std::runtime_error",
      "std::bad_alloc",
      "std::system_error"
    ]
  },
  {
    "q": "Which exception class should you use to indicate an invalid argument passed to a function?",
    "o": [
      "std::invalid_argument",
      "std::bad_cast",
      "std::length_error",
      "std::domain_error"
    ]
  },
  {
    "q": "What is the purpose of `throw;` inside a catch block?",
    "o": [
      "To rethrow the current exception",
      "To throw a new exception",
      "To terminate the program",
      "To resume from exception"
    ]
  },
  {
    "q": "Which is a valid reason to use catch blocks in C++?",
    "o": [
      "To handle thrown exceptions and avoid program termination",
      "To restart execution from the beginning",
      "To log all function calls",
      "To automatically delete objects"
    ]
  },
  {
    "q": "What will be the output of this code?\n",
    "c": "#include <iostream>\nclass MyError {};\nint main() {\n    try {\n        throw MyError();\n    } catch (...) {\n        std::cout << \"Generic Catch\";\n    }\n}",
    "o": [
      "Generic Catch",
      "MyError",
      "Unhandled",
      "Caught exception"
    ]
  },
  {
    "q": "Which of these guarantees that no exceptions will be thrown?",
    "o": [
      "No-throw guarantee",
      "Basic guarantee",
      "Strong guarantee",
      "Safe-fail guarantee"
    ]
  },
  {
    "q": "Which standard library header defines most common exception types?",
    "o": [
      "<stdexcept>",
      "<exception.h>",
      "<errors>",
      "<exceptions>"
    ]
  },
  {
    "q": "Why is exception handling preferred over error codes in modern C++?",
    "o": [
      "It separates error-handling from logic more cleanly",
      "It compiles faster",
      "It reduces memory usage",
      "It avoids using standard headers"
    ]
  },
  {
    "q": "Which C++ keyword is used to start a block where exceptions might occur?",
    "o": [
      "try",
      "check",
      "assert",
      "handle"
    ]
  },
  {
    "q": "What happens if you throw a pointer to an exception instead of the object?",
    "o": [
      "It must be caught using a pointer type",
      "It cannot be caught at all",
      "The program terminates immediately",
      "It is automatically dereferenced"
    ]
  },
  {
    "q": "Which of these standard exceptions is thrown by std::vector::at() if index is out of bounds?",
    "o": [
      "std::out_of_range",
      "std::length_error",
      "std::range_error",
      "std::underflow_error"
    ]
  },
  {
    "q": "What should you avoid doing in a noexcept function?",
    "o": [
      "Throwing any exception",
      "Returning values",
      "Using templates",
      "Calling member functions"
    ]
  },
  {
    "q": "Which standard exception would you use when a value is outside an expected numeric range?",
    "o": [
      "std::out_of_range",
      "std::invalid_argument",
      "std::length_error",
      "std::bad_cast"
    ]
  },
  {
    "q": "Which of the following best describes the basic exception safety guarantee?",
    "o": [
      "The program remains in a valid state even if an exception is thrown",
      "No exceptions are thrown under any circumstances",
      "Operations are always rolled back fully",
      "Only standard exceptions can be thrown"
    ]
  },
  {
    "q": "What does this code output?\n",
    "c": "#include <iostream>\n#include <stdexcept>\nint main() {\n  try {\n    throw std::logic_error(\"Logic error occurred\");\n  } catch (std::logic_error &e) {\n    std::cout << e.what();\n  }\n}",
    "o": [
      "Logic error occurred",
      "Unhandled",
      "Caught",
      "Exception"
    ]
  },
  {
    "q": "Which C++ feature allows you to specify that a function will not throw an exception?",
    "o": [
      "noexcept",
      "throw()",
      "never_throw",
      "no_throw"
    ]
  },
  {
    "q": "Which standard exception is thrown by bad type casting using dynamic_cast?",
    "o": [
      "std::bad_cast",
      "std::invalid_cast",
      "std::type_mismatch",
      "std::cast_error"
    ]
  },
  {
    "q": "Which of the following best describes the strong exception safety guarantee?",
    "o": [
      "Operations can be rolled back to the original state on failure",
      "No exceptions will be thrown",
      "Program terminates safely",
      "Exceptions are ignored"
    ]
  },
  {
    "q": "Which exception class would be thrown when a vector's max size is exceeded?",
    "o": [
      "std::length_error",
      "std::range_error",
      "std::bad_alloc",
      "std::overflow_error"
    ]
  },
  {
    "q": "What is a good practice when writing destructors in classes that may throw exceptions?",
    "o": [
      "Avoid throwing exceptions from destructors",
      "Always throw std::exception from destructors",
      "Use global catch in destructors",
      "Throw raw integers to reduce overhead"
    ]
  },
  {
    "q": "What is the output of this code?\n",
    "c": "#include <iostream>\nint main() {\n  try {\n    throw std::runtime_error(\"Runtime\");\n  } catch (const std::exception &e) {\n    std::cout << \"Caught: \" << e.what();\n  }\n}",
    "o": [
      "Caught: Runtime",
      "Runtime",
      "Caught exception",
      "Exception"
    ]
  },
  {
    "q": "Which header is required to use std::runtime_error?",
    "o": [
      "<stdexcept>",
      "<exception>",
      "<runtime>",
      "<error>"
    ]
  },
  {
    "q": "Which of the following types of exceptions is best suited for runtime errors?",
    "o": [
      "std::runtime_error",
      "std::logic_error",
      "std::invalid_argument",
      "std::out_of_range"
    ]
  },
  {
    "q": "What is the purpose of the catch(...) block?",
    "o": [
      "To catch any type of exception",
      "To catch logic errors only",
      "To avoid all exception handling",
      "To catch syntax errors"
    ]
  },
  {
    "q": "What will this code output?\n",
    "c": "#include <iostream>\nint main() {\n  try {\n    int* arr = new int[1000000000];\n  } catch (std::bad_alloc &e) {\n    std::cout << \"Allocation failed\";\n  }\n}",
    "o": [
      "Allocation failed",
      "Memory full",
      "Unhandled",
      "Caught exception"
    ]
  },
  {
    "q": "Which exception safety level ensures that no memory/resource leaks occur?",
    "o": [
      "Basic guarantee",
      "No-throw guarantee",
      "Minimal guarantee",
      "Fatal safety"
    ]
  },
  {
    "q": "What does this code do?\n",
    "c": "#include <iostream>\nvoid func() noexcept {\n  throw 1;\n}\nint main() {\n  func();\n}",
    "o": [
      "Calls std::terminate",
      "Throws and is caught",
      "Compiles without warning",
      "Outputs 1"
    ]
  },
  {
    "q": "Which of the following allows catching exceptions by type hierarchy?",
    "o": [
      "Polymorphic exception classes",
      "Exception filters",
      "Exception tables",
      "Function overloading"
    ]
  },
  {
    "q": "How would you catch both std::runtime_error and std::logic_error with one catch block?",
    "o": [
      "catch(const std::exception& e)",
      "catch(std::runtime_error | std::logic_error)",
      "catch(...)",
      "catch(auto e)"
    ]
  },
  {
    "q": "Which function in std::exception is marked noexcept?",
    "o": [
      "what()",
      "catch()",
      "raise()",
      "message()"
    ]
  },
  {
    "q": "What is a common reason for throwing a custom exception?",
    "o": [
      "To provide domain-specific error information",
      "To reduce compilation time",
      "To replace try-catch with switch-case",
      "To avoid using std::string"
    ]
  },
  {
    "q": "What happens when a noexcept function throws an exception?",
    "o": [
      "std::terminate is called",
      "The exception is caught by caller",
      "The program continues",
      "Compiler generates warning but allows it"
    ]
  },
  {
    "q": "Which of the following keywords is used to manually raise an exception in C++?",
    "o": [
      "throw",
      "raise",
      "except",
      "raise_exception"
    ]
  },
  {
    "q": "What does this code output?\n",
    "c": "#include <iostream>\nint main() {\n  try {\n    throw 'x';\n  } catch (int e) {\n    std::cout << \"int\";\n  } catch (char e) {\n    std::cout << e;\n  }\n}",
    "o": [
      "x",
      "int",
      "error",
      "exception"
    ]
  },
  {
    "q": "Which of these exceptions is thrown by a failed dynamic memory allocation using 'new'?",
    "o": [
      "std::bad_alloc",
      "std::runtime_error",
      "std::allocation_error",
      "std::null_exception"
    ]
  },
  {
    "q": "How do you define a custom exception class that extends std::exception?",
    "o": [
      "class MyEx : public std::exception { const char* what() const noexcept override { return \"MyEx\"; } };",
      "class MyEx : std::exception { string msg; };",
      "class MyEx { void error(); };",
      "struct MyEx extends exception {}; "
    ]
  },
  {
    "q": "What is the role of RAII in exception safety?",
    "o": [
      "It ensures automatic resource cleanup during stack unwinding",
      "It prevents exceptions from being thrown",
      "It logs thrown exceptions",
      "It delays exception propagation"
    ]
  },
  {
    "q": "What does this code output?\n",
    "c": "#include <iostream>\n#include <stdexcept>\nint main() {\n  try {\n    throw std::out_of_range(\"Out of range!\");\n  } catch (const std::exception& e) {\n    std::cout << e.what();\n  }\n}",
    "o": [
      "Out of range!",
      "std::out_of_range",
      "Exception thrown",
      "Range Error"
    ]
  },
  {
    "q": "Which of the following exceptions is part of the <exception> header?",
    "o": [
      "std::exception",
      "std::invalid_argument",
      "std::out_of_range",
      "std::runtime_error"
    ]
  },
  {
    "q": "What is the best practice for exception specification in modern C++?",
    "o": [
      "Use noexcept instead of dynamic exception specifications",
      "Use throw() for all functions",
      "Avoid using noexcept or throw entirely",
      "Use try/catch in every function"
    ]
  },
  {
    "q": "Which of the following describes the no-throw guarantee?",
    "o": [
      "The operation is guaranteed not to throw any exception",
      "The program will compile even if throw is missing",
      "No object destruction will occur",
      "Only custom exceptions can be thrown"
    ]
  },
  {
    "q": "What will this code print?\n",
    "c": "#include <iostream>\nint main() {\n  try {\n    throw std::string(\"Error\");\n  } catch (std::string& s) {\n    std::cout << s;\n  }\n}",
    "o": [
      "Error",
      "std::string",
      "Exception caught",
      "String exception"
    ]
  },
  {
    "q": "Which statement is TRUE regarding throwing exceptions in constructors?",
    "o": [
      "It prevents object creation and skips destructor call",
      "It leads to undefined behavior",
      "It must be avoided in C++",
      "It requires the use of templates"
    ]
  },
  {
    "q": "Which of the following exceptions is typically thrown when a container operation exceeds bounds?",
    "o": [
      "std::out_of_range",
      "std::length_error",
      "std::underflow_error",
      "std::domain_error"
    ]
  },
  {
    "q": "What happens if no catch block handles a thrown exception?",
    "o": [
      "The program terminates by calling std::terminate",
      "The exception is ignored",
      "The compiler handles it silently",
      "The operating system recovers"
    ]
  },
  {
    "q": "What kind of exception should you throw when a mathematical argument is outside its domain?",
    "o": [
      "std::domain_error",
      "std::range_error",
      "std::overflow_error",
      "std::bad_function_call"
    ]
  },
  {
    "q": "Which of these ensures a destructor won't throw during stack unwinding?",
    "o": [
      "Mark destructor as noexcept",
      "Use global catch block",
      "Use try block in destructor",
      "Call terminate()"
    ]
  },
  {
    "q": "What is the output of this code?\n",
    "c": "#include <iostream>\nint main() {\n  try {\n    throw 5;\n  } catch (double) {\n    std::cout << \"double\";\n  } catch (int) {\n    std::cout << \"int\";\n  }\n}",
    "o": [
      "int",
      "double",
      "5",
      "Error"
    ]
  },
  {
    "q": "What will happen if you throw inside a noexcept function?",
    "o": [
      "std::terminate is called",
      "Compilation fails",
      "The exception is caught by default handler",
      "Undefined behavior occurs"
    ]
  },
  {
    "q": "Which of the following is NOT a benefit of exception handling?",
    "o": [
      "Reduces code readability",
      "Improves error handling flexibility",
      "Supports stack unwinding",
      "Separates error-handling code from logic"
    ]
  },
  {
    "q": "Which exception class is thrown when converting to a wrong type via std::any_cast?",
    "o": [
      "std::bad_any_cast",
      "std::bad_cast",
      "std::type_mismatch",
      "std::invalid_conversion"
    ]
  },
  {
    "q": "Which catch block is guaranteed to handle any exception type?",
    "o": [
      "catch(...)",
      "catch(exception e)",
      "catch(int e)",
      "catch(auto e)"
    ]
  },
  {
    "q": "Which of the following exceptions is most appropriate when an invalid argument is passed to a function?",
    "o": [
      "std::invalid_argument",
      "std::logic_error",
      "std::domain_error",
      "std::range_error"
    ]
  },
  {
    "q": "What will the following code output?\n",
    "c": "#include <iostream>\n#include <stdexcept>\nint main() {\n  try {\n    throw std::overflow_error(\"Overflow\");\n  } catch (const std::exception &e) {\n    std::cout << e.what();\n  }\n}",
    "o": [
      "Overflow",
      "Exception",
      "runtime_error",
      "Caught error"
    ]
  },
  {
    "q": "Which of the following best describes exception neutrality?",
    "o": [
      "Allowing exceptions to propagate unchanged",
      "Catching all exceptions and suppressing them",
      "Wrapping all exceptions in std::exception",
      "Converting all exceptions to string"
    ]
  },
  {
    "q": "Which mechanism in C++ ensures that destructors are called when an exception is thrown?",
    "o": [
      "Stack unwinding",
      "RAII",
      "Smart pointers",
      "Exception masking"
    ]
  },
  {
    "q": "What will this program output?\n",
    "c": "#include <iostream>\nint main() {\n  try {\n    throw 3.14;\n  } catch (double x) {\n    std::cout << \"Caught double\";\n  }\n}",
    "o": [
      "Caught double",
      "Caught float",
      "Caught",
      "3.14"
    ]
  },
  {
    "q": "Which standard exception is typically used when accessing a map with an invalid key?",
    "o": [
      "std::out_of_range",
      "std::range_error",
      "std::key_error",
      "std::invalid_argument"
    ]
  },
  {
    "q": "What does noexcept(true) indicate?",
    "o": [
      "The function is guaranteed not to throw exceptions",
      "Exceptions will be caught at runtime",
      "Exceptions are suppressed",
      "The function may throw exceptions"
    ]
  },
  {
    "q": "Which of the following is used to define a base exception class for user-defined exceptions?",
    "o": [
      "class MyEx : public std::exception {}",
      "class MyEx : private std::error {}",
      "class MyEx extends exception {}",
      "class MyEx : implements std::exception {}"
    ]
  },
  {
    "q": "What is the output of this code?\n",
    "c": "#include <iostream>\nvoid risky() { throw std::runtime_error(\"Oops\"); }\nint main() {\n  try { risky(); } catch (...) {\n    std::cout << \"Caught something\";\n  }\n}",
    "o": [
      "Caught something",
      "Oops",
      "Caught runtime_error",
      "Unhandled exception"
    ]
  },
  {
    "q": "Which of the following provides the strongest exception guarantee?",
    "o": [
      "No-throw guarantee",
      "Strong guarantee",
      "Basic guarantee",
      "Weak guarantee"
    ]
  },
  {
    "q": "Which C++ construct is essential for achieving basic exception safety?",
    "o": [
      "RAII (Resource Acquisition Is Initialization)",
      "Multiple inheritance",
      "Function pointers",
      "Lambda expressions"
    ]
  },
  {
    "q": "Which of the following exceptions is best suited for detecting overflow errors?",
    "o": [
      "std::overflow_error",
      "std::range_error",
      "std::underflow_error",
      "std::domain_error"
    ]
  },
  {
    "q": "What is the output of this code?\n",
    "c": "#include <iostream>\nclass MyEx {};\nint main() {\n  try {\n    throw MyEx();\n  } catch (...) {\n    std::cout << \"Generic catch\";\n  }\n}",
    "o": [
      "Generic catch",
      "MyEx",
      "Unhandled",
      "Caught"
    ]
  },
  {
    "q": "Which of the following keywords is used to handle exceptions in C++?",
    "o": [
      "catch",
      "except",
      "handle",
      "recover"
    ]
  },
  {
    "q": "What does this code print?\n",
    "c": "#include <iostream>\nint main() {\n  try {\n    throw std::exception();\n  } catch (std::exception& e) {\n    std::cout << \"Standard exception\";\n  }\n}",
    "o": [
      "Standard exception",
      "Caught",
      "Handled",
      "Exception"
    ]
  },
  {
    "q": "Which standard C++ feature helps prevent memory/resource leaks when exceptions occur?",
    "o": [
      "RAII",
      "Multithreading",
      "Macros",
      "Templates"
    ]
  },
  {
    "q": "Which exception is thrown if an operation exceeds a defined limit, but the value is still within range?",
    "o": [
      "std::range_error",
      "std::overflow_error",
      "std::length_error",
      "std::domain_error"
    ]
  },
  {
    "q": "What kind of catch block is most specific?",
    "o": [
      "catch(std::invalid_argument&)",
      "catch(std::exception&)",
      "catch(...)",
      "catch(auto&)"
    ]
  },
  {
    "q": "What does the following code output?\n",
    "c": "#include <iostream>\nclass E {};\nint main() {\n  try {\n    throw E();\n  } catch (int) {\n    std::cout << \"int\";\n  } catch (...) {\n    std::cout << \"other\";\n  }\n}",
    "o": [
      "other",
      "int",
      "E",
      "Caught"
    ]
  },
  {
    "q": "Which exception type represents logic errors detected at compile-time or early runtime?",
    "o": [
      "std::logic_error",
      "std::runtime_error",
      "std::bad_exception",
      "std::type_error"
    ]
  },
  {
    "q": "Which of the following C++ features enables cleanup of local objects during exception propagation?",
    "o": [
      "Stack unwinding",
      "Catch-all handler",
      "Exception masking",
      "Smart pointer"
    ]
  },
  {
    "q": "Which C++ exception class is thrown when there's an attempt to use `typeid` on a null pointer to a polymorphic type?",
    "o": [
      "std::bad_typeid",
      "std::bad_cast",
      "std::invalid_argument",
      "std::type_error"
    ]
  },
  {
    "q": "What is printed by this code?\n",
    "c": "#include <iostream>\nint main() {\n  try {\n    throw std::logic_error(\"Logic error occurred\");\n  } catch (const std::exception& e) {\n    std::cout << e.what();\n  }\n}",
    "o": [
      "Logic error occurred",
      "Exception",
      "Caught logic_error",
      "error"
    ]
  },
  {
    "q": "Which of the following is a benefit of defining custom exception classes in C++?",
    "o": [
      "Improves clarity and provides specific error context",
      "Automatically logs the exception details",
      "Reduces binary size",
      "Prevents exceptions from being thrown"
    ]
  },
  {
    "q": "What does this code output?\n",
    "c": "#include <iostream>\nclass MyEx {};\nint main() {\n  try {\n    throw MyEx();\n  } catch (MyEx&) {\n    std::cout << \"MyEx caught\";\n  }\n}",
    "o": [
      "MyEx caught",
      "Error",
      "Caught",
      "Unhandled"
    ]
  },
  {
    "q": "What will happen if you throw an exception and there is no matching catch block?",
    "o": [
      "The program will call std::terminate",
      "The exception is silently ignored",
      "The compiler will fix it",
      "The stack is restored and execution resumes"
    ]
  },
  {
    "q": "What kind of error is best represented by std::length_error?",
    "o": [
      "A container is requested to exceed its maximum size",
      "Accessing outside of a valid index range",
      "Null pointer dereference",
      "File not found"
    ]
  },
  {
    "q": "Which catch block will catch all types of exceptions?",
    "o": [
      "catch(...)",
      "catch(std::exception e)",
      "catch(int e)",
      "catch(std::any e)"
    ]
  },
  {
    "q": "What is the output?\n",
    "c": "#include <iostream>\nint main() {\n  try {\n    throw 42;\n  } catch (int e) {\n    std::cout << e;\n  }\n}",
    "o": [
      "42",
      "int",
      "Caught",
      "Exception"
    ]
  },
  {
    "q": "Which of the following helps prevent resource leaks in exception-prone code?",
    "o": [
      "Using smart pointers and RAII",
      "Avoiding try-catch blocks",
      "Using raw pointers only",
      "Throwing basic types only"
    ]
  },
  {
    "q": "Which standard exception indicates failure due to a dynamic_cast?",
    "o": [
      "std::bad_cast",
      "std::bad_typeid",
      "std::invalid_argument",
      "std::range_error"
    ]
  },
  {
    "q": "What does noexcept(false) mean?",
    "o": [
      "The function may throw exceptions",
      "The function will not throw exceptions",
      "The function must not throw exceptions",
      "It disables all exception handling"
    ]
  },
  {
    "q": "Which standard exception represents an error due to input being out of a valid domain?",
    "o": [
      "std::domain_error",
      "std::out_of_range",
      "std::invalid_argument",
      "std::underflow_error"
    ]
  },
  {
    "q": "Which exception class is used as a base for all standard C++ exceptions?",
    "o": [
      "std::exception",
      "std::logic_error",
      "std::runtime_error",
      "std::error_base"
    ]
  },
  {
    "q": "What happens during stack unwinding?",
    "o": [
      "Destructors of all local objects are called as the stack unwinds",
      "The program terminates immediately",
      "All catch blocks are skipped",
      "Memory is leaked"
    ]
  },
  {
    "q": "What is printed?\n",
    "c": "#include <iostream>\nclass E : public std::exception {\n  const char* what() const noexcept override { return \"Custom E\"; }\n};\nint main() {\n  try {\n    throw E();\n  } catch (std::exception& e) {\n    std::cout << e.what();\n  }\n}",
    "o": [
      "Custom E",
      "E",
      "Exception",
      "Error"
    ]
  },
  {
    "q": "Which is the correct way to catch multiple exception types in C++?",
    "o": [
      "Use separate catch blocks for each exception type",
      "Use a single catch block with OR condition",
      "Use a try-finally block",
      "Use nested try-catch blocks for each type"
    ]
  },
  {
    "q": "Which of the following provides the basic exception safety guarantee?",
    "o": [
      "The program remains in a valid state after an exception",
      "No exceptions are thrown at all",
      "All resources are leaked",
      "All operations are completely rolled back"
    ]
  },
  {
    "q": "What exception is thrown when memory allocation fails using new?",
    "o": [
      "std::bad_alloc",
      "std::out_of_memory",
      "std::alloc_error",
      "std::runtime_error"
    ]
  },
  {
    "q": "What does this code output?\n",
    "c": "#include <iostream>\nint main() {\n  try {\n    throw std::underflow_error(\"Underflow occurred\");\n  } catch (const std::underflow_error& e) {\n    std::cout << e.what();\n  }\n}",
    "o": [
      "Underflow occurred",
      "Runtime error",
      "Caught",
      "underflow_error"
    ]
  },
  {
    "q": "Which of the following keywords is used to throw an exception in C++?",
    "o": [
      "throw",
      "raise",
      "except",
      "error"
    ]
  },
  {
    "q": "What is the correct order of catch blocks for proper exception handling in C++?",
    "o": [
      "From most specific to most generic",
      "From most generic to most specific",
      "Order does not matter",
      "Only one catch block is allowed"
    ]
  },
  {
    "q": "Which of the following is true about exception specification in C++11?",
    "o": [
      "Dynamic exception specifications are deprecated",
      "Functions must declare all thrown exceptions",
      "All functions must be noexcept",
      "Only standard exceptions can be thrown"
    ]
  },
  {
    "q": "What will the following code print?\n",
    "c": "#include <iostream>\nint main() {\n  try {\n    throw 'x';\n  } catch (char c) {\n    std::cout << c;\n  }\n}",
    "o": [
      "x",
      "char",
      "Caught",
      "Error"
    ]
  },
  {
    "q": "Which of the following is an example of a custom exception class?",
    "o": [
      "class MyError : public std::exception {};",
      "class MyError : public std::logic_error {};",
      "class MyError() extends std::exception {};",
      "struct MyError inherits std::exception {};"
    ]
  },
  {
    "q": "Which C++ standard introduced noexcept?",
    "o": [
      "C++11",
      "C++98",
      "C++03",
      "C++17"
    ]
  },
  {
    "q": "Which of the following standard exceptions represents a problem when a container exceeds its maximum size?",
    "o": [
      "std::length_error",
      "std::range_error",
      "std::overflow_error",
      "std::invalid_argument"
    ]
  },
  {
    "q": "What happens if an exception is thrown but not caught anywhere in the program?",
    "o": [
      "The program calls std::terminate",
      "The exception is logged and ignored",
      "The compiler automatically catches it",
      "A warning is issued but the program continues"
    ]
  },
  {
    "q": "Which of these ensures a resource is released properly in presence of exceptions?",
    "o": [
      "RAII (Resource Acquisition Is Initialization)",
      "Using raw pointers",
      "Manual memory management",
      "Try-finally"
    ]
  },
  {
    "q": "What will the output be?\n",
    "c": "#include <iostream>\nclass A {};\nint main() {\n  try {\n    throw A();\n  } catch (int) {\n    std::cout << \"int\";\n  } catch (...) {\n    std::cout << \"unknown\";\n  }\n}",
    "o": [
      "unknown",
      "int",
      "A",
      "caught"
    ]
  },
  {
    "q": "What kind of exception should be thrown when a function receives a value that violates a logical precondition?",
    "o": [
      "std::invalid_argument",
      "std::runtime_error",
      "std::range_error",
      "std::overflow_error"
    ]
  },
  {
    "q": "Which of these exceptions is derived from std::logic_error?",
    "o": [
      "std::domain_error",
      "std::runtime_error",
      "std::overflow_error",
      "std::underflow_error"
    ]
  },
  {
    "q": "Which catch block catches all exceptions deriving from std::exception?",
    "o": [
      "catch(const std::exception& e)",
      "catch(...)",
      "catch(std::any& e)",
      "catch(auto e)"
    ]
  },
  {
    "q": "What is the correct syntax to rethrow the current exception?",
    "o": [
      "throw;",
      "throw current;",
      "rethrow();",
      "throw again;"
    ]
  },
  {
    "q": "What will this code output?\n",
    "c": "#include <iostream>\n#include <stdexcept>\nint main() {\n  try {\n    throw std::range_error(\"range error\");\n  } catch (std::range_error& e) {\n    std::cout << e.what();\n  }\n}",
    "o": [
      "range error",
      "error",
      "range_error",
      "exception"
    ]
  },
  {
    "q": "Which of the following standard exceptions is used when a type conversion fails?",
    "o": [
      "std::bad_cast",
      "std::bad_typeid",
      "std::type_mismatch",
      "std::invalid_conversion"
    ]
  },
  {
    "q": "What is the result of this program?\n",
    "c": "#include <iostream>\nint main() {\n  try {\n    int* arr = new int[10000000000];\n  } catch (std::bad_alloc& e) {\n    std::cout << \"Allocation failed\";\n  }\n}",
    "o": [
      "Allocation failed",
      "Exception",
      "bad_alloc",
      "10000000000"
    ]
  },
  {
    "q": "Which exception class represents errors that occur during program execution but not due to logical errors?",
    "o": [
      "std::runtime_error",
      "std::logic_error",
      "std::invalid_argument",
      "std::bad_alloc"
    ]
  },
  {
    "q": "Which part of the function declaration specifies that the function does not throw any exception?",
    "o": [
      "noexcept",
      "try",
      "catch",
      "throw()"
    ]
  },
  {
    "q": "How do you catch an exception object by reference?",
    "o": [
      "catch (const std::exception& e)",
      "catch (std::exception e)",
      "catch (std::exception&& e)",
      "catch (*std::exception e)"
    ]
  },
  {
    "q": "What does the following code output?\n",
    "c": "#include <iostream>\nint main() {\n  try {\n    throw std::runtime_error(\"Runtime error!\");\n  } catch (std::runtime_error& e) {\n    std::cout << e.what();\n  }\n}",
    "o": [
      "Runtime error!",
      "runtime_error",
      "Error",
      "Exception"
    ]
  },
  {
    "q": "Which exception safety level ensures no side effects if an exception occurs?",
    "o": [
      "No-throw guarantee",
      "Basic guarantee",
      "Strong guarantee",
      "RAII guarantee"
    ]
  },
  {
    "q": "Which C++ standard exception should be thrown when an argument violates logical preconditions?",
    "o": [
      "std::domain_error",
      "std::range_error",
      "std::underflow_error",
      "std::length_error"
    ]
  },
  {
    "q": "What is the purpose of `catch(...)` in a try-catch block?",
    "o": [
      "To catch any exception type",
      "To catch only logic_error exceptions",
      "To ignore exceptions",
      "To propagate the exception"
    ]
  },
  {
    "q": "What does this program print?\n",
    "c": "#include <iostream>\nclass MyEx {};\nint main() {\n  try {\n    throw MyEx();\n  } catch (...) {\n    std::cout << \"Generic Catch\";\n  }\n}",
    "o": [
      "Generic Catch",
      "MyEx",
      "Exception",
      "Error"
    ]
  },
  {
    "q": "Which standard exception is thrown by `dynamic_cast` when it fails with references?",
    "o": [
      "std::bad_cast",
      "std::bad_typeid",
      "std::cast_error",
      "std::invalid_argument"
    ]
  },
  {
    "q": "In a custom exception class, what should the `what()` method return?",
    "o": [
      "A const char* describing the error",
      "An int error code",
      "A bool indicating success",
      "The exception type"
    ]
  },
  {
    "q": "What will this code output?\n",
    "c": "#include <iostream>\n#include <stdexcept>\nint main() {\n  try {\n    throw std::logic_error(\"Logic fail\");\n  } catch (std::exception& e) {\n    std::cout << e.what();\n  }\n}",
    "o": [
      "Logic fail",
      "std::logic_error",
      "fail",
      "exception caught"
    ]
  },
  {
    "q": "Which of the following ensures that an exception will not propagate out of a function?",
    "o": [
      "Declaring the function with `noexcept`",
      "Wrapping all code in try/catch",
      "Throwing only standard exceptions",
      "Using `goto` instead of exceptions"
    ]
  },
  {
    "q": "Which of these is a valid throw statement in C++?",
    "o": [
      "throw std::runtime_error(\"Error\");",
      "throw new std::runtime_error(\"Error\");",
      "raise std::runtime_error(\"Error\");",
      "exception std::runtime_error(\"Error\");"
    ]
  },
  {
    "q": "What happens during stack unwinding in exception handling?",
    "o": [
      "Destructors for local objects are called",
      "The stack pointer is reset to zero",
      "All memory is cleared",
      "The program skips all destructors"
    ]
  },
  {
    "q": "Which exception indicates an arithmetic overflow error?",
    "o": [
      "std::overflow_error",
      "std::range_error",
      "std::domain_error",
      "std::logic_error"
    ]
  },
  {
    "q": "Which of the following ensures automatic resource management in exception-prone code?",
    "o": [
      "RAII (Resource Acquisition Is Initialization)",
      "Using try-finally",
      "Manual cleanup in catch blocks",
      "Avoiding dynamic allocation"
    ]
  },
  {
    "q": "What is the output of the following code?\n",
    "c": "#include <iostream>\nvoid risky() {\n  throw 3.14;\n}\nint main() {\n  try {\n    risky();\n  } catch (double d) {\n    std::cout << d;\n  }\n}",
    "o": [
      "3.14",
      "double",
      "Exception",
      "risky"
    ]
  },
  {
    "q": "How is a custom exception class typically defined in C++?",
    "o": [
      "By inheriting from std::exception",
      "By inheriting from std::runtime_error only",
      "By using a macro",
      "By overloading throw() operator"
    ]
  },
  {
    "q": "Which exception is thrown when there is an attempt to access beyond valid container boundaries?",
    "o": [
      "std::out_of_range",
      "std::range_error",
      "std::overflow_error",
      "std::bad_cast"
    ]
  },
  {
    "q": "What keyword is used in C++ to handle exceptions?",
    "o": [
      "catch",
      "handle",
      "except",
      "recover"
    ]
  },
  {
    "q": "How can you rethrow an exception from a catch block?",
    "o": [
      "Using the `throw;` statement alone",
      "Using `throw e;`",
      "Using `raise();`",
      "Using `throw exception;`"
    ]
  },
  {
    "q": "Which of the following standard exceptions represents an arithmetic underflow error?",
    "o": [
      "std::underflow_error",
      "std::domain_error",
      "std::length_error",
      "std::logic_error"
    ]
  },
  {
    "q": "What will this code print?\n",
    "c": "#include <iostream>\nclass BaseException : public std::exception {\npublic:\n  const char* what() const noexcept override { return \"BaseException\"; }\n};\nint main() {\n  try {\n    throw BaseException();\n  } catch (const std::exception& e) {\n    std::cout << e.what();\n  }\n}",
    "o": [
      "BaseException",
      "Exception",
      "std::exception",
      "Caught"
    ]
  },
  {
    "q": "Which keyword is used to define a block of code that may generate exceptions in C++?",
    "o": [
      "try",
      "catch",
      "throw",
      "handle"
    ]
  },
  {
    "q": "What is the output of the following code?\n",
    "c": "#include <iostream>\nint main() {\n  try {\n    throw 404;\n  } catch (int e) {\n    std::cout << \"Error code: \" << e;\n  }\n}",
    "o": [
      "Error code: 404",
      "404",
      "Error",
      "Exception caught"
    ]
  },
  {
    "q": "Which standard exception should be thrown when a function receives an invalid value?",
    "o": [
      "std::invalid_argument",
      "std::logic_error",
      "std::domain_error",
      "std::range_error"
    ]
  },
  {
    "q": "Which of the following ensures no resource leaks even when an exception occurs?",
    "o": [
      "Using RAII (Resource Acquisition Is Initialization)",
      "Using raw pointers and delete",
      "Using try/catch inside every function",
      "Avoiding dynamic memory"
    ]
  },
  {
    "q": "What happens when no matching catch block is found for a thrown exception?",
    "o": [
      "std::terminate is called",
      "The program tries to recover",
      "The exception is ignored",
      "A warning is displayed"
    ]
  },
  {
    "q": "What will this code output?\n",
    "c": "#include <iostream>\nclass MyException : public std::exception {\n  const char* what() const noexcept override {\n    return \"MyException occurred\";\n  }\n};\nint main() {\n  try {\n    throw MyException();\n  } catch (std::exception& e) {\n    std::cout << e.what();\n  }\n}",
    "o": [
      "MyException occurred",
      "Exception",
      "Caught",
      "Error"
    ]
  },
  {
    "q": "Which standard exception is thrown when a new memory allocation fails?",
    "o": [
      "std::bad_alloc",
      "std::overflow_error",
      "std::logic_error",
      "std::invalid_argument"
    ]
  },
  {
    "q": "Which of the following is true about noexcept in C++?",
    "o": [
      "It tells the compiler the function will not throw exceptions",
      "It guarantees stack unwinding",
      "It disables exception handling",
      "It allows runtime exception checks"
    ]
  },
  {
    "q": "What does this program print?\n",
    "c": "#include <iostream>\nint main() {\n  try {\n    throw std::out_of_range(\"Index out of range\");\n  } catch (const std::exception& e) {\n    std::cout << e.what();\n  }\n}",
    "o": [
      "Index out of range",
      "out_of_range",
      "std::exception",
      "Error"
    ]
  },
  {
    "q": "Which of the following is a correct custom exception class declaration?",
    "o": [
      "class MyError : public std::exception { const char* what() const noexcept override { return \"Error\"; } };",
      "class MyError { virtual const char* what() { return \"Error\"; } };",
      "struct MyError extends std::exception {};",
      "class MyError : std::exception { const char* what(); };"
    ]
  },
  {
    "q": "What is the correct way to catch all types of exceptions?",
    "o": [
      "catch(...)",
      "catch(all)",
      "catch(*)",
      "catch(Exception)"
    ]
  },
  {
    "q": "Which standard exception is thrown when an operation attempts to exceed container capacity?",
    "o": [
      "std::length_error",
      "std::overflow_error",
      "std::range_error",
      "std::logic_error"
    ]
  },
  {
    "q": "Which of the following is part of strong exception safety guarantee?",
    "o": [
      "Operations either complete successfully or have no effect",
      "The program may leave resources leaked",
      "An exception leaves data in a partially updated state",
      "The object becomes invalid after an exception"
    ]
  },
  {
    "q": "What will be printed?\n",
    "c": "#include <iostream>\n#include <stdexcept>\nvoid f() { throw std::domain_error(\"Math error\"); }\nint main() {\n  try { f(); } catch (std::domain_error& e) {\n    std::cout << e.what();\n  }\n}",
    "o": [
      "Math error",
      "domain_error",
      "Error",
      "Caught"
    ]
  },
  {
    "q": "What will this code print?\n",
    "c": "#include <iostream>\nvoid test() {\n  try {\n    throw;\n  } catch (...) {\n    std::cout << \"Exception rethrown\";\n  }\n}\nint main() {\n  try {\n    throw 1;\n  } catch (...) {\n    test();\n  }\n}",
    "o": [
      "Exception rethrown",
      "1",
      "Error",
      "Unhandled"
    ]
  },
  {
    "q": "Which standard exception is most suitable for reporting a conversion failure?",
    "o": [
      "std::bad_cast",
      "std::invalid_argument",
      "std::range_error",
      "std::underflow_error"
    ]
  },
  {
    "q": "How would you indicate that a function does not throw exceptions in C++11 or later?",
    "o": [
      "By adding `noexcept` after the function signature",
      "By declaring `throw()`",
      "By wrapping the body in try/catch",
      "By returning void"
    ]
  },
  {
    "q": "What kind of error does std::underflow_error indicate?",
    "o": [
      "An arithmetic underflow during computation",
      "A missing file",
      "Out-of-bounds access",
      "Invalid data type"
    ]
  },
  {
    "q": "Which exception safety guarantee ensures that all invariants of an object remain valid and no leaks occur?",
    "o": [
      "Basic guarantee",
      "No-throw guarantee",
      "Strong guarantee",
      "Invariant guarantee"
    ]
  },
  {
    "q": "What happens to local objects when an exception is thrown and not caught in the same block?",
    "o": [
      "Their destructors are called during stack unwinding",
      "They remain in memory",
      "They are skipped",
      "They are set to null"
    ]
  },
  {
    "q": "What is the correct syntax to catch an exception in C++?",
    "o": [
      "try { /* code */ } catch(ExceptionType e) { /* handler */ }",
      "try: { /* code */ } catch(ExceptionType e) { /* handler */ }",
      "try (/* code */) catch(ExceptionType e) { /* handler */ }",
      "try { /* code */ }; catch(ExceptionType e) { /* handler */ }"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        throw 10;\n    } catch (int e) {\n        cout << \"Caught exception: \" << e << endl;\n    }\n    return 0;\n}",
    "o": [
      "Caught exception: 10",
      "Caught exception: e",
      "Error: Cannot catch int",
      "No output"
    ]
  },
  {
    "q": "Which of the following is a standard exception in C++?",
    "o": [
      "std::out_of_range",
      "std::wrong_type",
      "std::invalid_pointer",
      "std::null_reference"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nint main() {\n    try {\n        throw runtime_error(\"Runtime error occurred\");\n    } catch (runtime_error &e) {\n        cout << e.what() << endl;\n    }\n    return 0;\n}",
    "o": [
      "Runtime error occurred",
      "Error caught",
      "Exception thrown",
      "Unhandled exception"
    ]
  },
  {
    "q": "How do you define a custom exception class in C++?",
    "o": [
      "By inheriting from std::exception and overriding what() method",
      "By using the keyword 'exception class'",
      "By using struct only",
      "Custom exceptions are not allowed in C++"
    ]
  },
  {
    "q": "What is exception safety in C++?",
    "o": [
      "The guarantee that code behaves correctly in the presence of exceptions",
      "Avoiding exception handling altogether",
      "A way to catch all types of exceptions using int",
      "Throwing exceptions from destructors"
    ]
  },
  {
    "q": "What will be the output of the following C++ code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass MyException {};\n\nint main() {\n    try {\n        throw MyException();\n    } catch (MyException &e) {\n        cout << \"Custom exception caught\" << endl;\n    }\n    return 0;\n}",
    "o": [
      "Custom exception caught",
      "Compilation error",
      "Exception not caught",
      "No output"
    ]
  },
  {
    "q": "Which block must always be present in exception handling in C++?",
    "o": [
      "try",
      "catch",
      "finally",
      "throw"
    ]
  },
  {
    "q": "Which C++ keyword is used to manually raise an exception?",
    "o": [
      "throw",
      "raise",
      "raise_exception",
      "except"
    ]
  },
  {
    "q": "What is the output of the following C++ code?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        int x = 5;\n        if (x > 0) throw 'A';\n    } catch (char c) {\n        cout << \"Caught: \" << c << endl;\n    }\n    return 0;\n}",
    "o": [
      "Caught: A",
      "Caught: x",
      "Caught: 5",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following exceptions is thrown by the C++ Standard Library when accessing an invalid index in a vector?",
    "o": [
      "std::out_of_range",
      "std::range_error",
      "std::length_error",
      "std::invalid_argument"
    ]
  },
  {
    "q": "How do you catch any exception regardless of its type in C++?",
    "o": [
      "catch (...)",
      "catch (Exception e)",
      "catch (any)",
      "catch (all)"
    ]
  },
  {
    "q": "What is the purpose of the `what()` function in C++ exception handling?",
    "o": [
      "It returns a description of the exception",
      "It throws the exception object",
      "It logs the exception to console",
      "It retries the failed code block"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nint main() {\n    try {\n        throw logic_error(\"Logic failure\");\n    } catch (exception &e) {\n        cout << \"Caught: \" << e.what();\n    }\n    return 0;\n}",
    "o": [
      "Caught: Logic failure",
      "Caught: runtime error",
      "Caught: logic_error",
      "Caught: exception"
    ]
  },
  {
    "q": "Which of the following best describes a 'strong exception safety guarantee'?",
    "o": [
      "Operations either complete successfully or have no side effects",
      "All exceptions are ignored",
      "Exceptions are logged automatically",
      "Exception handlers always return default values"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass DivideByZero {};\n\nint main() {\n    try {\n        int a = 5, b = 0;\n        if (b == 0) throw DivideByZero();\n        cout << a / b;\n    } catch (DivideByZero &) {\n        cout << \"Division by zero error\";\n    }\n    return 0;\n}",
    "o": [
      "Division by zero error",
      "0",
      "5",
      "Compilation error"
    ]
  },
  {
    "q": "Which C++ standard exception is thrown by functions that are passed invalid arguments?",
    "o": [
      "std::invalid_argument",
      "std::out_of_range",
      "std::logic_error",
      "std::bad_alloc"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nvoid check(int age) {\n    if (age < 18)\n        throw invalid_argument(\"Underage\");\n}\n\nint main() {\n    try {\n        check(15);\n    } catch (invalid_argument &e) {\n        cout << \"Error: \" << e.what();\n    }\n    return 0;\n}",
    "o": [
      "Error: Underage",
      "Error: invalid",
      "Underage",
      "15"
    ]
  },
  {
    "q": "What does 'no-throw guarantee' mean in exception safety?",
    "o": [
      "The operation is guaranteed not to throw any exception",
      "The operation catches all exceptions",
      "The operation throws standard exceptions only",
      "The operation logs exceptions automatically"
    ]
  },
  {
    "q": "How do you declare a custom exception class named `MyException` that stores a message?",
    "o": [
      "class MyException : public std::exception {\n  std::string msg;\npublic:\n  MyException(std::string m) : msg(m) {}\n  const char* what() const noexcept override { return msg.c_str(); }\n};",
      "class MyException extends std::exception {\n  string msg;\n};",
      "exception MyException(string msg);",
      "throw class MyException(string msg);"
    ]
  },
  {
    "q": "Which of the following best defines exception neutrality?",
    "o": [
      "Code should not catch exceptions it cannot handle",
      "Code should convert exceptions into error codes",
      "All exceptions must be re-thrown",
      "Only standard exceptions should be used"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        throw 3.14;\n    } catch (double d) {\n        cout << \"Caught double: \" << d;\n    }\n    return 0;\n}",
    "o": [
      "Caught double: 3.14",
      "Caught: 3.14",
      "Error",
      "Caught double: d"
    ]
  },
  {
    "q": "Which exception is thrown when memory allocation using `new` fails?",
    "o": [
      "std::bad_alloc",
      "std::overflow_error",
      "std::length_error",
      "std::null_exception"
    ]
  },
  {
    "q": "Why should you avoid throwing exceptions from destructors?",
    "o": [
      "It can cause program termination if another exception is active",
      "It slows down the program",
      "It increases memory usage",
      "It hides bugs"
    ]
  },
  {
    "q": "Which of the following keywords is used to define a block of code that may raise an exception in C++?",
    "o": [
      "try",
      "catch",
      "throw",
      "raise"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        cout << \"Before throw\\n\";\n        throw 42;\n        cout << \"After throw\\n\";\n    } catch (int e) {\n        cout << \"Caught exception: \" << e << endl;\n    }\n    return 0;\n}",
    "o": [
      "Before throw\nCaught exception: 42",
      "Before throw\nAfter throw\nCaught exception: 42",
      "Caught exception: 42",
      "After throw\nCaught exception: 42"
    ]
  },
  {
    "q": "Which of the following standard exceptions is derived from `std::logic_error`?",
    "o": [
      "std::domain_error",
      "std::runtime_error",
      "std::bad_alloc",
      "std::overflow_error"
    ]
  },
  {
    "q": "What does it mean if a function provides the 'basic exception safety guarantee'?",
    "o": [
      "The function may leave the object in a valid but unspecified state",
      "The function never throws exceptions",
      "The function guarantees rollback on failure",
      "The function only throws standard exceptions"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nvoid risky() {\n    throw runtime_error(\"Failed!\");\n}\n\nint main() {\n    try {\n        risky();\n    } catch (runtime_error &e) {\n        cout << \"Caught: \" << e.what();\n    }\n    return 0;\n}",
    "o": [
      "Caught: Failed!",
      "Caught: runtime_error",
      "Caught: exception",
      "Failed!"
    ]
  },
  {
    "q": "Which of the following is TRUE about exception propagation in C++?",
    "o": [
      "An exception is passed up the call stack until a matching catch block is found",
      "The program terminates immediately after an exception is thrown",
      "Only local catch blocks can handle exceptions",
      "Exceptions can only be caught by functions where they are thrown"
    ]
  },
  {
    "q": "Which of the following is a correct custom exception class in C++?",
    "o": [
      "class MyError : public std::exception {\n  const char* what() const noexcept override {\n    return \"My error occurred\";\n  }\n};",
      "class MyError {\n  const char* error() const { return \"Error\"; }\n};",
      "throw new MyError();",
      "class MyError : public exception {}; int what();"
    ]
  },
  {
    "q": "What is the purpose of the ellipsis (`...`) in `catch(...)`?",
    "o": [
      "To catch any exception regardless of its type",
      "To ignore exceptions",
      "To catch standard exceptions only",
      "To re-throw exceptions"
    ]
  },
  {
    "q": "What is the correct syntax to throw an integer exception in C++?",
    "o": [
      "throw 10;",
      "throw(int) 10;",
      "throw exception 10;",
      "raise 10;"
    ]
  },
  {
    "q": "Which standard exception is used to report errors in numeric operations?",
    "o": [
      "std::overflow_error",
      "std::invalid_argument",
      "std::bad_cast",
      "std::range_error"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        int* arr = new int[1000000000000];\n    } catch (bad_alloc& e) {\n        cout << \"Allocation failed: \" << e.what();\n    }\n    return 0;\n}",
    "o": [
      "Allocation failed: std::bad_alloc",
      "Allocation failed: memory_error",
      "Allocation failed: runtime error",
      "Allocation failed: allocation failed"
    ]
  },
  {
    "q": "Which of the following is an advantage of exception handling in C++?",
    "o": [
      "It separates error-handling code from regular code",
      "It makes programs run faster",
      "It removes the need for debugging",
      "It prevents all bugs"
    ]
  },
  {
    "q": "How do you re-throw a caught exception in C++?",
    "o": [
      "throw;",
      "rethrow();",
      "raise();",
      "throw again;"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        throw string(\"String exception\");\n    } catch (int e) {\n        cout << \"Caught int: \" << e;\n    } catch (...) {\n        cout << \"Caught unknown exception\";\n    }\n    return 0;\n}",
    "o": [
      "Caught unknown exception",
      "Caught int: 0",
      "Caught: String exception",
      "Caught string: String exception"
    ]
  },
  {
    "q": "Which of these statements about custom exception classes in C++ is TRUE?",
    "o": [
      "They should inherit from std::exception to work seamlessly with standard exception handling",
      "They must be derived from std::runtime_error",
      "They can only contain a string message",
      "They cannot override the what() method"
    ]
  },
  {
    "q": "Which of the following levels of exception safety ensures that operations have no side effects if an exception occurs?",
    "o": [
      "Strong exception safety",
      "Basic exception safety",
      "No-throw guarantee",
      "Weak exception safety"
    ]
  },
  {
    "q": "Which of the following C++ exception types is thrown when a dynamic cast to a reference type fails?",
    "o": [
      "std::bad_cast",
      "std::bad_alloc",
      "std::domain_error",
      "std::invalid_argument"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nint main() {\n    try {\n        throw logic_error(\"Logic error occurred\");\n    } catch (exception& e) {\n        cout << e.what();\n    }\n    return 0;\n}",
    "o": [
      "Logic error occurred",
      "exception",
      "LogicError",
      "Unhandled exception"
    ]
  },
  {
    "q": "Which standard exception class should be used when a function receives an invalid argument?",
    "o": [
      "std::invalid_argument",
      "std::range_error",
      "std::overflow_error",
      "std::logic_error"
    ]
  },
  {
    "q": "What is required to ensure exception safety in resource management?",
    "o": [
      "Using RAII (Resource Acquisition Is Initialization)",
      "Using global variables",
      "Avoiding try-catch blocks",
      "Using raw pointers for better control"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "#include <iostream>\nusing namespace std;\n\nvoid test() {\n    throw 'x';\n}\n\nint main() {\n    try {\n        test();\n    } catch (char e) {\n        cout << \"Caught char: \" << e;\n    }\n    return 0;\n}",
    "o": [
      "Caught char: x",
      "Caught: x",
      "Exception caught",
      "Caught exception"
    ]
  },
  {
    "q": "What does `std::terminate()` do when an exception is not caught?",
    "o": [
      "Ends the program abruptly",
      "Ignores the exception",
      "Logs the exception and continues",
      "Returns control to the catch block"
    ]
  },
  {
    "q": "How can you catch multiple types of exceptions in C++?",
    "o": [
      "By writing multiple catch blocks with different exception types",
      "By writing a single catch block with multiple types",
      "By using a switch-case inside catch",
      "By overloading the try block"
    ]
  },
  {
    "q": "What is the role of `what()` in standard exception classes?",
    "o": [
      "Returns a C-style string describing the error",
      "Prints the exception",
      "Re-throws the exception",
      "Returns the exception type"
    ]
  },
  {
    "q": "Which keyword is used to indicate that an exception will be raised in C++?",
    "o": [
      "throw",
      "raise",
      "exception",
      "error"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        throw 3.14;\n    } catch (double e) {\n        cout << \"Caught double: \" << e;\n    }\n    return 0;\n}",
    "o": [
      "Caught double: 3.14",
      "Caught int: 3",
      "Caught something",
      "Unhandled exception"
    ]
  },
  {
    "q": "Which exception is thrown by new if memory allocation fails?",
    "o": [
      "std::bad_alloc",
      "std::bad_cast",
      "std::runtime_error",
      "std::overflow_error"
    ]
  },
  {
    "q": "What kind of exception safety guarantee ensures that the program remains in a valid state even if an exception is thrown?",
    "o": [
      "Basic exception safety",
      "No-throw guarantee",
      "Total exception safety",
      "Perfect safety guarantee"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        throw;\n    } catch (...) {\n        cout << \"Generic catch block\";\n    }\n    return 0;\n}",
    "o": [
      "Generic catch block",
      "Nothing will be printed",
      "Syntax error",
      "Unhandled exception"
    ]
  },
  {
    "q": "Which function should a custom exception class override to provide a descriptive error message?",
    "o": [
      "what()",
      "why()",
      "message()",
      "error()"
    ]
  },
  {
    "q": "In which header file is std::exception defined?",
    "o": [
      "<exception>",
      "<stdexcept>",
      "<error>",
      "<iostream>"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nclass MyException : public exception {\npublic:\n    const char* what() const noexcept override {\n        return \"Custom Exception\";\n    }\n};\n\nint main() {\n    try {\n        throw MyException();\n    } catch (exception& e) {\n        cout << e.what();\n    }\n    return 0;\n}",
    "o": [
      "Custom Exception",
      "Exception",
      "MyException",
      "Unhandled Exception"
    ]
  },
  {
    "q": "Which of the following is the correct syntax for catching multiple exceptions in C++?",
    "o": [
      "catch (exception_type1& e) { } catch (exception_type2& e) { }",
      "catch (exception_type1& e, exception_type2& e) { }",
      "catch (exception_type1, exception_type2) { }",
      "catch (e) { }"
    ]
  },
  {
    "q": "Which standard exception class is thrown when an operation attempts to access a value outside of the valid range?",
    "o": [
      "std::out_of_range",
      "std::invalid_argument",
      "std::logic_error",
      "std::bad_alloc"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        throw 404;\n    } catch (int e) {\n        cout << \"Caught integer: \" << e;\n    }\n    return 0;\n}",
    "o": [
      "Caught integer: 404",
      "Caught exception",
      "Caught 404",
      "Unhandled exception"
    ]
  },
  {
    "q": "Which of the following ensures a program remains in a valid state even after an exception occurs?",
    "o": [
      "Exception safety",
      "Error handling",
      "Code optimization",
      "Runtime performance"
    ]
  },
  {
    "q": "What does the `throw` keyword in C++ do?",
    "o": [
      "Throws an exception to be caught by a catch block",
      "Catches an exception from a try block",
      "Re-throws an exception from a catch block",
      "Ends the program execution"
    ]
  },
  {
    "q": "Which of the following is a valid custom exception class in C++?",
    "o": [
      "class MyException : public std::exception { public: const char* what() const noexcept override { return \"My custom exception\"; } }",
      "class MyException : public exception { public: void what() { return \"My custom exception\"; } }",
      "class MyException { public: void what() { return \"My custom exception\"; } }",
      "class MyException { public: const char* what() { return \"My custom exception\"; } }"
    ]
  },
  {
    "q": "What happens when a `std::exception` is thrown and not caught?",
    "o": [
      "The program terminates",
      "The program continues execution",
      "The program outputs an error message and continues",
      "The program goes into an infinite loop"
    ]
  },
  {
    "q": "In which case is exception safety particularly important?",
    "o": [
      "When dealing with resource management (e.g., memory allocation, file handling)",
      "When trying to optimize the program's performance",
      "When debugging logical errors",
      "When dealing with non-critical user input"
    ]
  },
  {
    "q": "What is the default behavior when an exception is thrown in C++ and no matching `catch` block is found?",
    "o": [
      "The program calls `std::terminate()`",
      "The program continues execution",
      "The exception is silently ignored",
      "The program outputs the exception message"
    ]
  },
  {
    "q": "Which of the following is true about exception handling in C++?",
    "o": [
      "Exceptions can be thrown using the `throw` keyword and caught with the `catch` keyword",
      "Exceptions can only be thrown by the compiler",
      "Catch blocks must be specified in a specific order, from general to specific",
      "C++ does not support exception handling"
    ]
  },
  {
    "q": "Which of the following standard exceptions is thrown when an invalid argument is passed to a function?",
    "o": [
      "std::invalid_argument",
      "std::bad_alloc",
      "std::out_of_range",
      "std::runtime_error"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        throw 'A';\n    } catch (char e) {\n        cout << \"Caught char: \" << e;\n    }\n    return 0;\n}",
    "o": [
      "Caught char: A",
      "Caught exception",
      "Caught: A",
      "Unhandled exception"
    ]
  },
  {
    "q": "Which exception class is used to represent a failure in memory allocation?",
    "o": [
      "std::bad_alloc",
      "std::logic_error",
      "std::range_error",
      "std::invalid_argument"
    ]
  },
  {
    "q": "What is the purpose of `noexcept` in C++ exception handling?",
    "o": [
      "Indicates that a function will not throw any exceptions",
      "Marks a function as throwing an exception",
      "Catches an exception in a function",
      "Declares an exception type"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        throw 10;\n    } catch (int e) {\n        cout << \"Caught integer: \" << e;\n    }\n    return 0;\n}",
    "o": [
      "Caught integer: 10",
      "Caught: 10",
      "Caught exception",
      "Unhandled exception"
    ]
  },
  {
    "q": "Which of the following is true regarding exception handling in C++?",
    "o": [
      "Exception handling is implemented using `try`, `catch`, and `throw` keywords",
      "C++ does not support exception handling",
      "Exceptions can only be handled using a single catch block",
      "Exceptions in C++ are handled automatically by the compiler"
    ]
  },
  {
    "q": "Which exception type would you typically use to indicate an error caused by an invalid argument passed to a function in C++?",
    "o": [
      "std::invalid_argument",
      "std::bad_alloc",
      "std::range_error",
      "std::logic_error"
    ]
  },
  {
    "q": "How would you write a custom exception class in C++?",
    "o": [
      "class MyException : public std::exception { public: const char* what() const noexcept override { return \"Custom exception\"; } }",
      "class MyException { public: const char* what() const noexcept { return \"Custom exception\"; } }",
      "class MyException : public exception { public: void what() { return \"Custom exception\"; } }",
      "class MyException { public: const char* message() { return \"Custom exception\"; } }"
    ]
  },
  {
    "q": "What is the effect of `throw;` in a catch block in C++?",
    "o": [
      "Re-throws the current exception",
      "Catches a new exception",
      "Terminates the program",
      "Prevents further exception handling"
    ]
  },
  {
    "q": "Which of the following exception safety levels guarantees that operations are either completed successfully or not at all, even in the case of an exception?",
    "o": [
      "Strong exception safety",
      "Basic exception safety",
      "No-throw guarantee",
      "Weak exception safety"
    ]
  },
  {
    "q": "Which of the following will result in a runtime error when an exception is thrown without a matching catch block?",
    "o": [
      "The program will call std::terminate()",
      "The program will continue to execute normally",
      "The exception will be silently ignored",
      "The program will print a default error message"
    ]
  },
  {
    "q": "Which of the following is the correct syntax for a `catch` block that handles exceptions of any type?",
    "o": [
      "catch (...) { }",
      "catch (std::exception e) { }",
      "catch { }",
      "catch (int e) { }"
    ]
  },
  {
    "q": "What is the purpose of a custom exception class in C++?",
    "o": [
      "To define a specific type of exception for more granular error handling",
      "To avoid the use of standard exceptions",
      "To throw all exceptions to the operating system",
      "To replace the `throw` and `catch` mechanisms"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        throw 5.5;\n    } catch (double d) {\n        cout << \"Caught double: \" << d;\n    }\n    return 0;\n}",
    "o": [
      "Caught double: 5.5",
      "Caught: 5.5",
      "Caught exception",
      "Unhandled exception"
    ]
  },
  {
    "q": "Which of the following exception types is thrown when a division by zero occurs in C++?",
    "o": [
      "std::runtime_error",
      "std::overflow_error",
      "std::invalid_argument",
      "std::logic_error"
    ]
  },
  {
    "q": "Which of the following would be an appropriate catch block for catching a `std::out_of_range` exception?",
    "o": [
      "catch (std::out_of_range& e) { cout << e.what(); }",
      "catch (std::exception& e) { cout << e.what(); }",
      "catch (int e) { cout << e; }",
      "catch (...) { cout << \"Unknown error\"; }"
    ]
  },
  {
    "q": "Which of the following statements is true about exception safety in C++?",
    "o": [
      "Exception safety ensures that if an exception is thrown, the program state remains valid",
      "Exception safety is not necessary if exceptions are not thrown",
      "Exception safety guarantees that all exceptions are caught",
      "Exception safety only applies to resource management code"
    ]
  },
  {
    "q": "What will happen if an exception is thrown in the destructor of an object in C++?",
    "o": [
      "The program will terminate unless the exception is caught",
      "The exception will be ignored",
      "The destructor will execute without exception handling",
      "The exception will cause the program to continue executing normally"
    ]
  },
  {
    "q": "Which of the following is a valid way to create a custom exception class in C++ that inherits from `std::exception`?",
    "o": [
      "class MyException : public std::exception { public: const char* what() const noexcept override { return \"My custom exception\"; } }",
      "class MyException : std::exception { public: void what() { return \"My custom exception\"; } }",
      "class MyException : public std::exception { public: std::string what() { return \"My custom exception\"; } }",
      "class MyException { public: const char* what() const noexcept { return \"My custom exception\"; } }"
    ]
  },
  {
    "q": "What does the `throw` keyword do in C++?",
    "o": [
      "Throws an exception from a function",
      "Catches an exception thrown by another function",
      "Exits the program",
      "Ends the current function"
    ]
  },
  {
    "q": "What is the behavior when an exception is thrown from a destructor in C++?",
    "o": [
      "The program will terminate unless the exception is caught",
      "The exception will be ignored and the destructor will continue",
      "The exception will be automatically caught by the compiler",
      "The program will enter an infinite loop"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        throw 3.14;\n    } catch (double d) {\n        cout << \"Caught double: \" << d;\n    }\n    return 0;\n}",
    "o": [
      "Caught double: 3.14",
      "Caught exception",
      "Caught: 3.14",
      "Unhandled exception"
    ]
  },
  {
    "q": "Which of the following exception classes is used to indicate a failure to allocate memory in C++?",
    "o": [
      "std::bad_alloc",
      "std::out_of_range",
      "std::invalid_argument",
      "std::runtime_error"
    ]
  },
  {
    "q": "Which of the following is true about `throw` in C++ exception handling?",
    "o": [
      "It is used to throw an exception from a function or block",
      "It is used to catch an exception",
      "It is used to declare an exception type in a function",
      "It is used to define a custom exception"
    ]
  },
  {
    "q": "Which of the following will not cause an exception to be thrown?",
    "o": [
      "Throwing a value that is not caught by a catch block",
      "Throwing a pointer to a non-primitive type",
      "Accessing an out-of-bounds array element",
      "Using an invalid memory reference"
    ]
  },
  {
    "q": "What is the purpose of the `noexcept` keyword in C++?",
    "o": [
      "Indicates that a function does not throw exceptions",
      "Marks a function that may throw exceptions",
      "Declares an exception to be thrown by a function",
      "Catches any thrown exception"
    ]
  },
  {
    "q": "Which of the following exception types can be used to represent an invalid argument in C++?",
    "o": [
      "std::invalid_argument",
      "std::out_of_range",
      "std::bad_alloc",
      "std::runtime_error"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        throw 'X';\n    } catch (char c) {\n        cout << \"Caught char: \" << c;\n    }\n    return 0;\n}",
    "o": [
      "Caught char: X",
      "Caught: X",
      "Caught exception",
      "Unhandled exception"
    ]
  },
  {
    "q": "Which of the following is a correct syntax for a `catch` block in C++ to catch an exception of type `std::out_of_range`?",
    "o": [
      "catch (std::out_of_range& e) { cout << e.what(); }",
      "catch (std::out_of_range e) { cout << e.what(); }",
      "catch (out_of_range& e) { cout << e.what(); }",
      "catch (std::exception e) { cout << e.what(); }"
    ]
  },
  {
    "q": "Which of the following is the safest way to handle multiple types of exceptions in a single try block?",
    "o": [
      "Using multiple catch blocks to handle different exception types",
      "Using a single catch block with `catch(...)`",
      "Catching all exceptions in a single block",
      "Catching only `std::exception`"
    ]
  },
  {
    "q": "What happens if an exception is thrown in a constructor in C++ and not caught?",
    "o": [
      "The object is not created, and the constructor will not complete",
      "The exception is ignored, and the object is created",
      "The program continues execution as if nothing happened",
      "The exception is automatically caught by the compiler"
    ]
  },
  {
    "q": "Which of the following is a valid syntax for throwing an exception in C++?",
    "o": [
      "throw 42;",
      "throw (42);",
      "throw: 42;",
      "throw new 42;"
    ]
  },
  {
    "q": "Which of the following standard exceptions is thrown when an out-of-bounds index is accessed in a container?",
    "o": [
      "std::out_of_range",
      "std::logic_error",
      "std::runtime_error",
      "std::invalid_argument"
    ]
  },
  {
    "q": "What will happen if a `catch` block does not match the type of exception thrown?",
    "o": [
      "The program will terminate or call `std::terminate()`",
      "The `catch` block will execute regardless of the exception type",
      "The `catch` block will ignore the exception",
      "The program will enter a recovery state"
    ]
  },
  {
    "q": "Which of the following C++ exceptions is thrown when a function call is passed an invalid argument?",
    "o": [
      "std::invalid_argument",
      "std::out_of_range",
      "std::runtime_error",
      "std::logic_error"
    ]
  },
  {
    "q": "What will happen if an exception is thrown inside a `catch` block?",
    "o": [
      "The new exception will be caught by the next outer `catch` block, or std::terminate() will be called",
      "The exception will be ignored by the program",
      "The program will halt immediately after the `catch` block ends",
      "The program will enter an infinite loop"
    ]
  },
  {
    "q": "What is the primary advantage of using custom exception classes in C++?",
    "o": [
      "They allow more specific and granular error handling for different situations",
      "They are required for exception handling in C++",
      "They make exception handling faster",
      "They allow the program to continue even after a critical error"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        throw std::out_of_range(\"Out of range!\");\n    } catch (std::out_of_range& e) {\n        cout << \"Exception caught: \" << e.what();\n    }\n    return 0;\n}",
    "o": [
      "Exception caught: Out of range!",
      "Caught exception",
      "Out of range!",
      "Unhandled exception"
    ]
  },
  {
    "q": "Which of the following is the correct syntax for handling a division by zero exception in C++?",
    "o": [
      "catch (std::exception& e) { cout << \"Division by zero error\"; }",
      "catch (std::overflow_error& e) { cout << e.what(); }",
      "catch (std::bad_arithmetic& e) { cout << \"Cannot divide by zero!\"; }",
      "catch (std::runtime_error& e) { cout << e.what(); }"
    ]
  },
  {
    "q": "Which of the following is a feature of exception safety in C++?",
    "o": [
      "Exception safety ensures that no resource leaks occur when exceptions are thrown",
      "It guarantees all exceptions are caught and handled",
      "Exception safety ensures that exceptions never happen",
      "It ensures the program stops when an exception is thrown"
    ]
  },
  {
    "q": "What will happen if an exception is thrown in the destructor of a C++ object during stack unwinding?",
    "o": [
      "The program will terminate and call `std::terminate()`",
      "The exception will be caught by the destructor's `catch` block",
      "The program will continue as normal, and the exception will be ignored",
      "The object will not be properly destroyed"
    ]
  },
  {
    "q": "Which of the following is the correct way to define a custom exception class in C++?",
    "o": [
      "class MyException : public std::exception { public: const char* what() const noexcept { return \"My custom exception\"; } };",
      "class MyException { public: void what() { return \"My custom exception\"; } };",
      "class MyException : public std::exception { public: string what() { return \"My custom exception\"; } };",
      "class MyException : public std::exception { public: char* what() { return \"My custom exception\"; } };"
    ]
  },
  {
    "q": "What is the correct use of `std::terminate()` in exception handling in C++?",
    "o": [
      "It is called when an exception is thrown and not caught",
      "It terminates the program without exception handling",
      "It ensures that all exceptions are caught by the program",
      "It pauses the program execution for debugging"
    ]
  },
  {
    "q": "What happens if a function throws an exception and does not have a corresponding `catch` block?",
    "o": [
      "The exception is propagated to the caller, and if uncaught, the program will terminate",
      "The program will continue executing normally",
      "The exception is automatically caught by the compiler",
      "The exception is logged and ignored by the runtime"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nint main() {\n    try {\n        throw std::runtime_error(\"Runtime error occurred\");\n    } catch (const std::exception& e) {\n        cout << e.what();\n    }\n    return 0;\n}",
    "o": [
      "Runtime error occurred",
      "Caught exception",
      "std::exception",
      "Unhandled exception"
    ]
  },
  {
    "q": "Which of the following standard exceptions is used when an invalid index is used to access an array or container in C++?",
    "o": [
      "std::out_of_range",
      "std::invalid_argument",
      "std::overflow_error",
      "std::underflow_error"
    ]
  },
  {
    "q": "What is the correct syntax for catching all exceptions in C++?",
    "o": [
      "catch (...) { }",
      "catch (std::exception& e) { }",
      "catch (std::any& e) { }",
      "catch (void* e) { }"
    ]
  },
  {
    "q": "Which of the following is true about the `throw` keyword in C++?",
    "o": [
      "It is used to throw an exception object",
      "It is used to define the exceptions that a function may throw",
      "It terminates the program when called",
      "It is used to catch exceptions"
    ]
  },
  {
    "q": "Which of the following is an example of a situation where exception safety should be considered in C++?",
    "o": [
      "When dynamically allocating memory in a function",
      "When performing input/output operations in a program",
      "When declaring variables inside a `try` block",
      "When using the `throw` keyword in a function"
    ]
  },
  {
    "q": "What is the behavior of the following code when a `std::bad_alloc` exception is thrown?",
    "c": "#include <iostream>\n#include <new>\nusing namespace std;\n\nint main() {\n    try {\n        throw std::bad_alloc();\n    } catch (const std::bad_alloc& e) {\n        cout << \"Memory allocation failed!\";\n    }\n    return 0;\n}",
    "o": [
      "Memory allocation failed!",
      "Caught exception: bad_alloc",
      "Out of memory",
      "Unhandled exception"
    ]
  },
  {
    "q": "What is the result of the following code when an exception is thrown inside the `finally` block?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        throw 42;\n    } catch (int e) {\n        cout << \"Caught exception: \" << e;\n    } finally {\n        cout << \"Finally block executed\";\n        throw 100; // New exception\n    }\n    return 0;\n}",
    "o": [
      "The program will terminate due to the unhandled exception from the finally block",
      "The exception from the `catch` block will be rethrown",
      "The finally block will execute without errors",
      "The program will continue to execute after the finally block"
    ]
  },
  {
    "q": "Which of the following standard exceptions is used when a resource (like memory) is unavailable?",
    "o": [
      "std::bad_alloc",
      "std::out_of_range",
      "std::invalid_argument",
      "std::overflow_error"
    ]
  },
  {
    "q": "Which of the following statements about the `throw` keyword in C++ is true?",
    "o": [
      "It throws an exception object",
      "It is used to handle exceptions in a `catch` block",
      "It terminates the program immediately",
      "It automatically catches thrown exceptions"
    ]
  },
  {
    "q": "What happens when an exception is thrown from within a `catch` block in C++?",
    "o": [
      "The program terminates, and `std::terminate()` is called",
      "The outer `catch` block handles the new exception",
      "The exception is ignored, and the program continues execution",
      "The program enters an infinite loop"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nint main() {\n    try {\n        throw std::logic_error(\"Logic error\");\n    } catch (const std::logic_error& e) {\n        cout << e.what();\n    } catch (...) {\n        cout << \"Unknown exception\";\n    }\n    return 0;\n}",
    "o": [
      "Logic error",
      "Unknown exception",
      "std::logic_error",
      "Unhandled exception"
    ]
  },
  {
    "q": "Which of the following correctly handles multiple exceptions in a `try` block in C++?",
    "o": [
      "Multiple `catch` blocks can be used to handle different exceptions",
      "Only one `catch` block is allowed in a `try` block",
      "Exceptions are handled by the `throw` keyword inside `try`",
      "All exceptions must be caught by a single `catch` block"
    ]
  },
  {
    "q": "What is the role of `noexcept` in exception handling in C++?",
    "o": [
      "It specifies that a function does not throw any exceptions",
      "It specifies that a function will throw exceptions of a specific type",
      "It allows a function to catch exceptions automatically",
      "It prevents a function from being called inside a `try` block"
    ]
  },
  {
    "q": "Which of the following is true regarding exception safety in C++?",
    "o": [
      "Exception safety ensures no resource leaks occur during exception handling",
      "It guarantees that exceptions are always handled by the program",
      "It ensures that exceptions are never thrown from functions",
      "It guarantees that all exceptions will be caught by the runtime"
    ]
  },
  {
    "q": "What is the correct syntax for throwing a custom exception object in C++?",
    "o": [
      "throw MyCustomException(\"Error message\");",
      "throw new MyCustomException(\"Error message\");",
      "throw MyCustomException; // without parameters",
      "throw 'MyCustomException';"
    ]
  },
  {
    "q": "What happens if no `catch` block matches the thrown exception in C++?",
    "o": [
      "The program calls `std::terminate()` and stops execution",
      "The exception is automatically handled by the compiler",
      "The program continues executing normally without catching the exception",
      "The program retries the exception handling mechanism"
    ]
  },
  {
    "q": "What is the purpose of the `std::exception` class in C++?",
    "o": [
      "It is the base class for all standard exceptions",
      "It defines how exceptions should be caught in C++",
      "It is used to define custom exceptions in the program",
      "It stores the error code of an exception"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nint main() {\n    try {\n        throw std::out_of_range(\"Out of range exception\");\n    } catch (const std::out_of_range& e) {\n        cout << e.what();\n    }\n    return 0;\n}",
    "o": [
      "Out of range exception",
      "Caught exception: std::out_of_range",
      "Unhandled exception",
      "Out of range"
    ]
  },
  {
    "q": "Which of the following is true about the `throw` keyword in C++?",
    "o": [
      "It is used to throw an exception in C++",
      "It is used to catch exceptions",
      "It defines custom exception classes",
      "It allows functions to return exceptions"
    ]
  },
  {
    "q": "What will happen if an exception is thrown in a `try` block and no corresponding `catch` block is found?",
    "o": [
      "The program will call `std::terminate()` and stop execution",
      "The program will continue as normal without catching the exception",
      "The exception will be caught by the compiler",
      "The program will attempt to catch the exception in the next function"
    ]
  },
  {
    "q": "Which exception class should be used when a function cannot find the required resource (e.g., a file or a database record) in C++?",
    "o": [
      "std::runtime_error",
      "std::out_of_range",
      "std::invalid_argument",
      "std::bad_alloc"
    ]
  },
  {
    "q": "Which of the following correctly handles exceptions in C++?",
    "o": [
      "Using multiple `catch` blocks to handle different types of exceptions",
      "Using a single `catch` block for all exceptions",
      "Throwing exceptions without catching them",
      "Catching exceptions inside a `finally` block"
    ]
  },
  {
    "q": "What is the primary purpose of the `noexcept` keyword in C++?",
    "o": [
      "To indicate that a function does not throw any exceptions",
      "To define which exceptions a function may throw",
      "To catch all exceptions within a function",
      "To automatically handle exceptions inside a function"
    ]
  },
  {
    "q": "What happens when an exception is thrown in a destructor during stack unwinding?",
    "o": [
      "The program will terminate immediately by calling `std::terminate()`",
      "The exception will be ignored, and the object will still be destructed",
      "The program will continue executing, but the object won't be destructed",
      "The destructor will be retried"
    ]
  },
  {
    "q": "What is the result of catching exceptions using `catch (...)`?",
    "o": [
      "It catches all types of exceptions regardless of their type",
      "It only catches `std::exception` type exceptions",
      "It catches runtime exceptions but not logic errors",
      "It ignores the exception and does not handle it"
    ]
  },
  {
    "q": "Which of the following is a valid custom exception class in C++?",
    "o": [
      "class MyException : public std::exception { public: const char* what() const noexcept { return \"My custom exception\"; } };",
      "class MyException { public: string what() { return \"My custom exception\"; } };",
      "class MyException : public exception { public: string what() { return \"My custom exception\"; } };",
      "class MyException : std::exception { public: string what() { return \"My custom exception\"; } };"
    ]
  },
  {
    "q": "Which of the following standard exception classes is used to represent logical errors in C++?",
    "o": [
      "std::logic_error",
      "std::runtime_error",
      "std::out_of_range",
      "std::invalid_argument"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nint main() {\n    try {\n        throw std::invalid_argument(\"Invalid argument exception\");\n    } catch (const std::invalid_argument& e) {\n        cout << e.what();\n    }\n    return 0;\n}",
    "o": [
      "Invalid argument exception",
      "Caught exception: invalid_argument",
      "std::invalid_argument",
      "Unhandled exception"
    ]
  },
  {
    "q": "What is the outcome of the following code when an exception is thrown in a `try` block inside a function, and the function does not have a `catch` block?",
    "c": "#include <iostream>\nusing namespace std;\n\nvoid exampleFunction() {\n    throw 100;\n}\n\nint main() {\n    try {\n        exampleFunction();\n    } catch (...) {\n        cout << \"Caught exception!\";\n    }\n    return 0;\n}",
    "o": [
      "The exception will be caught by the `catch` block in `main()`",
      "The exception will not be caught, and the program will terminate",
      "The exception will be caught by a new `catch` block inside `exampleFunction()`",
      "The exception will be ignored and the program will continue"
    ]
  },
  {
    "q": "Which of the following is used to catch exceptions thrown by functions that do not specify the types of exceptions they might throw?",
    "o": [
      "catch(...)",
      "catch(std::exception& e)",
      "catch(std::bad_alloc& e)",
      "catch(int e)"
    ]
  },
  {
    "q": "What is the purpose of the `std::exception` base class in exception handling?",
    "o": [
      "It provides a base for all standard C++ exceptions",
      "It is used to handle custom exceptions",
      "It allows exceptions to be ignored by the program",
      "It stores the error message of the exception"
    ]
  },
  {
    "q": "Which of the following statements about exception safety in C++ is true?",
    "o": [
      "Exception safety ensures that no resources (like memory) are leaked when an exception is thrown",
      "It ensures that exceptions can only be caught by `catch` blocks",
      "It allows exceptions to be thrown from destructors only",
      "It requires that all exceptions are caught and handled immediately"
    ]
  },
  {
    "q": "What happens if an exception is thrown in a constructor but the exception is not caught within that constructor?",
    "o": [
      "The constructor will terminate and the program will move to the nearest `catch` block",
      "The constructor will retry automatically until successful",
      "The exception will be ignored and the object will still be constructed",
      "The constructor will return a null pointer"
    ]
  },
  {
    "q": "Which of the following standard exceptions is thrown when a function receives an argument with an invalid value?",
    "o": [
      "std::invalid_argument",
      "std::out_of_range",
      "std::length_error",
      "std::overflow_error"
    ]
  },
  {
    "q": "What is the correct way to define a custom exception class that inherits from `std::exception`?",
    "o": [
      "class MyException : public std::exception { public: const char* what() const noexcept override { return \"My custom exception\"; } };",
      "class MyException : std::exception { public: const char* what() const { return \"My custom exception\"; } };",
      "class MyException : public exception { public: string what() { return \"My custom exception\"; } };",
      "class MyException { public: const char* what() const noexcept { return \"My custom exception\"; } };"
    ]
  },
  {
    "q": "What happens when an exception is thrown in a `catch` block itself?",
    "o": [
      "The program will call `std::terminate()` and terminate the program",
      "The thrown exception will be ignored and execution will continue normally",
      "The outer `catch` block will handle the exception",
      "The program will enter into a loop and keep throwing the exception"
    ]
  },
  {
    "q": "Which of the following statements is correct regarding exception propagation in C++?",
    "o": [
      "When an exception is thrown, it propagates up the call stack until it is caught by a `catch` block",
      "Exceptions are automatically caught by the nearest `try` block, even if it is outside the current function",
      "An exception is caught by the first `catch` block it encounters, even if the `catch` block is not a match",
      "Once an exception is thrown, it cannot be caught again by the same `catch` block"
    ]
  },
  {
    "q": "What does `std::bad_alloc` indicate in C++ exception handling?",
    "o": [
      "It indicates a failure to allocate memory",
      "It indicates a problem with an invalid argument passed to a function",
      "It indicates that a runtime error has occurred",
      "It indicates that a file could not be opened"
    ]
  },
  {
    "q": "What is the role of the `throw` keyword in C++ exception handling?",
    "o": [
      "It signals the occurrence of an exceptional condition",
      "It catches an exception thrown by a function",
      "It defines a block of code that handles errors",
      "It logs the error to the console"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        throw runtime_error(\"Error occurred\");\n    } catch (const exception& e) {\n        cout << e.what();\n    }\n    return 0;\n}",
    "o": [
      "Error occurred",
      "exception",
      "runtime_error",
      "Caught an exception"
    ]
  },
  {
    "q": "Which standard C++ exception is specifically thrown when accessing an invalid index in a container?",
    "o": [
      "std::out_of_range",
      "std::invalid_argument",
      "std::logic_error",
      "std::length_error"
    ]
  },
  {
    "q": "Which of the following ensures that resources are not leaked even when exceptions are thrown?",
    "o": [
      "RAII (Resource Acquisition Is Initialization)",
      "try-catch-finally structure",
      "Using global variables",
      "Using inline functions"
    ]
  },
  {
    "q": "Which of the following statements about `try` and `catch` blocks is correct?",
    "o": [
      "A `catch` block must immediately follow a `try` block",
      "A `try` block can be used without a `catch` block",
      "A `try` block can only handle `std::exception` types",
      "Multiple `try` blocks can be nested without `catch`"
    ]
  },
  {
    "q": "How do you throw a custom exception in C++?",
    "o": [
      "throw MyCustomException();",
      "MyCustomException.throw();",
      "raise MyCustomException;",
      "error(MyCustomException)"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass MyException {};\n\nint main() {\n    try {\n        throw MyException();\n    } catch (MyException&) {\n        cout << \"Caught MyException\";\n    }\n    return 0;\n}",
    "o": [
      "Caught MyException",
      "Error",
      "Unhandled exception",
      "Segmentation fault"
    ]
  },
  {
    "q": "What does it mean for a function to be 'exception safe'?",
    "o": [
      "It guarantees consistent program state even if an exception occurs",
      "It prevents exceptions from being thrown",
      "It must use only standard exceptions",
      "It logs all exceptions to a file"
    ]
  },
  {
    "q": "Which keyword is used to define a custom exception class in C++?",
    "o": [
      "class",
      "exception",
      "define",
      "throwable"
    ]
  },
  {
    "q": "What happens if no `catch` block matches the thrown exception?",
    "o": [
      "The program calls `std::terminate()` and exits",
      "The program continues execution normally",
      "The compiler ignores the throw statement",
      "The exception is ignored silently"
    ]
  },
  {
    "q": "Which of the following types can be used in a `throw` statement?",
    "o": [
      "Any data type, including user-defined types",
      "Only int or string",
      "Only standard exceptions",
      "Only class objects"
    ]
  },
  {
    "q": "What is the correct way to catch all types of exceptions in C++?",
    "o": [
      "catch (...)",
      "catch (any)",
      "catch (exception)",
      "catch (*)"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        throw 42;\n    } catch (int x) {\n        cout << \"Caught: \" << x;\n    }\n    return 0;\n}",
    "o": [
      "Caught: 42",
      "Caught: int",
      "Caught: exception",
      "No output"
    ]
  },
  {
    "q": "Which of the following standard exceptions is derived from `std::logic_error`?",
    "o": [
      "std::invalid_argument",
      "std::runtime_error",
      "std::bad_alloc",
      "std::bad_cast"
    ]
  },
  {
    "q": "In C++, what is the base class for all standard exceptions?",
    "o": [
      "std::exception",
      "std::runtime_error",
      "std::logic_error",
      "std::error_code"
    ]
  },
  {
    "q": "Which statement about exception safety is TRUE?",
    "o": [
      "A strong exception guarantee means rollback to the original state if failure occurs",
      "Basic guarantee ensures no exception is thrown",
      "Nothrow guarantee is required by all STL containers",
      "Weak exception guarantee is better than strong"
    ]
  },
  {
    "q": "What will the following program output?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nint main() {\n    try {\n        throw logic_error(\"Logic error occurred\");\n    } catch (const logic_error& e) {\n        cout << e.what();\n    }\n    return 0;\n}",
    "o": [
      "Logic error occurred",
      "runtime_error",
      "Exception caught",
      "Caught logic"
    ]
  },
  {
    "q": "Which of the following is NOT a good practice when writing exception-safe code?",
    "o": [
      "Ignoring exceptions inside catch blocks",
      "Using RAII for resource management",
      "Ensuring destructors do not throw",
      "Keeping exception-handling code minimal"
    ]
  },
  {
    "q": "Why is using raw pointers risky in exception-handling scenarios?",
    "o": [
      "They may lead to memory leaks if not deleted before an exception is thrown",
      "They make the code more efficient",
      "They prevent exceptions from propagating",
      "They automatically clean up memory"
    ]
  },
  {
    "q": "What happens when an exception is thrown in a constructor?",
    "o": [
      "The destructor is not called, but already constructed members are destroyed",
      "The object is constructed but marked invalid",
      "The destructor is always called",
      "The constructor silently fails"
    ]
  },
  {
    "q": "Which exception is thrown when a dynamic cast fails with a reference type?",
    "o": [
      "std::bad_cast",
      "std::bad_alloc",
      "std::invalid_argument",
      "std::bad_typeid"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "#include <iostream>\nusing namespace std;\n\nvoid test() {\n    throw string(\"Error\");\n}\n\nint main() {\n    try {\n        test();\n    } catch (string &e) {\n        cout << e;\n    }\n    return 0;\n}",
    "o": [
      "Error",
      "string",
      "Caught",
      "Exception"
    ]
  },
  {
    "q": "How is exception safety achieved in C++ STL containers?",
    "o": [
      "By providing strong exception guarantees during operations",
      "By avoiding all use of exceptions",
      "By throwing only primitive types",
      "By using only raw pointers"
    ]
  },
  {
    "q": "Which of the following best describes the basic exception safety guarantee?",
    "o": [
      "Operations may fail, but the program remains in a valid state",
      "The operation never throws an exception",
      "All resources are guaranteed to be released",
      "State is rolled back to the original"
    ]
  },
  {
    "q": "What is the correct way to define a custom exception class inheriting from std::exception?",
    "o": [
      "class MyException : public std::exception {}",
      "class MyException : exception {}",
      "exception MyException extends {}",
      "throw class MyException {}"
    ]
  },
  {
    "q": "What does `std::terminate()` do in C++?",
    "o": [
      "It ends the program when an exception is not caught",
      "It rethrows an exception",
      "It clears the exception state",
      "It logs the error and continues"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        int* arr = new int[100000000000];\n    } catch (bad_alloc &e) {\n        cout << \"Memory allocation failed\";\n    }\n    return 0;\n}",
    "o": [
      "Memory allocation failed",
      "Array index out of bounds",
      "Segmentation fault",
      "Error occurred"
    ]
  },
  {
    "q": "Which of the following is a characteristic of the `nothrow` exception safety level?",
    "o": [
      "Function guarantees not to throw exceptions",
      "Function may throw exceptions but maintains validity",
      "Function rolls back to original state on failure",
      "Function logs but ignores exceptions"
    ]
  },
  {
    "q": "Which C++ feature is most helpful in cleaning up resources when exceptions are thrown?",
    "o": [
      "Destructors",
      "Virtual functions",
      "Templates",
      "Macros"
    ]
  },
  {
    "q": "What is the type returned by the `what()` function in standard exceptions?",
    "o": [
      "const char*",
      "string",
      "char",
      "int"
    ]
  },
  {
    "q": "Which C++ keyword is used to rethrow an exception inside a catch block?",
    "o": [
      "throw;",
      "retry;",
      "resend;",
      "catchagain;"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nint main() {\n    try {\n        throw runtime_error(\"Runtime issue\");\n    } catch (exception& e) {\n        cout << e.what();\n    }\n}",
    "o": [
      "Runtime issue",
      "Exception",
      "Error",
      "Caught"
    ]
  },
  {
    "q": "Which of the following is a custom exception class?",
    "o": [
      "class MyError : public std::exception { public: const char* what() const noexcept override { return \"MyError\"; } };",
      "class MyError { public: string message; };",
      "throw new std::exception(\"MyError\");",
      "exception MyError();"
    ]
  },
  {
    "q": "Why should destructors in C++ never throw exceptions?",
    "o": [
      "Because throwing in a destructor during stack unwinding may call terminate()",
      "Because destructors cannot be virtual",
      "Because exceptions in destructors are ignored",
      "Because destructors are not part of exception handling"
    ]
  },
  {
    "q": "What is the purpose of `noexcept` in function declarations?",
    "o": [
      "To indicate the function does not throw exceptions",
      "To catch exceptions automatically",
      "To suppress all runtime errors",
      "To rethrow exceptions implicitly"
    ]
  },
  {
    "q": "Which of the following C++ features helps in writing exception-safe code?",
    "o": [
      "RAII (Resource Acquisition Is Initialization)",
      "Macros",
      "Preprocessor directives",
      "Goto statements"
    ]
  },
  {
    "q": "What kind of exception does this code generate?",
    "c": "#include <iostream>\n#include <typeinfo>\nusing namespace std;\n\nclass Base { virtual void func() {} };\n\nint main() {\n    Base* b = nullptr;\n    try {\n        typeid(*b);\n    } catch (bad_typeid& e) {\n        cout << e.what();\n    }\n}",
    "o": [
      "std::bad_typeid",
      "std::bad_cast",
      "std::runtime_error",
      "Segmentation fault"
    ]
  },
  {
    "q": "Which of the following best describes a strong exception guarantee?",
    "o": [
      "Operation either completes successfully or has no side effects",
      "Operation cannot throw any exception",
      "Operation will log errors only",
      "Operation completes but with partial success"
    ]
  },
  {
    "q": "Which of these exceptions is thrown when memory allocation using `new` fails?",
    "o": [
      "std::bad_alloc",
      "std::bad_cast",
      "std::runtime_error",
      "std::overflow_error"
    ]
  },
  {
    "q": "What does the following code demonstrate?",
    "c": "try {\n    // some code\n} catch (const std::exception& e) {\n    throw;\n}",
    "o": [
      "Rethrowing the caught exception",
      "Catching multiple exceptions",
      "Creating a custom exception",
      "Suppressing the exception"
    ]
  },
  {
    "q": "What happens if no catch block matches the thrown exception in C++?",
    "o": [
      "The program terminates by calling std::terminate()",
      "The exception is ignored",
      "It returns to the main function",
      "The compiler throws a warning"
    ]
  },
  {
    "q": "Which standard C++ exception is thrown for dynamic_cast failures with references?",
    "o": [
      "std::bad_cast",
      "std::invalid_argument",
      "std::bad_alloc",
      "std::domain_error"
    ]
  },
  {
    "q": "What is printed by the following code?",
    "c": "#include <iostream>\nusing namespace std;\nint main() {\n    try {\n        throw 10;\n    } catch (int e) {\n        cout << \"Caught: \" << e;\n    }\n}",
    "o": [
      "Caught: 10",
      "Caught: int",
      "Caught: e",
      "No output"
    ]
  },
  {
    "q": "How do you define an exception-safe class in C++?",
    "o": [
      "By ensuring constructors and destructors do not throw exceptions",
      "By avoiding all exceptions",
      "By using `exit()` instead of `throw`",
      "By catching only `std::exception` types"
    ]
  },
  {
    "q": "Which of the following is TRUE about exception specifications in modern C++?",
    "o": [
      "Dynamic exception specifications are deprecated",
      "You must always use `throw()` for every function",
      "Functions without exception specs cannot throw",
      "Only constructors can use `noexcept`"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\nint main() {\n    try {\n        throw logic_error(\"Logic error occurred\");\n    } catch (const logic_error& e) {\n        cout << e.what();\n    }\n}",
    "o": [
      "Logic error occurred",
      "Exception caught",
      "Runtime error",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is an example of exception propagation?",
    "o": [
      "An exception thrown in one function is caught in the calling function",
      "An exception is caught and ignored",
      "An exception is logged and program exits",
      "A function throws but also catches internally"
    ]
  },
  {
    "q": "How can a custom exception provide more context?",
    "o": [
      "By adding extra members to the custom class",
      "By using `throw` without a message",
      "By inheriting from `int`",
      "By overriding `main()`"
    ]
  },
  {
    "q": "What is the correct syntax to catch all exceptions?",
    "o": [
      "catch (...)",
      "catch (any)",
      "catch (exception)",
      "catch (all)"
    ]
  },
  {
    "q": "Which of the following standard exceptions is best suited for an invalid function argument?",
    "o": [
      "std::invalid_argument",
      "std::range_error",
      "std::underflow_error",
      "std::bad_typeid"
    ]
  },
  {
    "q": "What type of value can be thrown using the `throw` keyword in C++?",
    "o": [
      "Any data type including user-defined types",
      "Only integers",
      "Only objects of std::exception",
      "Only strings"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "#include <iostream>\nusing namespace std;\nvoid test() {\n    throw string(\"Error occurred\");\n}\nint main() {\n    try {\n        test();\n    } catch (string &s) {\n        cout << s;\n    }\n}",
    "o": [
      "Error occurred",
      "Compilation error",
      "Runtime error",
      "Nothing"
    ]
  },
  {
    "q": "Which C++ standard exception is typically used for out-of-bounds array access?",
    "o": [
      "std::out_of_range",
      "std::invalid_argument",
      "std::logic_error",
      "std::overflow_error"
    ]
  },
  {
    "q": "Why should destructors not throw exceptions in C++?",
    "o": [
      "Because if an exception is already active, another throw will call terminate()",
      "Because destructors cannot use try-catch blocks",
      "Because destructors are private",
      "Because exceptions in destructors are always ignored"
    ]
  },
  {
    "q": "What is printed by this code?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\nint main() {\n    try {\n        throw runtime_error(\"Runtime!\");\n    } catch (exception &e) {\n        cout << e.what();\n    }\n}",
    "o": [
      "Runtime!",
      "exception",
      "runtime_error",
      "No output"
    ]
  },
  {
    "q": "What is the benefit of using `noexcept` in a function declaration?",
    "o": [
      "It tells the compiler the function will not throw exceptions",
      "It enables runtime exception detection",
      "It disables error reporting",
      "It forces the function to throw exceptions"
    ]
  },
  {
    "q": "Which of the following can be considered an exception-safe technique?",
    "o": [
      "Using RAII (Resource Acquisition Is Initialization)",
      "Using raw pointers for memory",
      "Calling `exit()` instead of `throw`",
      "Avoiding try-catch blocks altogether"
    ]
  },
  {
    "q": "What is wrong with this code?",
    "c": "#include <iostream>\nusing namespace std;\nint main() {\n    try {\n        throw;\n    } catch (...) {\n        cout << \"Caught\";\n    }\n}",
    "o": [
      "Throw without an operand is only valid inside a catch block",
      "Catch block cannot have ellipsis",
      "You must catch specific types",
      "Nothing is wrong"
    ]
  },
  {
    "q": "What is the advantage of creating custom exception classes?",
    "o": [
      "To provide detailed and type-safe error reporting",
      "To avoid using try-catch blocks",
      "To replace all standard exceptions",
      "To enable automatic recovery"
    ]
  },
  {
    "q": "How do you rethrow an exception from a catch block?",
    "o": [
      "Using `throw;` without any operand",
      "Using `throw e;`",
      "Using `return;`",
      "Using `catch again;`"
    ]
  },
  {
    "q": "Which block is used to catch exceptions in C++?",
    "o": [
      "catch",
      "handle",
      "except",
      "receive"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "#include <iostream>\nusing namespace std;\nint main() {\n    try {\n        throw 20;\n    } catch (int e) {\n        cout << \"Exception: \" << e;\n    }\n    return 0;\n}",
    "o": [
      "Exception: 20",
      "20",
      "Exception caught",
      "Runtime error"
    ]
  },
  {
    "q": "What base class do all standard exceptions in C++ inherit from?",
    "o": [
      "std::exception",
      "std::runtime_error",
      "std::logic_error",
      "std::bad_exception"
    ]
  },
  {
    "q": "Which standard exception would you use for invalid arguments passed to a function?",
    "o": [
      "std::invalid_argument",
      "std::out_of_range",
      "std::overflow_error",
      "std::bad_cast"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\nint main() {\n    try {\n        throw out_of_range(\"Out of bounds\");\n    } catch (const out_of_range& e) {\n        cout << e.what();\n    }\n    return 0;\n}",
    "o": [
      "Out of bounds",
      "out_of_range",
      "Caught exception",
      "Runtime error"
    ]
  },
  {
    "q": "Which of the following is NOT a standard C++ exception class?",
    "o": [
      "std::file_not_found",
      "std::logic_error",
      "std::runtime_error",
      "std::bad_alloc"
    ]
  },
  {
    "q": "Why should resources be wrapped using RAII in exception-safe code?",
    "o": [
      "To ensure automatic cleanup even when exceptions are thrown",
      "To disable exception throwing",
      "To improve performance",
      "To avoid using destructors"
    ]
  },
  {
    "q": "What is the output of this program?",
    "c": "#include <iostream>\nusing namespace std;\nclass MyException {};\nint main() {\n    try {\n        throw MyException();\n    } catch (MyException&) {\n        cout << \"Custom exception caught\";\n    }\n}",
    "o": [
      "Custom exception caught",
      "Exception caught",
      "Compilation error",
      "No output"
    ]
  },
  {
    "q": "Which keyword is used to create a custom exception class in C++?",
    "o": [
      "class",
      "exception",
      "define",
      "custom"
    ]
  },
  {
    "q": "When does the `terminate()` function get called in C++ exception handling?",
    "o": [
      "When an exception is thrown but not caught",
      "When throw is used with a standard exception",
      "When exception is rethrown",
      "When catch block is used"
    ]
  },
  {
    "q": "Which C++ keyword is used to manually raise an exception?",
    "o": [
      "throw",
      "raise",
      "raise_exception",
      "signal"
    ]
  },
  {
    "q": "What is the output of this code snippet?",
    "c": "#include <iostream>\nusing namespace std;\nint main() {\n    try {\n        cout << \"Before throw\\n\";\n        throw \"Error occurred\";\n        cout << \"After throw\\n\";\n    } catch (const char* msg) {\n        cout << msg;\n    }\n    return 0;\n}",
    "o": [
      "Before throw\nError occurred",
      "Error occurred",
      "Before throw\nAfter throw\nError occurred",
      "After throw"
    ]
  },
  {
    "q": "Which standard exception should be thrown when a memory allocation fails?",
    "o": [
      "std::bad_alloc",
      "std::overflow_error",
      "std::length_error",
      "std::logic_error"
    ]
  },
  {
    "q": "Which of the following correctly defines a custom exception class in C++?",
    "o": [
      "class MyException : public std::exception { public: const char* what() const noexcept override { return \"My error\"; } };",
      "class MyException { void error(); };",
      "exception MyException : base { };",
      "class MyException : std::exception { public: char* what(); };"
    ]
  },
  {
    "q": "What type of exception safety ensures that no resources are leaked even if an exception occurs?",
    "o": [
      "Strong exception safety",
      "Basic exception safety",
      "No exception safety",
      "Partial exception safety"
    ]
  },
  {
    "q": "Which of these ensures the highest level of exception safety in C++?",
    "o": [
      "Guaranteeing rollback to the original state if an exception occurs",
      "Not throwing any exceptions",
      "Using multiple catch blocks",
      "Avoiding destructors"
    ]
  },
  {
    "q": "What happens if an exception is thrown but not caught?",
    "o": [
      "std::terminate() is called",
      "The code continues executing",
      "The program retries the block",
      "The exception is ignored"
    ]
  },
  {
    "q": "What is the purpose of the `what()` function in standard exceptions?",
    "o": [
      "Returns a description of the error",
      "Throws an exception",
      "Ends the program",
      "Logs the error to file"
    ]
  },
  {
    "q": "What is printed by this code?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\nint main() {\n    try {\n        throw logic_error(\"Logic failed\");\n    } catch (exception& e) {\n        cout << e.what();\n    }\n}",
    "o": [
      "Logic failed",
      "logic_error",
      "Caught exception",
      "Runtime error"
    ]
  },
  {
    "q": "Which exception is thrown when a container element access is out of bounds?",
    "o": [
      "std::out_of_range",
      "std::invalid_argument",
      "std::overflow_error",
      "std::range_error"
    ]
  },
  {
    "q": "Which of the following blocks must be used with a 'throw' to catch exceptions in C++?",
    "o": [
      "catch",
      "finally",
      "handle",
      "grab"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\nint main() {\n    try {\n        throw 20;\n    } catch (int e) {\n        cout << \"Caught: \" << e;\n    }\n    return 0;\n}",
    "o": [
      "Caught: 20",
      "Caught: e",
      "Caught an exception",
      "Error"
    ]
  },
  {
    "q": "Which header file must be included to use standard exceptions like std::runtime_error?",
    "o": [
      "<stdexcept>",
      "<exception>",
      "<iostream>",
      "<cstdlib>"
    ]
  },
  {
    "q": "Which of the following is a best practice when defining a custom exception class in C++?",
    "o": [
      "Inherit from std::exception and override what()",
      "Use a global variable to store the error",
      "Inherit from std::string",
      "Inherit from int and define toString()"
    ]
  },
  {
    "q": "What is the term for the ability to ensure resources are not leaked during exceptions?",
    "o": [
      "Exception safety",
      "Dynamic binding",
      "RAII",
      "Memory management"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\nvoid test() {\n    throw string(\"Test failed\");\n}\nint main() {\n    try {\n        test();\n    } catch (string& msg) {\n        cout << msg;\n    }\n}",
    "o": [
      "Test failed",
      "Exception",
      "String thrown",
      "Compilation error"
    ]
  },
  {
    "q": "Which standard exception is thrown by functions that receive invalid arguments?",
    "o": [
      "std::invalid_argument",
      "std::logic_error",
      "std::range_error",
      "std::bad_cast"
    ]
  },
  {
    "q": "Which of the following guarantees that an operation leaves program state unchanged if an exception occurs?",
    "o": [
      "Strong exception guarantee",
      "Basic exception guarantee",
      "No exception guarantee",
      "Total safety guarantee"
    ]
  },
  {
    "q": "What will happen if an exception is thrown inside a constructor and not caught?",
    "o": [
      "The constructor will not finish and the object won't be created",
      "The object is created with default values",
      "The exception is ignored",
      "The object is created and then deleted"
    ]
  },
  {
    "q": "Which is the correct way to catch all exceptions in C++?",
    "o": [
      "catch (...)",
      "catch AllException",
      "catch (*)",
      "catch (Exception)"
    ]
  },
  {
    "q": "What type of values can be thrown using the 'throw' keyword in C++?",
    "o": [
      "Any type",
      "Only integers",
      "Only objects derived from std::exception",
      "Only strings"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nint main() {\n    try {\n        throw runtime_error(\"Runtime error occurred\");\n    } catch (exception& e) {\n        cout << e.what();\n    }\n}",
    "o": [
      "Runtime error occurred",
      "Caught exception",
      "Unhandled exception",
      "Compilation error"
    ]
  },
  {
    "q": "Which exception is thrown when a dynamic cast fails with references?",
    "o": [
      "std::bad_cast",
      "std::bad_alloc",
      "std::invalid_argument",
      "std::overflow_error"
    ]
  },
  {
    "q": "Which statement best defines exception-safe code?",
    "o": [
      "Code that ensures proper resource management even if exceptions occur",
      "Code that avoids using exceptions",
      "Code that ignores runtime errors",
      "Code that throws multiple exceptions at once"
    ]
  },
  {
    "q": "What is the correct way to define a custom exception class?",
    "c": "#include <exception>\n#include <string>\nclass MyException : public std::exception {\n    std::string msg;\npublic:\n    MyException(const std::string& m) : msg(m) {}\n    const char* what() const noexcept override {\n        return msg.c_str();\n    }\n};",
    "o": [
      "Inherits from std::exception and overrides what()",
      "Uses a macro to define error",
      "Inherits from std::string",
      "Returns int instead of const char*"
    ]
  },
  {
    "q": "Which of the following represents the 'basic exception safety' guarantee?",
    "o": [
      "The program remains in a valid state if an exception occurs",
      "The operation is completely rolled back",
      "The program crashes but doesn't corrupt memory",
      "No resources are used at all"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\nint main() {\n    try {\n        int* arr = new int[1000000000000];\n    } catch (bad_alloc& e) {\n        cout << \"Allocation failed: \" << e.what();\n    }\n}",
    "o": [
      "Allocation failed: std::bad_alloc",
      "Segmentation fault",
      "Compilation error",
      "Program runs normally"
    ]
  },
  {
    "q": "Which of the following ensures that a function never throws an exception in C++11 or later?",
    "o": [
      "noexcept",
      "try {}",
      "static_cast",
      "safe_call"
    ]
  },
  {
    "q": "What happens if no catch block matches a thrown exception?",
    "o": [
      "The program calls std::terminate()",
      "The exception is ignored",
      "The program continues",
      "A warning is displayed"
    ]
  },
  {
    "q": "Which keyword is used to manually raise an exception in C++?",
    "o": [
      "throw",
      "raise",
      "catch",
      "except"
    ]
  },
  {
    "q": "What is the purpose of the catch(...) block in C++?",
    "o": [
      "To catch any type of exception",
      "To catch only standard exceptions",
      "To catch compile-time errors",
      "To catch integer exceptions only"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        throw 3.14;\n    } catch (int x) {\n        cout << \"Caught int\";\n    } catch (...) {\n        cout << \"Caught unknown exception\";\n    }\n    return 0;\n}",
    "o": [
      "Caught unknown exception",
      "Caught int",
      "Compilation error",
      "Program crashes"
    ]
  },
  {
    "q": "Which of the following is a standard C++ exception class?",
    "o": [
      "std::logic_error",
      "std::custom_exception",
      "std::program_exception",
      "std::runtime_fault"
    ]
  },
  {
    "q": "What is a major benefit of using RAII (Resource Acquisition Is Initialization) in exception handling?",
    "o": [
      "It ensures automatic resource release during exceptions",
      "It prevents the use of try-catch blocks",
      "It disables exception propagation",
      "It catches only memory-related exceptions"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nvoid test() {\n    throw logic_error(\"Logic Error Detected\");\n}\n\nint main() {\n    try {\n        test();\n    } catch (const exception& e) {\n        cout << e.what();\n    }\n    return 0;\n}",
    "o": [
      "Logic Error Detected",
      "Caught exception",
      "Program terminated",
      "Unhandled exception"
    ]
  },
  {
    "q": "What kind of exception is typically thrown when an invalid argument is passed to a function?",
    "o": [
      "std::invalid_argument",
      "std::bad_alloc",
      "std::out_of_range",
      "std::domain_error"
    ]
  },
  {
    "q": "Which of the following correctly defines a function that guarantees not to throw any exception in C++?",
    "o": [
      "void myFunc() noexcept;",
      "noexcept void myFunc();",
      "void noexcept myFunc();",
      "myFunc() noexcept void;"
    ]
  },
  {
    "q": "What is the result if an exception is thrown in a constructor and not caught?",
    "o": [
      "The destructor of already constructed objects is called",
      "The program continues to execute",
      "The memory leak occurs silently",
      "The compiler warns but continues"
    ]
  },
  {
    "q": "What is exception propagation in C++?",
    "o": [
      "It is the process of passing an exception to an outer catch block",
      "It is the re-throwing of exceptions only in constructors",
      "It means converting exceptions to warnings",
      "It refers to exceptions generated at compile time"
    ]
  },
  {
    "q": "Which of the following is a best practice for writing exception-safe code?",
    "o": [
      "Prefer stack-allocated resources and RAII",
      "Use global try-catch blocks for all functions",
      "Avoid exceptions entirely and use error codes",
      "Use 'catch (...)' in all catch blocks"
    ]
  },
  {
    "q": "Which block must always follow a try block in C++?",
    "o": [
      "catch",
      "finally",
      "return",
      "goto"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        throw string(\"Error\");\n    } catch (string s) {\n        cout << s;\n    }\n    return 0;\n}",
    "o": [
      "Error",
      "Caught Error",
      "Exception",
      "Program terminated"
    ]
  },
  {
    "q": "Which of the following keywords is used to raise an exception in C++?",
    "o": [
      "throw",
      "raise",
      "raiseException",
      "error"
    ]
  },
  {
    "q": "Which C++ standard exception is thrown when a container is accessed out of bounds?",
    "o": [
      "std::out_of_range",
      "std::length_error",
      "std::invalid_argument",
      "std::range_error"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nint main() {\n    try {\n        throw runtime_error(\"Runtime error\");\n    } catch (logic_error &e) {\n        cout << \"Logic error: \" << e.what();\n    } catch (exception &e) {\n        cout << \"Exception: \" << e.what();\n    }\n    return 0;\n}",
    "o": [
      "Exception: Runtime error",
      "Logic error: Runtime error",
      "Caught an exception",
      "Unhandled exception"
    ]
  },
  {
    "q": "Which of the following describes a custom exception class in C++?",
    "o": [
      "A user-defined class that inherits from std::exception",
      "A template class used for throwing",
      "A subclass of std::string",
      "A function used in catch block"
    ]
  },
  {
    "q": "What does 'exception safety' refer to in C++ programming?",
    "o": [
      "Writing code that behaves correctly if exceptions occur",
      "Avoiding all exceptions in code",
      "Catching exceptions silently",
      "Using only standard exceptions"
    ]
  },
  {
    "q": "Which of the following will create a noexcept function?",
    "o": [
      "void test() noexcept;",
      "noexcept void test();",
      "void noexcept test();",
      "test() void noexcept;"
    ]
  },
  {
    "q": "Which of the following is true about the `catch(...)` block?",
    "o": [
      "It can catch any type of exception",
      "It can catch only int and float types",
      "It must be the first catch block",
      "It replaces the try block"
    ]
  },
  {
    "q": "Why should exceptions not be thrown from destructors in C++?",
    "o": [
      "Because it can cause program termination during stack unwinding",
      "Because destructors do not support throw statements",
      "Because exceptions in destructors are ignored",
      "Because destructors cannot be virtual"
    ]
  },
  {
    "q": "Which of the following correctly handles multiple types of exceptions in C++?",
    "o": [
      "Using multiple catch blocks after a try block",
      "Using nested try blocks only",
      "Using one generic catch block only",
      "Using if-else inside a catch block"
    ]
  },
  {
    "q": "What will be the output of the following C++ code?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        int* arr = new int[1000000000];\n    } catch (bad_alloc &e) {\n        cout << \"Memory allocation failed: \" << e.what();\n    }\n    return 0;\n}",
    "o": [
      "Memory allocation failed: std::bad_alloc",
      "Segmentation fault",
      "Compilation error",
      "No output"
    ]
  },
  {
    "q": "What is the base class for all standard exceptions in C++?",
    "o": [
      "std::exception",
      "std::error",
      "std::throwable",
      "std::base_error"
    ]
  },
  {
    "q": "Which of the following is NOT a standard exception in C++?",
    "o": [
      "std::divide_by_zero",
      "std::overflow_error",
      "std::out_of_range",
      "std::invalid_argument"
    ]
  },
  {
    "q": "What is the correct syntax for creating a custom exception class in C++?",
    "o": [
      "class MyException : public std::exception { public: const char* what() const noexcept override { return \"Custom error\"; } };",
      "class MyException { public: void what() { return \"Custom error\"; } };",
      "class MyException inherits std::exception { public: string what() { return \"Custom error\"; } };",
      "class MyException extends std::exception { public: const char* what() { return \"Custom error\"; } };"
    ]
  },
  {
    "q": "Which of the following guarantees the strongest exception safety?",
    "o": [
      "Operations are completed successfully or have no effects",
      "The program compiles without any warning",
      "Exceptions are caught using catch(...)",
      "All functions are marked noexcept"
    ]
  },
  {
    "q": "What will be the result of this code?",
    "c": "#include <iostream>\nusing namespace std;\n\nvoid risky() {\n    throw 42;\n}\n\nint main() {\n    try {\n        risky();\n    } catch (int e) {\n        cout << \"Caught: \" << e;\n    }\n    return 0;\n}",
    "o": [
      "Caught: 42",
      "42",
      "Caught: risky",
      "Error: throw must be inside main"
    ]
  },
  {
    "q": "Which of the following ensures exception safety during object copy?",
    "o": [
      "Implementing the copy constructor with strong exception guarantee",
      "Avoiding the use of pointers in class members",
      "Overloading the assignment operator only",
      "Using default constructor with noexcept"
    ]
  },
  {
    "q": "Which of the following can be used to rethrow an exception in C++?",
    "o": [
      "throw;",
      "rethrow();",
      "throw e();",
      "retry();"
    ]
  },
  {
    "q": "In C++, what is the purpose of noexcept specifier?",
    "o": [
      "To indicate that a function does not throw exceptions",
      "To prevent catch blocks from being used",
      "To enable runtime type checks",
      "To suppress all runtime errors"
    ]
  },
  {
    "q": "What happens if an exception is thrown but not caught in a C++ program?",
    "o": [
      "The program terminates by calling std::terminate",
      "The program continues execution normally",
      "The compiler throws a warning",
      "The exception is ignored"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nint main() {\n    try {\n        throw runtime_error(\"Runtime error occurred\");\n    } catch (const exception& e) {\n        cout << e.what();\n    }\n    return 0;\n}",
    "o": [
      "Runtime error occurred",
      "Exception caught",
      "std::exception",
      "Program terminates"
    ]
  },
  {
    "q": "Which of the following is considered a standard exception in C++?",
    "o": [
      "std::out_of_range",
      "std::null_pointer",
      "std::file_error",
      "std::connection_lost"
    ]
  },
  {
    "q": "How do you specify a function that guarantees not to throw exceptions?",
    "o": [
      "Use the noexcept specifier",
      "Use the noreturn attribute",
      "Use the nothrow() keyword",
      "Use the const keyword"
    ]
  },
  {
    "q": "Which catch block can handle any type of exception?",
    "o": [
      "catch(...)",
      "catch(int)",
      "catch(std::exception)",
      "catch(char*)"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        throw 'x';\n    } catch (int e) {\n        cout << \"Caught int\";\n    } catch (...) {\n        cout << \"Caught unknown type\";\n    }\n    return 0;\n}",
    "o": [
      "Caught unknown type",
      "Caught int",
      "Compilation error",
      "Caught x"
    ]
  },
  {
    "q": "Which of the following statements is true about exception safety?",
    "o": [
      "Strong exception guarantee ensures no side-effects if an exception is thrown",
      "Basic exception guarantee ensures the program won't terminate",
      "No-throw guarantee means exceptions are allowed in destructors",
      "Exception safety is only needed in constructors"
    ]
  },
  {
    "q": "How can a custom exception class be made more informative?",
    "o": [
      "By overriding the what() method from std::exception",
      "By inheriting from std::error instead of std::exception",
      "By throwing strings instead",
      "By defining multiple constructors with throw specifier"
    ]
  },
  {
    "q": "What is the output of this C++ snippet?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass MyException {};\n\nint main() {\n    try {\n        throw MyException();\n    } catch (MyException&) {\n        cout << \"Custom exception caught\";\n    }\n    return 0;\n}",
    "o": [
      "Custom exception caught",
      "Compilation error",
      "Program terminates",
      "No output"
    ]
  },
  {
    "q": "Why should exceptions be caught by reference in C++?",
    "o": [
      "To avoid object slicing and ensure polymorphic behavior",
      "To prevent exceptions from being caught",
      "To improve memory allocation",
      "To throw the same exception again"
    ]
  },
  {
    "q": "Which of the following correctly throws an exception in C++?",
    "o": [
      "throw std::runtime_error(\"Something went wrong\");",
      "raise std::runtime_error(\"Something went wrong\");",
      "exception(\"Something went wrong\");",
      "catch std::runtime_error(\"Something went wrong\");"
    ]
  },
  {
    "q": "What will the following C++ code print?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        int x = 10;\n        if (x == 10) throw 100;\n        cout << \"No error\";\n    } catch (int e) {\n        cout << \"Caught exception: \" << e;\n    }\n    return 0;\n}",
    "o": [
      "Caught exception: 100",
      "No error",
      "Caught exception: x",
      "Compilation error"
    ]
  },
  {
    "q": "Which exception class is used when a new memory allocation fails in C++?",
    "o": [
      "std::bad_alloc",
      "std::memory_error",
      "std::alloc_exception",
      "std::out_of_memory"
    ]
  },
  {
    "q": "What should be done in a custom exception class to provide an error message?",
    "o": [
      "Override the what() function",
      "Redefine the throw keyword",
      "Inherit from std::error instead",
      "Use a global message variable"
    ]
  },
  {
    "q": "Which of the following guarantees that no exceptions will be thrown by a function?",
    "o": [
      "noexcept",
      "throw()",
      "nothrow",
      "try()"
    ]
  },
  {
    "q": "What will the following C++ code output?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nvoid test() {\n    throw logic_error(\"Logic error!\");\n}\n\nint main() {\n    try {\n        test();\n    } catch (const logic_error& e) {\n        cout << e.what();\n    }\n    return 0;\n}",
    "o": [
      "Logic error!",
      "Caught exception",
      "Unhandled exception",
      "Compilation error"
    ]
  },
  {
    "q": "What type of exception safety ensures that operations leave objects in a valid state but may modify them?",
    "o": [
      "Basic exception guarantee",
      "Strong exception guarantee",
      "No-throw guarantee",
      "Weak exception guarantee"
    ]
  },
  {
    "q": "What does `catch(std::exception& e)` provide in exception handling?",
    "o": [
      "Polymorphic catching of standard exceptions",
      "Prevention of memory leaks",
      "Faster compilation",
      "Direct error code return"
    ]
  },
  {
    "q": "Which line properly defines a custom exception class in C++?",
    "o": [
      "class MyException : public std::exception { public: const char* what() const noexcept override { return \"MyException occurred\"; } };",
      "class MyException extends std::exception { const char* message() { return \"error\"; } };",
      "class MyException implements std::exception { public: char* msg() { return \"oops\"; } };",
      "exception MyException() { return \"Invalid\"; };"
    ]
  },
  {
    "q": "Which block is mandatory in a C++ exception handling structure?",
    "o": [
      "try",
      "catch",
      "throw",
      "finally"
    ]
  },
  {
    "q": "Which of the following correctly catches all exceptions in C++?",
    "o": [
      "catch(...)",
      "catch(std::exception)",
      "catch(int e)",
      "catch(any)"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nint main() {\n    try {\n        throw 'x';\n    } catch (int) {\n        cout << \"Caught int\";\n    } catch (...) {\n        cout << \"Caught something else\";\n    }\n    return 0;\n}",
    "o": [
      "Caught something else",
      "Caught int",
      "Caught char",
      "Runtime error"
    ]
  },
  {
    "q": "Which of the following is a benefit of exception handling in C++?",
    "o": [
      "Separates error handling from regular code",
      "Improves code execution speed",
      "Avoids using memory",
      "Increases dependency on OS"
    ]
  },
  {
    "q": "What will happen if an exception is thrown but not caught?",
    "o": [
      "The program will terminate",
      "The program will continue execution",
      "It will raise a compile-time error",
      "It will silently ignore it"
    ]
  },
  {
    "q": "Which exception is thrown by `typeid` when applied to a dereferenced null pointer to a polymorphic type?",
    "o": [
      "std::bad_typeid",
      "std::bad_cast",
      "std::runtime_error",
      "std::invalid_argument"
    ]
  },
  {
    "q": "Which of the following keywords is used to declare that a function may throw no exceptions in C++11 and above?",
    "o": [
      "noexcept",
      "throw()",
      "neverthrow",
      "safe"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\n#include <stdexcept>\nusing namespace std;\n\nint main() {\n    try {\n        throw std::invalid_argument(\"Invalid argument!\");\n    } catch (const std::logic_error& e) {\n        cout << e.what();\n    }\n    return 0;\n}",
    "o": [
      "Invalid argument!",
      "Runtime error",
      "Caught invalid_argument",
      "No output"
    ]
  },
  {
    "q": "What level of exception safety ensures that no side effects occur if an exception is thrown?",
    "o": [
      "Strong exception guarantee",
      "Basic exception guarantee",
      "No-throw guarantee",
      "Minimal exception guarantee"
    ]
  },
  {
    "q": "Which of the following is true about custom exception classes in C++?",
    "o": [
      "They typically inherit from std::exception",
      "They must be defined inside the main function",
      "They should not contain any member functions",
      "They must not override the what() method"
    ]
  },
  {
    "q": "Which standard exception is thrown when a type cast using dynamic_cast fails?",
    "o": [
      "std::bad_cast",
      "std::bad_typeid",
      "std::invalid_argument",
      "std::runtime_error"
    ]
  }
]