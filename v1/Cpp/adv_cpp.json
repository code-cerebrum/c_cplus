[
  {
    "q": "Which of the following is the correct way to access a variable from a namespace in C++?",
    "o": [
      "using namespace_name::variable_name;",
      "access variable using variable_name only;",
      "namespace variable_name;",
      "access::namespace.variable_name;"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "namespace A {\n    int value = 10;\n}\nnamespace B {\n    int value = 20;\n}\n\n#include <iostream>\nint main() {\n    std::cout << A::value << std::endl;\n    return 0;\n}",
    "o": [
      "10",
      "20",
      "A::value",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer automatically deletes the object when the last shared pointer to it is destroyed?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::weak_ptr"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::shared_ptr<int> p1 = std::make_shared<int>(42);\n    std::shared_ptr<int> p2 = p1;\n    std::cout << *p2 << std::endl;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "Garbage value",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following best describes move semantics in C++?",
    "o": [
      "It allows the resources of one object to be moved to another to avoid deep copies.",
      "It creates a new object and copies all resources from another object.",
      "It disables object copying.",
      "It makes all objects const after assignment."
    ]
  },
  {
    "q": "What is the output of the following code snippet demonstrating move semantics?",
    "c": "#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> a = {1, 2, 3};\n    std::vector<int> b = std::move(a);\n    std::cout << \"Size of a: \" << a.size() << std::endl;\n    std::cout << \"Size of b: \" << b.size() << std::endl;\n    return 0;\n}",
    "o": [
      "Size of a: 0\nSize of b: 3",
      "Size of a: 3\nSize of b: 3",
      "Size of a: 3\nSize of b: 0",
      "Size of a: 0\nSize of b: 0"
    ]
  },
  {
    "q": "Which header file must be included to use multithreading features like std::thread in C++?",
    "o": [
      "<thread>",
      "<pthread>",
      "<concurrency>",
      "<mutex>"
    ]
  },
  {
    "q": "What is the output of the following code snippet using std::thread?",
    "c": "#include <iostream>\n#include <thread>\n\nvoid printMessage() {\n    std::cout << \"Hello from thread!\" << std::endl;\n}\n\nint main() {\n    std::thread t(printMessage);\n    t.join();\n    return 0;\n}",
    "o": [
      "Hello from thread!",
      "No output",
      "Compilation error",
      "Program crash"
    ]
  },
  {
    "q": "Which operator is used to resolve scope in C++ namespaces?",
    "o": [
      "::",
      ".",
      "->",
      ":"
    ]
  },
  {
    "q": "What is the output of this code snippet?",
    "c": "#include <iostream>\nnamespace Physics {\n    int force = 50;\n}\nnamespace Chemistry {\n    int force = 30;\n}\n\nint main() {\n    using namespace Physics;\n    std::cout << force << std::endl;\n    return 0;\n}",
    "o": [
      "50",
      "30",
      "force",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer provides sole ownership of a dynamically allocated object?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What will be the result of this code snippet?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::unique_ptr<int> p1 = std::make_unique<int>(100);\n    std::unique_ptr<int> p2 = std::move(p1);\n    std::cout << *p2 << std::endl;\n    return 0;\n}",
    "o": [
      "100",
      "0",
      "Compilation error",
      "Segmentation fault"
    ]
  },
  {
    "q": "Which of the following statements about std::move is true?",
    "o": [
      "std::move casts an object to an rvalue reference to enable move semantics.",
      "std::move deletes the source object.",
      "std::move creates a deep copy of the object.",
      "std::move disables copy constructors."
    ]
  },
  {
    "q": "What will be the output of this code snippet using move semantics?",
    "c": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string a = \"Hello\";\n    std::string b = std::move(a);\n    std::cout << \"b: \" << b << \"\\na: \" << a << std::endl;\n    return 0;\n}",
    "o": [
      "b: Hello\na: ",
      "b: \na: Hello",
      "b: Hello\na: Hello",
      "b: \na: "
    ]
  },
  {
    "q": "What does std::thread::join() do in C++ multithreading?",
    "o": [
      "Waits for the thread to finish execution before continuing.",
      "Starts a new thread.",
      "Detaches a thread for independent execution.",
      "Kills the thread prematurely."
    ]
  },
  {
    "q": "What is the output of the following multithreading code?",
    "c": "#include <iostream>\n#include <thread>\n\nvoid task() {\n    std::cout << \"Task running\\n\";\n}\n\nint main() {\n    std::thread t1(task);\n    t1.detach();\n    std::cout << \"Main ends\\n\";\n    return 0;\n}",
    "o": [
      "Main ends\nTask running",
      "Task running\nMain ends",
      "Only Task running",
      "Only Main ends"
    ]
  },
  {
    "q": "Which of the following is a correct use of a nested namespace in C++17?",
    "o": [
      "namespace A::B { int x = 5; }",
      "namespace A->B { int x = 5; }",
      "namespace A.B { int x = 5; }",
      "namespace A/B { int x = 5; }"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "#include <iostream>\nnamespace Alpha {\n    int val = 100;\n}\n\nnamespace Beta {\n    int val = 200;\n}\n\nint main() {\n    std::cout << Beta::val << std::endl;\n    return 0;\n}",
    "o": [
      "200",
      "100",
      "Beta::val",
      "Compilation Error"
    ]
  },
  {
    "q": "Which of the following smart pointers is best suited to avoid circular references?",
    "o": [
      "std::weak_ptr",
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What happens when a std::unique_ptr is moved to another unique_ptr?",
    "o": [
      "Ownership is transferred, and the original becomes null.",
      "Both pointers now own the same object.",
      "It results in a compilation error.",
      "The object is deleted immediately."
    ]
  },
  {
    "q": "What is the purpose of rvalue references (&&) in move semantics?",
    "o": [
      "They enable resources to be moved rather than copied.",
      "They prevent objects from being modified.",
      "They allow overloading of the copy constructor.",
      "They always point to null."
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\n#include <utility>\n#include <vector>\n\nint main() {\n    std::vector<int> a = {1, 2, 3};\n    std::vector<int> b = std::move(a);\n    std::cout << \"a.size(): \" << a.size() << std::endl;\n    return 0;\n}",
    "o": [
      "a.size(): 0",
      "a.size(): 3",
      "a.size(): undefined",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is true about std::thread::detach()?",
    "o": [
      "It allows the thread to run independently in the background.",
      "It waits for the thread to finish execution.",
      "It terminates the thread.",
      "It throws an exception if called twice."
    ]
  },
  {
    "q": "What will be the output of this multithreaded program?",
    "c": "#include <iostream>\n#include <thread>\n\nvoid run() {\n    std::cout << \"Running in thread\\n\";\n}\n\nint main() {\n    std::thread t(run);\n    t.join();\n    std::cout << \"Main thread ends\\n\";\n    return 0;\n}",
    "o": [
      "Running in thread\nMain thread ends",
      "Main thread ends\nRunning in thread",
      "No output",
      "Compilation error"
    ]
  },
  {
    "q": "How do you access a variable from a specific namespace in C++?",
    "o": [
      "Using the scope resolution operator ::",
      "Using the dot operator .",
      "Using the arrow operator ->",
      "Using the assignment operator ="
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nnamespace Math {\n    int value = 10;\n}\n\nint main() {\n    int value = 5;\n    std::cout << Math::value << std::endl;\n    return 0;\n}",
    "o": [
      "10",
      "5",
      "0",
      "Math::value"
    ]
  },
  {
    "q": "Which smart pointer automatically deletes the object it holds when it goes out of scope?",
    "o": [
      "std::unique_ptr",
      "std::weak_ptr",
      "std::shared_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What is the key difference between std::shared_ptr and std::unique_ptr?",
    "o": [
      "shared_ptr allows multiple owners; unique_ptr allows only one",
      "unique_ptr allows multiple owners; shared_ptr allows only one",
      "shared_ptr deletes object when copied",
      "unique_ptr requires manual deletion"
    ]
  },
  {
    "q": "Which code snippet shows correct move semantics usage?",
    "c": "#include <iostream>\n#include <string>\n#include <utility>\n\nint main() {\n    std::string s1 = \"C++\";\n    std::string s2 = std::move(s1);\n    std::cout << s2 << std::endl;\n    return 0;\n}",
    "o": [
      "C++",
      "s1",
      "std::move",
      "Compilation error"
    ]
  },
  {
    "q": "Which statement about move constructors is true?",
    "o": [
      "They take an rvalue reference as a parameter.",
      "They take an lvalue reference as a parameter.",
      "They are called implicitly on copy assignment.",
      "They are only used with smart pointers."
    ]
  },
  {
    "q": "In multithreading, what happens if join() is not called on a std::thread object?",
    "o": [
      "The program may terminate unexpectedly.",
      "The thread continues safely in the background.",
      "It automatically joins at the end.",
      "The thread is paused until join() is called."
    ]
  },
  {
    "q": "What is the output of this C++ multithreading example?",
    "c": "#include <iostream>\n#include <thread>\nvoid work() {\n    std::cout << \"Working...\\n\";\n}\nint main() {\n    std::thread t1(work);\n    t1.join();\n    return 0;\n}",
    "o": [
      "Working...",
      "join...",
      "Error",
      "No output"
    ]
  },
  {
    "q": "Which keyword is used to refer to the global namespace explicitly?",
    "o": [
      "::",
      "global::",
      "namespace",
      "this::"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nnamespace A {\n    int x = 20;\n    namespace B {\n        int x = 50;\n    }\n}\nint main() {\n    std::cout << A::B::x << std::endl;\n    return 0;\n}",
    "o": [
      "50",
      "20",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer provides shared ownership of a dynamically allocated object?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What happens if two shared_ptr instances manage the same raw pointer without using make_shared?",
    "o": [
      "Double deletion may occur",
      "It ensures single deletion",
      "The program won't compile",
      "Both will be automatically converted to unique_ptr"
    ]
  },
  {
    "q": "Which situation best justifies the use of move semantics?",
    "o": [
      "Transferring ownership of a large resource like a vector or file handle",
      "Accessing a global constant",
      "Reading from a pointer without modifying",
      "Avoiding function overloading"
    ]
  },
  {
    "q": "What is the output of this code involving move semantics?",
    "c": "#include <iostream>\n#include <vector>\n\nstd::vector<int> getVector() {\n    std::vector<int> v = {1, 2, 3};\n    return v;\n}\n\nint main() {\n    std::vector<int> data = std::move(getVector());\n    std::cout << data.size() << std::endl;\n    return 0;\n}",
    "o": [
      "3",
      "0",
      "1",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is true about std::thread?",
    "o": [
      "It represents a single thread of execution",
      "It always runs in the main thread",
      "It replaces the main function",
      "It can only be used with std::mutex"
    ]
  },
  {
    "q": "What is the effect of calling std::this_thread::sleep_for()?",
    "o": [
      "It pauses the current thread for a specified duration",
      "It terminates all threads",
      "It joins all running threads",
      "It switches execution to another CPU core"
    ]
  },
  {
    "q": "Which of the following allows access to a variable in an outer namespace when the same variable exists in the inner scope?",
    "o": [
      "::NamespaceName::variableName",
      "NamespaceName::variableName",
      "variableName::NamespaceName",
      "NamespaceName.variableName"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\nnamespace Outer {\n    int num = 42;\n}\nint main() {\n    int num = 10;\n    std::cout << ::Outer::num << std::endl;\n    return 0;\n}",
    "o": [
      "42",
      "10",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer can break circular references when used with std::shared_ptr?",
    "o": [
      "std::weak_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What does std::make_unique provide in C++14?",
    "o": [
      "Safe creation of std::unique_ptr",
      "Automatic reference counting",
      "Creating multiple shared owners",
      "Thread-safe memory access"
    ]
  },
  {
    "q": "Which of the following is true about move assignment in C++?",
    "o": [
      "It transfers ownership and leaves the source in a valid but unspecified state",
      "It copies data and leaves both variables unchanged",
      "It destroys the moved-from object immediately",
      "It only applies to primitive data types"
    ]
  },
  {
    "q": "What is the output of this C++ program?",
    "c": "#include <iostream>\n#include <utility>\n#include <string>\nint main() {\n    std::string a = \"Apple\";\n    std::string b = std::move(a);\n    std::cout << b << std::endl;\n    return 0;\n}",
    "o": [
      "Apple",
      "a",
      "b",
      "Compilation error"
    ]
  },
  {
    "q": "Which header must be included to use std::thread?",
    "o": [
      "<thread>",
      "<pthread>",
      "<future>",
      "<atomic>"
    ]
  },
  {
    "q": "Which of the following statements is true about detach() in std::thread?",
    "o": [
      "It allows the thread to run independently from the main thread",
      "It waits for the thread to finish execution",
      "It stops the thread immediately",
      "It synchronizes multiple threads"
    ]
  },
  {
    "q": "What does the 'using namespace std;' directive do in a C++ program?",
    "o": [
      "Brings all names from the std namespace into the current scope",
      "Defines a new namespace named std",
      "Restricts access to std namespace members",
      "Converts all variables to standard types"
    ]
  },
  {
    "q": "What is the output of this C++ code using nested namespaces?",
    "c": "#include <iostream>\nnamespace A {\n    namespace B {\n        void greet() { std::cout << \"Hello from B\"; }\n    }\n}\nint main() {\n    A::B::greet();\n    return 0;\n}",
    "o": [
      "Hello from B",
      "greet",
      "Compilation error",
      "Hello A"
    ]
  },
  {
    "q": "Which smart pointer enforces exclusive ownership of a resource?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "Why is make_shared preferred over direct use of shared_ptr constructor?",
    "o": [
      "It performs a single allocation for both the object and control block",
      "It allows more flexible memory deallocation",
      "It guarantees thread safety",
      "It supports weak references directly"
    ]
  },
  {
    "q": "Which of the following is moved, not copied, in the move constructor?",
    "o": [
      "Resources like heap memory or file handles",
      "Global constants",
      "Function pointers",
      "Loop counters"
    ]
  },
  {
    "q": "What is the result of this code involving move semantics?",
    "c": "#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v1 = {1, 2, 3};\n    std::vector<int> v2 = std::move(v1);\n    std::cout << v1.size() << std::endl;\n    return 0;\n}",
    "o": [
      "0",
      "3",
      "Undefined",
      "Compilation error"
    ]
  },
  {
    "q": "What happens if you call join() on a std::thread twice?",
    "o": [
      "It throws a runtime exception",
      "It joins the thread again",
      "It silently returns",
      "It terminates the process"
    ]
  },
  {
    "q": "Which of the following correctly starts a thread in C++?",
    "c": "#include <iostream>\n#include <thread>\nvoid task() { std::cout << \"Running\"; }\nint main() {\n    std::thread t(task);\n    t.join();\n    return 0;\n}",
    "o": [
      "Running",
      "task",
      "join",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following accesses the global variable 'x' if a local variable of the same name exists?",
    "o": [
      "::x",
      "x::global",
      "global::x",
      "x::"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nnamespace X {\n    int val = 7;\n}\nint val = 3;\nint main() {\n    std::cout << X::val << \" \" << val;\n    return 0;\n}",
    "o": [
      "7 3",
      "3 7",
      "7 7",
      "3 3"
    ]
  },
  {
    "q": "Which smart pointer automatically deletes the object when it goes out of scope and doesn't allow copying?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::auto_ptr",
      "std::weak_ptr"
    ]
  },
  {
    "q": "Which of the following is used to observe but not own a shared resource?",
    "o": [
      "std::weak_ptr",
      "std::shared_ptr",
      "std::unique_ptr",
      "std::observer_ptr"
    ]
  },
  {
    "q": "Which keyword is used to enable move semantics in C++?",
    "o": [
      "std::move",
      "std::forward",
      "std::copy",
      "std::ref"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\n#include <string>\n#include <utility>\nint main() {\n    std::string a = \"C++\";\n    std::string b = std::move(a);\n    std::cout << a.empty();\n    return 0;\n}",
    "o": [
      "1",
      "0",
      "C++",
      "Compilation Error"
    ]
  },
  {
    "q": "What happens if you forget to call join or detach on a std::thread?",
    "o": [
      "std::terminate will be called",
      "The program will hang indefinitely",
      "The thread will run in background safely",
      "Nothing will happen"
    ]
  },
  {
    "q": "Which of the following correctly checks if a thread is joinable before calling join()?",
    "c": "#include <iostream>\n#include <thread>\nvoid work() {}\nint main() {\n    std::thread t(work);\n    if (t.joinable()) t.join();\n    return 0;\n}",
    "o": [
      "No runtime error",
      "Thread will throw exception",
      "Compilation error",
      "Undefined behavior"
    ]
  },
  {
    "q": "How can you refer to a function 'print()' defined inside namespace 'myUtils'?",
    "o": [
      "myUtils::print()",
      "::print()",
      "print::myUtils()",
      "namespace::print()"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nnamespace A {\n    int x = 5;\n    namespace B {\n        int x = 10;\n    }\n}\nint main() {\n    std::cout << A::x << \" \" << A::B::x;\n    return 0;\n}",
    "o": [
      "5 10",
      "10 5",
      "0 0",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer type allows multiple owners of the same dynamically allocated object?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What will happen if a shared_ptr's last owner goes out of scope?",
    "o": [
      "The object will be destroyed automatically",
      "The program crashes",
      "The object memory leaks",
      "The pointer becomes null but object remains"
    ]
  },
  {
    "q": "Which of the following scenarios is ideal for move semantics?",
    "o": [
      "Transferring ownership of a large temporary object",
      "Copying primitive data types",
      "Passing small values like int or char",
      "Storing static data in a container"
    ]
  },
  {
    "q": "What is the output of this code demonstrating move semantics?",
    "c": "#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v1 = {1,2,3};\n    std::vector<int> v2;\n    v2 = std::move(v1);\n    std::cout << v1.empty();\n    return 0;\n}",
    "o": [
      "1",
      "0",
      "3",
      "Compilation error"
    ]
  },
  {
    "q": "Which header is needed to work with std::thread in C++?",
    "o": [
      "<thread>",
      "<pthread>",
      "<concurrency>",
      "<parallel>"
    ]
  },
  {
    "q": "What will be the output of this C++ program using threads?",
    "c": "#include <iostream>\n#include <thread>\nvoid print() { std::cout << \"Thread running!\"; }\nint main() {\n    std::thread t(print);\n    t.join();\n    return 0;\n}",
    "o": [
      "Thread running!",
      "Compilation error",
      "Nothing",
      "Thread created!"
    ]
  },
  {
    "q": "What is the primary reason for using namespaces in C++?",
    "o": [
      "To avoid name conflicts between identifiers",
      "To speed up compilation time",
      "To enforce access restrictions",
      "To enable dynamic dispatch"
    ]
  },
  {
    "q": "What is the output of the following code using nested namespaces?",
    "c": "#include <iostream>\nnamespace outer {\n  namespace inner {\n    void greet() { std::cout << \"Hello from inner\"; }\n  }\n}\nint main() {\n  outer::inner::greet();\n  return 0;\n}",
    "o": [
      "Hello from inner",
      "inner",
      "Hello",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer type should be used when exactly one owner of the object is allowed?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What will happen when you copy a unique_ptr?",
    "o": [
      "It causes a compilation error",
      "It copies the underlying object",
      "It resets the original pointer",
      "It moves the pointer by default"
    ]
  },
  {
    "q": "Which of the following best describes move semantics?",
    "o": [
      "Transferring ownership of resources without deep copy",
      "Copying objects using overloaded assignment operator",
      "Using const references to avoid copying",
      "Avoiding heap allocation during runtime"
    ]
  },
  {
    "q": "What is the output of this code using move constructor?",
    "c": "#include <iostream>\n#include <string>\nclass A {\npublic:\n  std::string s;\n  A(std::string str) : s(str) {}\n  A(A&& other) { s = std::move(other.s); }\n};\nint main() {\n  A a1(\"Hello\");\n  A a2(std::move(a1));\n  std::cout << a2.s;\n}",
    "o": [
      "Hello",
      "Compilation error",
      "a1",
      "Empty string"
    ]
  },
  {
    "q": "Which C++ header is required to use std::mutex?",
    "o": [
      "<mutex>",
      "<thread>",
      "<atomic>",
      "<chrono>"
    ]
  },
  {
    "q": "What is the purpose of std::lock_guard in C++ multithreading?",
    "o": [
      "Automatically manages a mutex lock within a scope",
      "Spawns a new thread for the guarded section",
      "Monitors a condition variable",
      "Delays thread execution"
    ]
  },
  {
    "q": "Which operator is used to access members from a namespace in C++?",
    "o": [
      "::",
      ".",
      "->",
      "=>"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "#include <iostream>\nnamespace A {\n  int value = 100;\n}\nint value = 50;\nint main() {\n  std::cout << A::value;\n  return 0;\n}",
    "o": [
      "100",
      "50",
      "Compilation error",
      "0"
    ]
  },
  {
    "q": "What happens when the last std::shared_ptr owning a resource is destroyed?",
    "o": [
      "The resource is deallocated",
      "A runtime exception is thrown",
      "Nothing happens",
      "The resource is moved to a weak pointer"
    ]
  },
  {
    "q": "Which smart pointer does not participate in ownership but can observe a shared object?",
    "o": [
      "std::weak_ptr",
      "std::shared_ptr",
      "std::unique_ptr",
      "std::observer_ptr"
    ]
  },
  {
    "q": "What is the primary benefit of move semantics over copy semantics?",
    "o": [
      "Avoids unnecessary deep copies and improves performance",
      "Ensures thread-safety",
      "Automatically manages memory leaks",
      "Supports recursive calls"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "#include <iostream>\n#include <vector>\nint main() {\n  std::vector<int> a = {1,2,3};\n  std::vector<int> b(std::move(a));\n  std::cout << a.size();\n  return 0;\n}",
    "o": [
      "0",
      "3",
      "Undefined behavior",
      "Compilation error"
    ]
  },
  {
    "q": "What is the purpose of std::thread::join()?",
    "o": [
      "Waits for the thread to finish execution",
      "Detaches the thread to run independently",
      "Kills the running thread",
      "Pauses the main thread indefinitely"
    ]
  },
  {
    "q": "Which of the following is a correct way to start a thread in C++?",
    "o": [
      "std::thread t([](){ std::cout << \"Hello\"; });",
      "thread.start();",
      "std::start_thread();",
      "create_thread(std::function);"
    ]
  },
  {
    "q": "Which of the following allows aliasing a long namespace name to a shorter one?",
    "o": [
      "Using namespace alias",
      "Using #define",
      "Using typedef",
      "Using template"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "#include <iostream>\nnamespace Math {\n  int add(int a, int b) { return a + b; }\n}\nint main() {\n  using namespace Math;\n  std::cout << add(3, 4);\n  return 0;\n}",
    "o": [
      "7",
      "34",
      "Compilation error",
      "Math::add"
    ]
  },
  {
    "q": "What happens if multiple std::shared_ptr manage the same object and one resets?",
    "o": [
      "Only the calling shared_ptr stops managing the object",
      "The object is deleted immediately",
      "All shared_ptrs become invalid",
      "A runtime error occurs"
    ]
  },
  {
    "q": "What is the correct syntax to create a std::unique_ptr of an integer?",
    "o": [
      "std::unique_ptr<int> ptr = std::make_unique<int>(10);",
      "std::unique_ptr<int> ptr(10);",
      "auto ptr = new std::unique_ptr<int>(10);",
      "std::unique_ptr<int> ptr = unique_ptr<int>(10);"
    ]
  },
  {
    "q": "Which of these best describes the move constructor?",
    "o": [
      "It transfers resources from one object to another without copying",
      "It makes a deep copy of the object",
      "It duplicates the object and its resources",
      "It deletes the original object"
    ]
  },
  {
    "q": "What will be the output?",
    "c": "#include <iostream>\n#include <utility>\nclass Demo {\npublic:\n  Demo() {}\n  Demo(Demo&&) { std::cout << \"Moved\"; }\n};\nint main() {\n  Demo d1;\n  Demo d2 = std::move(d1);\n  return 0;\n}",
    "o": [
      "Moved",
      "Compilation error",
      "Runtime error",
      "No output"
    ]
  },
  {
    "q": "Which function should be used to synchronize threads at the end of execution?",
    "o": [
      "join()",
      "detach()",
      "wait()",
      "sync()"
    ]
  },
  {
    "q": "Which header file is essential for using std::thread in C++?",
    "o": [
      "<thread>",
      "<mutex>",
      "<future>",
      "<concurrency>"
    ]
  },
  {
    "q": "Which of the following is the correct way to access a global variable hidden by a local one?",
    "o": [
      "::x",
      "x::global",
      "global::x",
      "this->x"
    ]
  },
  {
    "q": "What does this code print?",
    "c": "#include <iostream>\nint value = 10;\nint main() {\n  int value = 20;\n  std::cout << ::value;\n  return 0;\n}",
    "o": [
      "10",
      "20",
      "Compilation error",
      "Undefined behavior"
    ]
  },
  {
    "q": "Which smart pointer automatically deletes the object when it goes out of scope and cannot be copied?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::auto_ptr",
      "std::weak_ptr"
    ]
  },
  {
    "q": "Which smart pointer allows multiple references to the same resource with reference counting?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "Move semantics can be most beneficial in which of the following scenarios?",
    "o": [
      "Returning large objects from functions",
      "Passing small integers by value",
      "Copying constant values",
      "Using global variables"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "#include <iostream>\n#include <vector>\nint main() {\n  std::vector<int> a = {1, 2, 3};\n  std::vector<int> b;\n  b = std::move(a);\n  std::cout << a.size();\n  return 0;\n}",
    "o": [
      "0",
      "3",
      "1",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following allows a thread to execute independently from the main thread?",
    "o": [
      "detach()",
      "join()",
      "terminate()",
      "pause()"
    ]
  },
  {
    "q": "What will happen if join() is not called on a joinable std::thread before main() exits?",
    "o": [
      "Program may terminate abnormally",
      "Thread continues normally",
      "The thread auto joins",
      "Nothing happens"
    ]
  },
  {
    "q": "Which keyword is used to define a nested namespace in modern C++?",
    "o": [
      "namespace A::B",
      "namespace A_B",
      "using namespace B in A",
      "define namespace B inside A"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nnamespace A {\n  int value = 5;\n}\nnamespace B {\n  int value = 10;\n}\nint main() {\n  std::cout << A::value;\n  return 0;\n}",
    "o": [
      "5",
      "10",
      "15",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following best prevents memory leaks in modern C++?",
    "o": [
      "Using smart pointers like std::unique_ptr",
      "Using raw pointers carefully",
      "Calling delete manually",
      "Using garbage collector"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "#include <memory>\n#include <iostream>\nint main() {\n  std::unique_ptr<int> p = std::make_unique<int>(42);\n  std::cout << *p;\n  return 0;\n}",
    "o": [
      "42",
      "0",
      "nullptr",
      "Compilation error"
    ]
  },
  {
    "q": "What is the purpose of std::move?",
    "o": [
      "To enable move semantics by casting to an rvalue",
      "To copy objects",
      "To delete temporary objects",
      "To reset a smart pointer"
    ]
  },
  {
    "q": "What is the effect of moving a std::vector using std::move?",
    "o": [
      "Ownership of memory is transferred",
      "Elements are copied one-by-one",
      "The original vector is cleared manually",
      "Nothing happens"
    ]
  },
  {
    "q": "Which of the following is true about std::thread?",
    "o": [
      "A std::thread represents a single thread of execution",
      "It must be included via <future>",
      "It executes on the same core always",
      "It doesn't support joining"
    ]
  },
  {
    "q": "What is the result of calling detach() on a std::thread?",
    "o": [
      "The thread runs independently and cannot be joined later",
      "The thread is blocked",
      "The thread joins automatically",
      "The thread is terminated"
    ]
  },
  {
    "q": "Which of the following statements correctly uses a symbol from a namespace?",
    "o": [
      "std::cout << \"Hello\";",
      "cout::std << \"Hello\";",
      "print(std::cout, \"Hello\");",
      "namespace::std::cout(\"Hello\");"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "#include <iostream>\nnamespace Alpha {\n  void display() { std::cout << \"Alpha\"; }\n}\nnamespace Beta = Alpha;\nint main() {\n  Beta::display();\n  return 0;\n}",
    "o": [
      "Alpha",
      "Beta",
      "AlphaBeta",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following smart pointers is best suited to avoid circular references?",
    "o": [
      "std::weak_ptr",
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "Which smart pointer provides exclusive ownership and cannot be copied?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What does this code print?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n  std::shared_ptr<int> a = std::make_shared<int>(100);\n  std::shared_ptr<int> b = a;\n  std::cout << *b;\n  return 0;\n}",
    "o": [
      "100",
      "0",
      "Garbage value",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following best defines move semantics in C++?",
    "o": [
      "Transfers ownership of resources instead of copying",
      "Copies values from one object to another",
      "Deletes the original object after copying",
      "Makes deep copies of dynamically allocated memory"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "#include <iostream>\n#include <vector>\nint main() {\n  std::vector<int> a = {1, 2, 3};\n  std::vector<int> b(std::move(a));\n  std::cout << a.empty();\n  return 0;\n}",
    "o": [
      "1",
      "0",
      "3",
      "Compilation error"
    ]
  },
  {
    "q": "Which method waits for a thread to complete execution?",
    "o": [
      "join()",
      "detach()",
      "wait()",
      "end()"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "#include <iostream>\n#include <thread>\nvoid run() { std::cout << \"Thread Running\"; }\nint main() {\n  std::thread t(run);\n  t.join();\n  return 0;\n}",
    "o": [
      "Thread Running",
      "Nothing",
      "Compilation error",
      "Runtime error"
    ]
  },
  {
    "q": "Which of the following allows shared ownership of a heap object?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What does the scope resolution operator (::) do in C++?",
    "o": [
      "Accesses a global or namespaced identifier",
      "Creates a new namespace",
      "Declares a smart pointer",
      "Creates a thread"
    ]
  },
  {
    "q": "What will this program output?",
    "c": "#include <iostream>\nnamespace A {\n  int x = 10;\n}\nint x = 5;\nint main() {\n  std::cout << A::x;\n  return 0;\n}",
    "o": [
      "10",
      "5",
      "15",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer should you use when exactly one object should own a resource?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "Which of the following best describes the behavior of std::shared_ptr?",
    "o": [
      "Reference-counted smart pointer allowing multiple owners",
      "Non-owning observer pointer",
      "Single-owner smart pointer",
      "Thread-local smart pointer"
    ]
  },
  {
    "q": "What does this code output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n  std::unique_ptr<int> p1 = std::make_unique<int>(7);\n  std::unique_ptr<int> p2 = std::move(p1);\n  std::cout << *p2;\n  return 0;\n}",
    "o": [
      "7",
      "0",
      "Garbage value",
      "Runtime error"
    ]
  },
  {
    "q": "What is the primary advantage of move semantics in C++?",
    "o": [
      "Avoids unnecessary deep copies by transferring resources",
      "Allows objects to be shared between threads",
      "Ensures exception safety",
      "Improves recursion performance"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "#include <iostream>\n#include <vector>\nint main() {\n  std::vector<int> v1 = {1, 2, 3};\n  std::vector<int> v2 = std::move(v1);\n  std::cout << v1.size();\n  return 0;\n}",
    "o": [
      "0",
      "3",
      "1",
      "Compilation error"
    ]
  },
  {
    "q": "Which header is required to use std::thread?",
    "o": [
      "<thread>",
      "<pthread>",
      "<concurrency>",
      "<process>"
    ]
  },
  {
    "q": "What is the risk of not calling join() or detach() on a std::thread before the object is destroyed?",
    "o": [
      "std::terminate is called",
      "Memory leak occurs",
      "Thread runs forever",
      "The thread is suspended"
    ]
  },
  {
    "q": "Which smart pointer type is used to break cyclic references in a shared_ptr network?",
    "o": [
      "std::weak_ptr",
      "std::unique_ptr",
      "std::scoped_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "Which of the following correctly accesses a variable 'val' inside a namespace 'Data'?",
    "o": [
      "Data::val",
      "Data.val",
      "::Data.val",
      "val::Data"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "#include <iostream>\nnamespace X {\n  int value = 20;\n}\nint main() {\n  int value = 10;\n  std::cout << X::value;\n  return 0;\n}",
    "o": [
      "20",
      "10",
      "30",
      "Compilation Error"
    ]
  },
  {
    "q": "Which smart pointer automatically deletes the object it owns when it goes out of scope and cannot be copied?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What does this program do?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n  std::shared_ptr<int> sp1 = std::make_shared<int>(42);\n  std::shared_ptr<int> sp2 = sp1;\n  std::cout << *sp2;\n  return 0;\n}",
    "o": [
      "42",
      "0",
      "Garbage value",
      "Compilation error"
    ]
  },
  {
    "q": "Move constructors are mainly used to:",
    "o": [
      "Transfer ownership of resources from one object to another",
      "Copy data deeply from one object to another",
      "Delay object construction until needed",
      "Lock a thread-safe resource"
    ]
  },
  {
    "q": "What will be the result of this code?",
    "c": "#include <iostream>\n#include <vector>\nint main() {\n  std::vector<int> a = {1, 2, 3};\n  std::vector<int> b = std::move(a);\n  std::cout << a.empty();\n  return 0;\n}",
    "o": [
      "1",
      "0",
      "3",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following creates and runs a new thread in C++?",
    "o": [
      "std::thread t(myFunction);",
      "pthread_create(&t, NULL, myFunction, NULL);",
      "std::spawn t(myFunction);",
      "std::start_thread(myFunction);"
    ]
  },
  {
    "q": "Before a thread object is destroyed, what must be done?",
    "o": [
      "Either join() or detach() must be called",
      "Only join() must be called",
      "Only detach() must be called",
      "Nothing is required"
    ]
  },
  {
    "q": "What does std::weak_ptr help prevent in C++?",
    "o": [
      "Cyclic references with std::shared_ptr",
      "Dangling pointers from std::unique_ptr",
      "Race conditions in threads",
      "Memory leaks with raw pointers"
    ]
  },
  {
    "q": "Which C++11 feature is used to enable move semantics?",
    "o": [
      "rvalue references (&&)",
      "const references (&)",
      "lvalue references (*)",
      "volatile specifiers"
    ]
  },
  {
    "q": "Which keyword is used to define a namespace in C++?",
    "o": [
      "namespace",
      "using",
      "package",
      "module"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "#include <iostream>\nnamespace A {\n  int x = 100;\n}\nnamespace B {\n  int x = 200;\n}\nint main() {\n  std::cout << A::x;\n  return 0;\n}",
    "o": [
      "100",
      "200",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "What is true about std::shared_ptr?",
    "o": [
      "It maintains a reference count and deletes the object when the count reaches zero.",
      "It transfers ownership automatically.",
      "It is unsafe to use across multiple threads.",
      "It cannot be copied."
    ]
  },
  {
    "q": "Which code snippet correctly creates a unique pointer?",
    "c": "#include <memory>\n#include <iostream>\nint main() {\n  std::unique_ptr<int> ptr = std::make_unique<int>(5);\n  std::cout << *ptr;\n  return 0;\n}",
    "o": [
      "5",
      "0",
      "Compilation error",
      "Garbage value"
    ]
  },
  {
    "q": "What is the main purpose of move semantics in C++?",
    "o": [
      "To transfer resources instead of copying them.",
      "To make deep copies of objects.",
      "To lock shared data in threads.",
      "To call multiple functions in sequence."
    ]
  },
  {
    "q": "Which of the following correctly demonstrates move semantics?",
    "c": "#include <iostream>\n#include <string>\nint main() {\n  std::string a = \"Hello\";\n  std::string b = std::move(a);\n  std::cout << b;\n  return 0;\n}",
    "o": [
      "Hello",
      "a",
      "b",
      "Compilation error"
    ]
  },
  {
    "q": "Which header file is required for using std::thread?",
    "o": [
      "<thread>",
      "<mutex>",
      "<future>",
      "<chrono>"
    ]
  },
  {
    "q": "What will the following code do?",
    "c": "#include <iostream>\n#include <thread>\nvoid run() {\n  std::cout << \"Running in thread\";\n}\nint main() {\n  std::thread t(run);\n  t.join();\n  return 0;\n}",
    "o": [
      "Prints 'Running in thread'",
      "Throws exception",
      "Results in undefined behavior",
      "Causes segmentation fault"
    ]
  },
  {
    "q": "Which smart pointer allows observation without affecting ownership?",
    "o": [
      "std::weak_ptr",
      "std::unique_ptr",
      "std::shared_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "Which of the following expressions uses the global scope resolution operator?",
    "o": [
      "::x",
      "x::",
      "x::x",
      "x.x"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\nnamespace App {\n  int version = 3;\n}\nint main() {\n  std::cout << App::version;\n  return 0;\n}",
    "o": [
      "3",
      "App",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which statement correctly describes the use of std::unique_ptr?",
    "o": [
      "It ensures exclusive ownership of a dynamically allocated object.",
      "It shares ownership between multiple pointers.",
      "It can be copied freely.",
      "It is deprecated in modern C++."
    ]
  },
  {
    "q": "What will this program output?",
    "c": "#include <memory>\n#include <iostream>\nint main() {\n  std::unique_ptr<int> ptr1 = std::make_unique<int>(42);\n  std::cout << *ptr1;\n  return 0;\n}",
    "o": [
      "42",
      "0",
      "Garbage value",
      "Compilation error"
    ]
  },
  {
    "q": "What does std::move() do in C++?",
    "o": [
      "It casts an object to an rvalue reference to enable move semantics.",
      "It moves a variable from memory.",
      "It deletes the object.",
      "It swaps two objects."
    ]
  },
  {
    "q": "What is the benefit of move semantics over copy semantics?",
    "o": [
      "Improved performance by transferring resources instead of copying.",
      "Cleaner code structure.",
      "Stronger typing.",
      "Better debugging output."
    ]
  },
  {
    "q": "Which of the following is thread-safe and used for shared ownership?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::weak_ptr"
    ]
  },
  {
    "q": "How do you correctly launch a new thread using std::thread?",
    "c": "#include <iostream>\n#include <thread>\nvoid greet() {\n  std::cout << \"Hi from thread\";\n}\nint main() {\n  std::thread t(greet);\n  t.join();\n  return 0;\n}",
    "o": [
      "Hi from thread",
      "Compilation error",
      "Segmentation fault",
      "No output"
    ]
  },
  {
    "q": "Which function is used to wait for a thread to complete execution?",
    "o": [
      "join()",
      "wait()",
      "sleep()",
      "block()"
    ]
  },
  {
    "q": "Which is the correct way to access a global variable 'count' from within a class method using scope resolution?",
    "o": [
      "::count",
      "this::count",
      "global::count",
      "self.count"
    ]
  },
  {
    "q": "Which smart pointer does not manage ownership but can observe a shared resource?",
    "o": [
      "std::weak_ptr",
      "std::unique_ptr",
      "std::scoped_ptr",
      "std::shared_ptr"
    ]
  },
  {
    "q": "Which of the following allows differentiating between variables with the same name in different scopes?",
    "o": [
      "Scope resolution operator (::)",
      "Dot operator (.)",
      "Arrow operator (->)",
      "Assignment operator (=)"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "#include <iostream>\nint value = 50;\nint main() {\n  int value = 20;\n  std::cout << ::value;\n  return 0;\n}",
    "o": [
      "50",
      "20",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "Which of the following is true about std::unique_ptr?",
    "o": [
      "It cannot be copied, only moved.",
      "It uses reference counting to manage ownership.",
      "It can have multiple owners.",
      "It is deprecated in C++17."
    ]
  },
  {
    "q": "Which of the following operations is allowed on a std::unique_ptr?",
    "o": [
      "Move construction",
      "Copy construction",
      "Assignment from another unique_ptr",
      "Copy assignment"
    ]
  },
  {
    "q": "Which of the following ensures shared ownership of a dynamically allocated object?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::raw_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What does this code print?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n  auto p1 = std::make_shared<int>(100);\n  auto p2 = p1;\n  std::cout << *p2;\n  return 0;\n}",
    "o": [
      "100",
      "0",
      "Undefined behavior",
      "Segmentation fault"
    ]
  },
  {
    "q": "What is the primary purpose of std::move?",
    "o": [
      "To cast an object to an rvalue reference.",
      "To copy values efficiently.",
      "To delete temporary variables.",
      "To create a thread."
    ]
  },
  {
    "q": "Which of the following statements is true about move constructors?",
    "o": [
      "They avoid deep copying and transfer ownership of resources.",
      "They are slower than copy constructors.",
      "They are used to create shared pointers.",
      "They are only available in C++98."
    ]
  },
  {
    "q": "Which function must be called to wait for a std::thread to finish?",
    "o": [
      "join()",
      "wait()",
      "sync()",
      "close()"
    ]
  },
  {
    "q": "What is a potential issue if a thread is not joined or detached before main ends?",
    "o": [
      "The program will terminate abnormally.",
      "The thread will complete silently.",
      "The thread will be suspended.",
      "The thread will be converted to a process."
    ]
  },
  {
    "q": "What is the correct way to use a class defined inside a namespace?",
    "o": [
      "NamespaceName::ClassName obj;",
      "NamespaceName>ClassName obj;",
      "ClassName::NamespaceName obj;",
      "NamespaceName.ClassName obj;"
    ]
  },
  {
    "q": "What does this code output?",
    "c": "#include <iostream>\nnamespace Physics {\n  int speed = 99;\n}\nint main() {\n  using Physics::speed;\n  std::cout << speed;\n  return 0;\n}",
    "o": [
      "99",
      "0",
      "speed",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is true about std::weak_ptr?",
    "o": [
      "It does not increase the reference count of the shared object.",
      "It manages ownership like unique_ptr.",
      "It cannot be used with shared_ptr.",
      "It throws an exception on expired access."
    ]
  },
  {
    "q": "Which smart pointer is best suited for exclusive ownership of a resource?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What does the following code do?",
    "c": "#include <iostream>\n#include <memory>\nvoid process(std::unique_ptr<int> ptr) {\n  std::cout << *ptr;\n}\nint main() {\n  auto p = std::make_unique<int>(10);\n  process(std::move(p));\n  return 0;\n}",
    "o": [
      "Prints 10",
      "Throws an exception",
      "Causes segmentation fault",
      "Prints garbage value"
    ]
  },
  {
    "q": "What happens when you try to copy a std::unique_ptr?",
    "o": [
      "It causes a compile-time error.",
      "It results in a runtime error.",
      "It duplicates the ownership.",
      "It moves the ownership."
    ]
  },
  {
    "q": "What is the effect of std::move on an object?",
    "o": [
      "It enables moving resources from one object to another.",
      "It deletes the object from memory.",
      "It copies the object using shallow copy.",
      "It disables the object."
    ]
  },
  {
    "q": "Which C++11 feature allows functions to run concurrently in separate threads?",
    "o": [
      "std::thread",
      "std::atomic",
      "std::future",
      "std::chrono"
    ]
  },
  {
    "q": "What does the following program print?",
    "c": "#include <iostream>\n#include <thread>\nvoid work() {\n  std::cout << \"Threading!\\n\";\n}\nint main() {\n  std::thread t(work);\n  t.join();\n  return 0;\n}",
    "o": [
      "Threading!",
      "Error: join() missing",
      "No output",
      "Program crash"
    ]
  },
  {
    "q": "What does std::thread::detach() do?",
    "o": [
      "It allows the thread to run independently from the calling thread.",
      "It blocks the thread until execution finishes.",
      "It stops the thread.",
      "It merges two threads together."
    ]
  },
  {
    "q": "Which symbol is used to resolve scope in C++?",
    "o": [
      "::",
      "->",
      ".",
      ":"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "#include <iostream>\nnamespace A {\n  int value = 7;\n}\nnamespace B {\n  int value = 9;\n}\nint main() {\n  std::cout << A::value;\n  return 0;\n}",
    "o": [
      "7",
      "9",
      "Compilation Error",
      "0"
    ]
  },
  {
    "q": "Which of the following does NOT create a memory leak when used properly?",
    "o": [
      "std::shared_ptr",
      "new without delete",
      "raw pointer",
      "malloc without free"
    ]
  },
  {
    "q": "Which smart pointer is best for observing a shared resource without affecting ownership?",
    "o": [
      "std::weak_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What does this code output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n  std::unique_ptr<int> ptr1 = std::make_unique<int>(5);\n  std::unique_ptr<int> ptr2 = std::move(ptr1);\n  std::cout << *ptr2;\n  return 0;\n}",
    "o": [
      "5",
      "0",
      "Compilation error",
      "Segmentation fault"
    ]
  },
  {
    "q": "What is the result of passing a temporary object to a function expecting an rvalue reference?",
    "o": [
      "The function can move from the temporary object.",
      "The function will copy the temporary object.",
      "The program will crash.",
      "The function cannot be called."
    ]
  },
  {
    "q": "Which of these enables efficient transfer of resources without copying?",
    "o": [
      "Move semantics",
      "Copy constructor",
      "Shallow copy",
      "Virtual inheritance"
    ]
  },
  {
    "q": "What happens if join() is not called on a std::thread object before it goes out of scope?",
    "o": [
      "The program terminates with an error.",
      "The thread joins automatically.",
      "The thread is deleted silently.",
      "Nothing happens."
    ]
  },
  {
    "q": "Which header is required to use std::thread?",
    "o": [
      "<thread>",
      "<future>",
      "<mutex>",
      "<concurrency>"
    ]
  },
  {
    "q": "Which function should be used to safely access a shared resource between multiple threads?",
    "o": [
      "std::lock_guard",
      "std::atomic_flag",
      "std::async",
      "std::move"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\nnamespace alpha {\n    int val = 42;\n}\nint main() {\n    std::cout << alpha::val;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "val",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is used to access a global variable when a local variable with the same name exists?",
    "o": [
      "::variableName",
      "variableName",
      "global::variableName",
      "this->variableName"
    ]
  },
  {
    "q": "Which smart pointer automatically deletes the object when the last reference is gone?",
    "o": [
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr",
      "std::unique_ptr"
    ]
  },
  {
    "q": "Which smart pointer type cannot be copied but can be moved?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What will the following code do?",
    "c": "#include <memory>\nint main() {\n  std::unique_ptr<int> p1 = std::make_unique<int>(100);\n  std::unique_ptr<int> p2 = p1;\n  return 0;\n}",
    "o": [
      "Cause a compile-time error",
      "Compile and run successfully",
      "Run but crash",
      "Cause runtime error"
    ]
  },
  {
    "q": "Move semantics are primarily used to:",
    "o": [
      "Transfer ownership of resources efficiently",
      "Copy large objects deeply",
      "Prevent object slicing",
      "Implement inheritance"
    ]
  },
  {
    "q": "Which of the following would invoke the move constructor?",
    "c": "#include <utility>\nclass Data {\npublic:\n    Data(Data&& d) {}\n};\n\nint main() {\n    Data d1;\n    Data d2 = std::move(d1);\n    return 0;\n}",
    "o": [
      "std::move(d1)",
      "d1",
      "Data d2(d1)",
      "None of the above"
    ]
  },
  {
    "q": "What does std::this_thread::sleep_for(std::chrono::seconds(2)) do?",
    "o": [
      "Pauses the current thread for 2 seconds",
      "Starts a new thread",
      "Terminates the thread",
      "Waits for a signal"
    ]
  },
  {
    "q": "Which of the following best describes a detached thread?",
    "o": [
      "It runs independently and can't be joined",
      "It blocks the main thread",
      "It must be explicitly destroyed",
      "It uses less memory"
    ]
  },
  {
    "q": "Which of these prevents data races in multithreaded programs?",
    "o": [
      "std::mutex",
      "std::thread",
      "std::atomic_flag",
      "std::condition_variable"
    ]
  },
  {
    "q": "What is the purpose of the 'using namespace std;' directive?",
    "o": [
      "It allows access to standard library names without prefixing 'std::'.",
      "It declares a new namespace called std.",
      "It imports all headers from the standard library.",
      "It defines a function in the std namespace."
    ]
  },
  {
    "q": "Which of the following allows you to define a function with the same name in different namespaces?",
    "o": [
      "Using different namespaces",
      "Using static keyword",
      "Using inline functions",
      "Using function overloading"
    ]
  },
  {
    "q": "What does this code output?",
    "c": "#include <iostream>\nnamespace X { int v = 100; }\nnamespace Y { int v = 200; }\nint main() {\n  using namespace X;\n  std::cout << v;\n  return 0;\n}",
    "o": [
      "100",
      "200",
      "Compilation error",
      "Undefined behavior"
    ]
  },
  {
    "q": "Which of the following will result in a shared_ptr with a reference count of 2?",
    "c": "#include <memory>\nint main() {\n  auto p1 = std::make_shared<int>(10);\n  auto p2 = p1;\n}",
    "o": [
      "auto p2 = p1;",
      "auto p2 = std::move(p1);",
      "auto p2 = new std::shared_ptr<int>(p1);",
      "auto p2(p1.get());"
    ]
  },
  {
    "q": "What is the effect of std::move on an object?",
    "o": [
      "It enables moving of resources from the object.",
      "It deletes the object.",
      "It copies the object deeply.",
      "It disables the object’s destructor."
    ]
  },
  {
    "q": "Which of the following best describes a move constructor?",
    "o": [
      "A constructor that transfers ownership of resources from another object.",
      "A constructor that copies an object deeply.",
      "A constructor that disables copying.",
      "A constructor that uses inheritance."
    ]
  },
  {
    "q": "Which line is valid usage of std::unique_ptr?",
    "o": [
      "std::unique_ptr<int> p = std::make_unique<int>(10);",
      "std::unique_ptr<int> p(new int[10]);",
      "std::unique_ptr<int> p = new int(5);",
      "unique_ptr<int> p = make_unique<int>();"
    ]
  },
  {
    "q": "Which function launches a thread and returns a future to retrieve the result?",
    "o": [
      "std::async",
      "std::launch",
      "std::thread::join",
      "std::thread::detach"
    ]
  },
  {
    "q": "What is the output of this code snippet?",
    "c": "#include <thread>\n#include <iostream>\nvoid task() {\n std::cout << \"Running\";\n}\nint main() {\n std::thread t(task);\n t.join();\n return 0;\n}",
    "o": [
      "Running",
      "Compilation error",
      "Nothing",
      "Segmentation fault"
    ]
  },
  {
    "q": "Which is true about std::mutex?",
    "o": [
      "It is used to prevent data races between threads.",
      "It launches a new thread.",
      "It joins two threads together.",
      "It shares memory between threads."
    ]
  },
  {
    "q": "Which keyword is used to access a global variable when a local variable has the same name?",
    "o": [
      ":: (scope resolution operator)",
      "global",
      "extern",
      "& (address-of operator)"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "#include <iostream>\nnamespace A {\n  int value = 5;\n}\nnamespace B {\n  int value = 10;\n}\nint main() {\n  std::cout << A::value;\n  return 0;\n}",
    "o": [
      "5",
      "10",
      "Compilation Error",
      "Undefined"
    ]
  },
  {
    "q": "What happens when a std::unique_ptr is copied?",
    "o": [
      "Compilation error",
      "New memory is allocated",
      "It creates a shallow copy",
      "It behaves like shared_ptr"
    ]
  },
  {
    "q": "Which smart pointer allows multiple pointers to share ownership of a resource?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n  auto p = std::make_unique<int>(42);\n  std::cout << *p;\n}",
    "o": [
      "42",
      "0",
      "Undefined",
      "Compilation error"
    ]
  },
  {
    "q": "Which constructor is called when an object is initialized with std::move()?",
    "o": [
      "Move constructor",
      "Copy constructor",
      "Default constructor",
      "Destructor"
    ]
  },
  {
    "q": "What does std::thread::join() do?",
    "o": [
      "Waits for a thread to finish execution",
      "Detaches a thread from the main thread",
      "Starts a thread",
      "Suspends a thread"
    ]
  },
  {
    "q": "Which of the following is NOT true about move semantics?",
    "o": [
      "It creates a deep copy of the resource.",
      "It avoids unnecessary copying of resources.",
      "It uses rvalue references.",
      "It improves performance in some scenarios."
    ]
  },
  {
    "q": "What is the use of std::weak_ptr?",
    "o": [
      "To break cyclic references in shared_ptr",
      "To take unique ownership of an object",
      "To automatically delete the object when reference count is zero",
      "To increase the reference count"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "#include <iostream>\n#include <thread>\nvoid run() { std::cout << \"Hello from thread!\"; }\nint main() {\n  std::thread t(run);\n  t.join();\n}",
    "o": [
      "Hello from thread!",
      "Nothing",
      "Compilation Error",
      "Runtime Error"
    ]
  },
  {
    "q": "Which syntax correctly accesses a variable from a nested namespace?",
    "o": [
      "Outer::Inner::variable",
      "Inner::Outer::variable",
      "Outer.Inner.variable",
      "Outer->Inner->variable"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nnamespace A { namespace B { int x = 25; } }\nint main() {\n  std::cout << A::B::x;\n  return 0;\n}",
    "o": [
      "25",
      "0",
      "Compilation Error",
      "Segmentation Fault"
    ]
  },
  {
    "q": "Which smart pointer does NOT support copy semantics?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What is the purpose of std::move in C++?",
    "o": [
      "To enable move semantics by casting to rvalue",
      "To copy an object deeply",
      "To clone an object",
      "To delete an object"
    ]
  },
  {
    "q": "Which header file is required for using std::thread?",
    "o": [
      "<thread>",
      "<pthread>",
      "<concurrency>",
      "<multithread>"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n  std::shared_ptr<int> p1 = std::make_shared<int>(100);\n  std::shared_ptr<int> p2 = p1;\n  std::cout << *p2;\n}",
    "o": [
      "100",
      "0",
      "Compilation Error",
      "Undefined Behavior"
    ]
  },
  {
    "q": "Which function transfers ownership from one unique_ptr to another?",
    "o": [
      "std::move()",
      "std::copy()",
      "std::transfer()",
      "std::exchange()"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n  std::unique_ptr<int> p1 = std::make_unique<int>(50);\n  std::unique_ptr<int> p2 = std::move(p1);\n  std::cout << (p1 ? \"Valid\" : \"Null\");\n}",
    "o": [
      "Null",
      "Valid",
      "50",
      "Compilation Error"
    ]
  },
  {
    "q": "Why is std::lock_guard preferred in multithreaded applications?",
    "o": [
      "It provides exception-safe locking",
      "It avoids deadlocks always",
      "It allows copying of mutexes",
      "It blocks all other threads"
    ]
  },
  {
    "q": "What is true about std::weak_ptr?",
    "o": [
      "It does not increase the reference count",
      "It owns the object",
      "It can be directly dereferenced",
      "It is a replacement for std::unique_ptr"
    ]
  },
  {
    "q": "Which keyword allows access to an outer namespace when there is a name conflict?",
    "o": [
      "scope resolution operator (::)",
      "access modifier",
      "global keyword",
      "outer"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nnamespace X { int value = 42; }\nint value = 5;\nint main() {\n  std::cout << X::value;\n  return 0;\n}",
    "o": [
      "42",
      "5",
      "0",
      "Compilation Error"
    ]
  },
  {
    "q": "Which smart pointer can cause a memory leak if used improperly due to cyclic references?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::weak_ptr"
    ]
  },
  {
    "q": "Which is true about move constructors?",
    "o": [
      "They avoid deep copies by transferring ownership",
      "They are the same as copy constructors",
      "They are used only in inheritance",
      "They allocate dynamic memory"
    ]
  },
  {
    "q": "What does std::async do?",
    "o": [
      "Starts a function asynchronously, possibly on a new thread",
      "Schedules a function for delayed execution",
      "Locks a shared resource",
      "Prevents data races automatically"
    ]
  },
  {
    "q": "What will be the output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n  std::shared_ptr<int> sp = std::make_shared<int>(99);\n  std::weak_ptr<int> wp = sp;\n  std::cout << wp.use_count();\n}",
    "o": [
      "1",
      "0",
      "2",
      "Undefined"
    ]
  },
  {
    "q": "Which of the following correctly transfers ownership of a unique_ptr?",
    "c": "#include <memory>\nstd::unique_ptr<int> a = std::make_unique<int>(10);\n// Transfer ownership to b",
    "o": [
      "std::unique_ptr<int> b = std::move(a);",
      "std::unique_ptr<int> b = a;",
      "std::unique_ptr<int> b(a);",
      "std::unique_ptr<int> b = std::copy(a);"
    ]
  },
  {
    "q": "What is the effect of detaching a thread using std::thread::detach()?",
    "o": [
      "The thread runs independently and can't be joined",
      "The thread is paused",
      "The thread is terminated",
      "The thread runs in main thread context"
    ]
  },
  {
    "q": "Which operator is used to differentiate between global and local variables?",
    "o": [
      ":: (scope resolution operator)",
      ". (dot operator)",
      "-> (arrow operator)",
      "::= (assignment operator)"
    ]
  },
  {
    "q": "What is the output?",
    "c": "#include <iostream>\n#include <thread>\nvoid task() { std::cout << \"Thread working\\n\"; }\nint main() {\n  std::thread t(task);\n  t.join();\n  return 0;\n}",
    "o": [
      "Thread working",
      "Compilation Error",
      "No output",
      "Segmentation Fault"
    ]
  },
  {
    "q": "Which of the following ensures that a function from the global namespace is used even if a local namespace has a function with the same name?",
    "o": [
      "::functionName()",
      "global::functionName()",
      "use functionName()",
      "~functionName()"
    ]
  },
  {
    "q": "What is the output?",
    "c": "#include <iostream>\nnamespace A {\n    int val = 10;\n}\nnamespace B {\n    int val = 20;\n}\nint main() {\n    using namespace A;\n    std::cout << B::val;\n    return 0;\n}",
    "o": [
      "20",
      "10",
      "Compilation error",
      "0"
    ]
  },
  {
    "q": "Which smart pointer does not allow shared ownership?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "Which header is required to use std::unique_ptr?",
    "o": [
      "<memory>",
      "<utility>",
      "<thread>",
      "<functional>"
    ]
  },
  {
    "q": "What is the main advantage of move semantics?",
    "o": [
      "It avoids unnecessary deep copies",
      "It ensures thread safety",
      "It makes variables immutable",
      "It disables copy constructors"
    ]
  },
  {
    "q": "What does the following code do?",
    "c": "#include <iostream>\n#include <vector>\n#include <utility>\nint main() {\n    std::vector<int> a = {1, 2, 3};\n    std::vector<int> b = std::move(a);\n    std::cout << a.size();\n}",
    "o": [
      "0",
      "3",
      "Compilation Error",
      "Undefined Behavior"
    ]
  },
  {
    "q": "Which function ensures that the calling thread waits for another thread to finish execution?",
    "o": [
      "join()",
      "detach()",
      "wait()",
      "end()"
    ]
  },
  {
    "q": "What will be the output of this program?",
    "c": "#include <iostream>\n#include <thread>\nvoid func() { std::cout << \"Hello \"; }\nint main() {\n    std::thread t(func);\n    t.join();\n    std::cout << \"World\";\n    return 0;\n}",
    "o": [
      "Hello World",
      "World Hello",
      "Compilation Error",
      "Runtime Error"
    ]
  },
  {
    "q": "Which of the following can be used to prevent dangling pointers in multithreaded environments?",
    "o": [
      "std::shared_ptr",
      "raw pointers",
      "std::move",
      "global variables"
    ]
  },
  {
    "q": "Which of the following is a consequence of using std::thread without join or detach?",
    "o": [
      "std::terminate is called",
      "The thread runs in background",
      "The program waits for thread to complete",
      "Memory leak occurs"
    ]
  },
  {
    "q": "Which operator is used for scope resolution in C++?",
    "o": [
      "::",
      ".",
      "->",
      ":="
    ]
  },
  {
    "q": "What will be the output?",
    "c": "#include <iostream>\nnamespace outer {\n    int x = 5;\n    namespace inner {\n        int x = 10;\n    }\n}\nint main() {\n    std::cout << outer::inner::x;\n    return 0;\n}",
    "o": [
      "10",
      "5",
      "0",
      "Compilation Error"
    ]
  },
  {
    "q": "Which smart pointer allows multiple shared owners of the same object?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::weak_ptr"
    ]
  },
  {
    "q": "What will happen when two std::unique_ptr instances try to manage the same raw pointer?",
    "o": [
      "It causes undefined behavior",
      "It results in a compilation error",
      "It automatically transfers ownership",
      "Both will share ownership safely"
    ]
  },
  {
    "q": "Which of the following allows observing an object managed by std::shared_ptr without affecting its reference count?",
    "o": [
      "std::weak_ptr",
      "std::auto_ptr",
      "std::unique_ptr",
      "std::observer_ptr"
    ]
  },
  {
    "q": "Which of the following keywords enables move semantics for a user-defined class?",
    "o": [
      "std::move",
      "std::forward",
      "std::copy",
      "std::ref"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "#include <iostream>\n#include <string>\n#include <utility>\nint main() {\n    std::string a = \"Hello\";\n    std::string b = std::move(a);\n    std::cout << a;\n    return 0;\n}",
    "o": [
      "", 
      "Hello",
      "Compilation Error",
      "b"
    ]
  },
  {
    "q": "What is the purpose of std::thread::detach()?",
    "o": [
      "To allow the thread to run independently",
      "To wait for the thread to complete",
      "To terminate the thread",
      "To pause the thread"
    ]
  },
  {
    "q": "What is the minimal requirement for using std::thread in C++?",
    "o": [
      "#include <thread>",
      "#include <pthread>",
      "#include <concurrency>",
      "#include <system>"
    ]
  },
  {
    "q": "Why should shared resources be protected in a multithreaded program?",
    "o": [
      "To avoid data races and undefined behavior",
      "To improve performance",
      "To avoid using too much memory",
      "To simplify thread creation"
    ]
  },
  {
    "q": "Which of the following best describes the purpose of a namespace in C++?",
    "o": [
      "To prevent name conflicts in large projects",
      "To allocate memory dynamically",
      "To manage threads efficiently",
      "To store class templates"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "#include <iostream>\nnamespace A {\n    int value = 1;\n}\nnamespace B {\n    int value = 2;\n}\nint main() {\n    std::cout << A::value;\n    return 0;\n}",
    "o": [
      "1",
      "2",
      "0",
      "Compilation Error"
    ]
  },
  {
    "q": "Which smart pointer automatically deletes the managed object when the last reference to it is destroyed?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::raw_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "Which smart pointer cannot be copied but can be moved?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> p1 = std::make_unique<int>(42);\n    std::unique_ptr<int> p2 = std::move(p1);\n    std::cout << (p1 ? \"Valid\" : \"Null\");\n    return 0;\n}",
    "o": [
      "Null",
      "Valid",
      "42",
      "Compilation Error"
    ]
  },
  {
    "q": "Move constructors are preferred over copy constructors when:",
    "o": [
      "An object is initialized from a temporary",
      "An object is passed by const reference",
      "The compiler enforces it",
      "There is a virtual function"
    ]
  },
  {
    "q": "Which of the following enables thread-safe operations on shared data?",
    "o": [
      "std::mutex",
      "std::thread",
      "std::vector",
      "std::lockfree"
    ]
  },
  {
    "q": "Which method is used to block the current thread until another thread finishes execution?",
    "o": [
      "join()",
      "detach()",
      "yield()",
      "pause()"
    ]
  },
  {
    "q": "What happens if you do not join or detach a std::thread before the destructor runs?",
    "o": [
      "The program terminates",
      "The thread automatically joins",
      "The thread runs in the background",
      "It throws a runtime exception"
    ]
  },
  {
    "q": "What is the advantage of using move semantics in C++?",
    "o": [
      "It avoids deep copying and improves performance",
      "It allows shared ownership",
      "It increases memory usage for performance",
      "It simplifies syntax of object construction"
    ]
  },
  {
    "q": "What is the correct way to access a variable `value` declared inside the namespace `Physics`?",
    "o": [
      "Physics::value",
      "namespace::Physics::value",
      "value::Physics",
      "Physics.value"
    ]
  },
  {
    "q": "What will this program output?",
    "c": "#include <iostream>\nnamespace X {\n    int x = 10;\n}\nnamespace Y {\n    int x = 20;\n}\nusing namespace Y;\nint main() {\n    std::cout << X::x;\n    return 0;\n}",
    "o": [
      "10",
      "20",
      "Compilation Error",
      "0"
    ]
  },
  {
    "q": "Which of the following smart pointers allows only one owner of the resource?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What does `std::weak_ptr` prevent in smart pointer usage?",
    "o": [
      "Circular reference problems",
      "Memory leaks due to improper deletion",
      "Copying ownership between pointers",
      "Multiple deletions of the same object"
    ]
  },
  {
    "q": "What is the output of this code snippet?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    auto sp = std::make_shared<int>(100);\n    std::weak_ptr<int> wp = sp;\n    std::cout << wp.use_count();\n    return 0;\n}",
    "o": [
      "1",
      "0",
      "100",
      "Compilation Error"
    ]
  },
  {
    "q": "Which of the following is true about move constructors?",
    "o": [
      "They transfer ownership of resources from one object to another without copying",
      "They duplicate an object’s content deeply",
      "They are automatically deleted by the compiler",
      "They do not improve performance"
    ]
  },
  {
    "q": "Which standard library header is needed to work with threads in C++11?",
    "o": [
      "<thread>",
      "<concurrency>",
      "<mutex>",
      "<atomic>"
    ]
  },
  {
    "q": "Which of the following statements about `std::thread::detach()` is true?",
    "o": [
      "It allows the thread to run independently from the calling thread",
      "It ensures the thread is joined before program exit",
      "It blocks the current thread until another finishes",
      "It pauses thread execution"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "#include <iostream>\n#include <thread>\nvoid greet() { std::cout << \"Hello from thread!\"; }\nint main() {\n    std::thread t(greet);\n    t.join();\n    return 0;\n}",
    "o": [
      "Hello from thread!",
      "Compilation Error",
      "Thread error",
      "Nothing"
    ]
  },
  {
    "q": "Why is `std::move` used in C++?",
    "o": [
      "To cast an object to an rvalue reference for enabling move semantics",
      "To delete the object immediately",
      "To disable copying of an object",
      "To prevent object slicing"
    ]
  },
  {
    "q": "Which keyword is used to bring a specific name from a namespace into the current scope?",
    "o": [
      "using",
      "namespace",
      "import",
      "include"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nnamespace A { int x = 5; }\nnamespace B { int x = 10; }\nint main() {\n    using namespace B;\n    std::cout << A::x << \" \" << x;\n    return 0;\n}",
    "o": [
      "5 10",
      "10 5",
      "10 10",
      "5 5"
    ]
  },
  {
    "q": "Which smart pointer automatically deletes the managed object when the last `shared_ptr` goes out of scope?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::raw_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What does `std::make_unique<T>()` do?",
    "o": [
      "Creates a `std::unique_ptr<T>` with automatic memory management",
      "Creates a `std::shared_ptr<T>`",
      "Copies a raw pointer into a smart pointer",
      "Initializes a `T*` without memory management"
    ]
  },
  {
    "q": "What is the benefit of move semantics in C++?",
    "o": [
      "It avoids unnecessary deep copies by transferring resources",
      "It increases memory usage by duplicating objects",
      "It prevents object movement entirely",
      "It simplifies threading logic"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "#include <iostream>\n#include <string>\n#include <utility>\nint main() {\n    std::string a = \"Hello\";\n    std::string b = std::move(a);\n    std::cout << b;\n    return 0;\n}",
    "o": [
      "Hello",
      "Compilation Error",
      "a",
      "Move failed"
    ]
  },
  {
    "q": "Which of the following is true about `std::thread` in C++11?",
    "o": [
      "It allows concurrent execution of code in separate threads",
      "It is deprecated and replaced by POSIX threads",
      "It can only be used on Linux systems",
      "It does not support argument passing"
    ]
  },
  {
    "q": "Which header provides `std::mutex` for thread synchronization?",
    "o": [
      "<mutex>",
      "<thread>",
      "<chrono>",
      "<future>"
    ]
  },
  {
    "q": "What does the following code do?",
    "c": "#include <iostream>\n#include <thread>\nvoid func() { std::cout << \"Threading!\"; }\nint main() {\n    std::thread t(func);\n    t.detach();\n    return 0;\n}",
    "o": [
      "Runs the thread independently and lets it finish on its own",
      "Waits for the thread to finish before proceeding",
      "Throws an exception on detach",
      "Terminates the thread immediately"
    ]
  },
  {
    "q": "When should you use `std::move()` in a constructor?",
    "o": [
      "When taking ownership of a resource passed as an rvalue reference",
      "When copying an object for safety",
      "When blocking access to member variables",
      "To avoid memory leaks"
    ]
  },
  {
    "q": "Which of the following is the correct way to access a variable inside a namespace?",
    "o": [
      "NamespaceName::variableName",
      "NamespaceName->variableName",
      "NamespaceName.variableName",
      "NamespaceName::variableName()"
    ]
  },
  {
    "q": "What does this code output?",
    "c": "#include <iostream>\nnamespace Physics {\n    int value = 42;\n}\nint main() {\n    int value = 10;\n    std::cout << Physics::value;\n    return 0;\n}",
    "o": [
      "42",
      "10",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "What is a key advantage of using `std::unique_ptr` over raw pointers?",
    "o": [
      "Automatic memory management and ownership semantics",
      "Faster execution time",
      "Allows multiple owners of the same resource",
      "Improves readability but not memory safety"
    ]
  },
  {
    "q": "Which of the following best describes `std::shared_ptr`?",
    "o": [
      "Smart pointer with reference counting for shared ownership",
      "Smart pointer for exclusive ownership",
      "Pointer with no memory management",
      "Thread-local storage pointer"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> p1 = std::make_unique<int>(100);\n    std::cout << *p1;\n    return 0;\n}",
    "o": [
      "100",
      "0",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "What is the purpose of `std::move`?",
    "o": [
      "It enables move semantics by converting an lvalue into an rvalue reference",
      "It copies values between objects",
      "It prevents object slicing",
      "It locks the object from being moved"
    ]
  },
  {
    "q": "What is true about move constructors in C++?",
    "o": [
      "They transfer ownership of resources instead of copying",
      "They perform deep copies of resources",
      "They are slower than copy constructors",
      "They are implicitly deleted for all user-defined types"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "#include <iostream>\n#include <thread>\nvoid task() {\n    std::cout << \"Running thread\\n\";\n}\nint main() {\n    std::thread t(task);\n    t.join();\n    return 0;\n}",
    "o": [
      "Running thread",
      "Compilation error",
      "No output",
      "Exception thrown"
    ]
  },
  {
    "q": "Which of the following is true about detached threads?",
    "o": [
      "They run independently and cannot be joined",
      "They block the main thread",
      "They always throw exceptions",
      "They must be joined to avoid memory leaks"
    ]
  },
  {
    "q": "Which C++11 keyword creates a thread object that starts execution?",
    "o": [
      "std::thread",
      "std::start_thread",
      "std::spawn",
      "thread_create"
    ]
  },
  {
    "q": "How do you bring all names from a namespace into current scope?",
    "o": [
      "using namespace std;",
      "import std;",
      "namespace std = global;",
      "std::use_all();"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "#include <iostream>\nnamespace Alpha {\n    int x = 50;\n}\nnamespace Beta {\n    int x = 100;\n}\nint main() {\n    std::cout << Alpha::x;\n    return 0;\n}",
    "o": [
      "50",
      "100",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer allows shared ownership of an object?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::raw_ptr",
      "std::weak_ptr"
    ]
  },
  {
    "q": "Which of these is a benefit of `std::unique_ptr`?",
    "o": [
      "Prevents memory leaks by ensuring only one owner",
      "Allows shared ownership among multiple pointers",
      "Supports reference counting",
      "Can be copied freely"
    ]
  },
  {
    "q": "What does this code output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    auto ptr = std::make_shared<int>(25);\n    std::shared_ptr<int> ptr2 = ptr;\n    std::cout << *ptr2;\n    return 0;\n}",
    "o": [
      "25",
      "0",
      "Garbage value",
      "Compilation error"
    ]
  },
  {
    "q": "Which scenario best justifies the use of move semantics?",
    "o": [
      "Transferring ownership of a large resource without copying",
      "Incrementing a value inside a loop",
      "Calling a method without modifying the object",
      "Swapping two integer variables"
    ]
  },
  {
    "q": "What is the output of the following move operation?",
    "c": "#include <iostream>\n#include <utility>\n#include <string>\nint main() {\n    std::string a = \"hello\";\n    std::string b = std::move(a);\n    std::cout << b;\n    return 0;\n}",
    "o": [
      "hello",
      "empty",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "What is true about `std::move`?",
    "o": [
      "It casts an object to an rvalue to enable move semantics",
      "It performs deep copying of data",
      "It automatically destroys the moved-from object",
      "It disables copy constructors"
    ]
  },
  {
    "q": "Which header must be included to use `std::thread`?",
    "o": [
      "<thread>",
      "<threads>",
      "<pthread>",
      "<concurrency>"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "#include <iostream>\n#include <thread>\nvoid greet() { std::cout << \"Hi!\"; }\nint main() {\n    std::thread t(greet);\n    t.join();\n    return 0;\n}",
    "o": [
      "Hi!",
      "Compilation error",
      "Nothing",
      "Segmentation fault"
    ]
  },
  {
    "q": "Which symbol is used to access identifiers inside a namespace?",
    "o": [
      "::",
      "->",
      ".",
      ":="
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\nnamespace Physics {\n    int value = 42;\n}\nint main() {\n    std::cout << Physics::value;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "value",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer automatically deletes the object when the last reference is destroyed?",
    "o": [
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What happens if you copy a std::unique_ptr?",
    "o": [
      "It causes a compilation error",
      "The ownership is transferred silently",
      "It creates a deep copy",
      "It throws a runtime exception"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> p1 = std::make_unique<int>(99);\n    std::cout << *p1;\n    return 0;\n}",
    "o": [
      "99",
      "0",
      "Undefined",
      "Runtime error"
    ]
  },
  {
    "q": "Which C++11 feature allows an object to be transferred without copying?",
    "o": [
      "Move semantics",
      "Copy constructor",
      "Template specialization",
      "Virtual functions"
    ]
  },
  {
    "q": "What does the `std::move` function actually do?",
    "o": [
      "It casts an lvalue into an rvalue",
      "It deletes the original object",
      "It swaps values between two objects",
      "It copies the data to a new location"
    ]
  },
  {
    "q": "What is the expected output of the code below?",
    "c": "#include <iostream>\n#include <utility>\n#include <string>\nint main() {\n    std::string s1 = \"ABC\";\n    std::string s2 = std::move(s1);\n    std::cout << s2;\n    return 0;\n}",
    "o": [
      "ABC",
      "s1",
      "Compilation error",
      "undefined"
    ]
  },
  {
    "q": "Which of the following creates and runs a thread in C++?",
    "o": [
      "std::thread t(myFunction);",
      "thread t = new myFunction();",
      "run_thread(myFunction);",
      "launch_thread(myFunction);"
    ]
  },
  {
    "q": "What is required after starting a thread using `std::thread`?",
    "o": [
      "You should call join() or detach() on it",
      "You must delete the thread manually",
      "Nothing, it joins automatically",
      "You need to sleep the main thread"
    ]
  },
  {
    "q": "Why is the scope resolution operator used with namespaces in C++?",
    "o": [
      "To access members defined inside a specific namespace",
      "To declare global variables",
      "To avoid memory leaks",
      "To allocate heap memory"
    ]
  },
  {
    "q": "What will be printed by the following code?",
    "c": "#include <iostream>\nnamespace A {\n    int value = 10;\n}\nnamespace B {\n    int value = 20;\n}\nint main() {\n    std::cout << A::value;\n    return 0;\n}",
    "o": [
      "10",
      "20",
      "A::value",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer should be used when ownership is shared among multiple parts of code?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What is the primary role of std::weak_ptr?",
    "o": [
      "To prevent circular references with shared_ptr",
      "To provide exclusive ownership of memory",
      "To delete raw pointers safely",
      "To create a deep copy of a pointer"
    ]
  },
  {
    "q": "Which of the following will cause a compilation error?",
    "c": "#include <memory>\nint main() {\n    std::unique_ptr<int> ptr1 = std::make_unique<int>(5);\n    std::unique_ptr<int> ptr2 = ptr1;\n    return 0;\n}",
    "o": [
      "std::unique_ptr<int> ptr2 = ptr1;",
      "std::unique_ptr<int> ptr1 = std::make_unique<int>(5);",
      "return 0;",
      "None of the above"
    ]
  },
  {
    "q": "When are move constructors called in C++?",
    "o": [
      "When an rvalue is used to initialize an object",
      "When two objects are added",
      "When a destructor is called",
      "When overloading a function"
    ]
  },
  {
    "q": "What is the key benefit of move semantics?",
    "o": [
      "Efficient transfer of resources without copying",
      "Type safety",
      "Cleaner syntax",
      "Increased code size"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "#include <iostream>\n#include <vector>\n#include <utility>\nint main() {\n    std::vector<int> v1 = {1, 2, 3};\n    std::vector<int> v2 = std::move(v1);\n    std::cout << v2.size();\n    return 0;\n}",
    "o": [
      "3",
      "0",
      "1",
      "Undefined behavior"
    ]
  },
  {
    "q": "What header must be included to use std::thread?",
    "o": [
      "<thread>",
      "<concurrency>",
      "<pthread>",
      "<threading>"
    ]
  },
  {
    "q": "Which line properly starts a thread that runs the function named `process`?",
    "o": [
      "std::thread t(process);",
      "start_thread(process);",
      "thread_start(process);",
      "process.thread();"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "#include <iostream>\nnamespace X {\n    int x = 100;\n}\nint main() {\n    int x = 50;\n    std::cout << X::x;\n    return 0;\n}",
    "o": [
      "100",
      "50",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is true about std::unique_ptr?",
    "o": [
      "It ensures sole ownership of a dynamically allocated object.",
      "It allows multiple pointers to share ownership of a resource.",
      "It automatically creates deep copies of objects.",
      "It can be copied freely like raw pointers."
    ]
  },
  {
    "q": "Which of the following is the correct way to transfer ownership of a std::unique_ptr?",
    "c": "#include <memory>\nint main() {\n    std::unique_ptr<int> p1 = std::make_unique<int>(10);\n    std::unique_ptr<int> p2 = std::move(p1);\n    return 0;\n}",
    "o": [
      "std::move(p1)",
      "p1.copy()",
      "std::copy(p1)",
      "p1.clone()"
    ]
  },
  {
    "q": "What keyword is used to indicate that a constructor is a move constructor?",
    "o": [
      "&&",
      "&",
      "*",
      "->"
    ]
  },
  {
    "q": "Which scenario best demonstrates the need for move semantics?",
    "o": [
      "Transferring ownership of a large resource without copying",
      "Reading input from console",
      "Performing arithmetic operations",
      "Declaring global constants"
    ]
  },
  {
    "q": "What is the purpose of std::mutex in multithreading?",
    "o": [
      "To prevent data races by synchronizing access to shared resources",
      "To delay thread execution",
      "To terminate all running threads",
      "To allocate memory across threads"
    ]
  },
  {
    "q": "Which line of code creates a thread and waits for it to finish?",
    "c": "#include <thread>\n#include <iostream>\nvoid task() { std::cout << \"Hello\"; }\nint main() {\n    std::thread t(task);\n    t.join();\n    return 0;\n}",
    "o": [
      "t.join();",
      "t.detach();",
      "join(t);",
      "wait(t);"
    ]
  },
  {
    "q": "What will be the state of a std::unique_ptr after it has been moved?",
    "o": [
      "It becomes null and no longer owns any resource",
      "It still holds the resource",
      "It throws an exception when accessed",
      "It retains partial ownership"
    ]
  },
  {
    "q": "Which of the following is a correct way to define a namespace?",
    "o": [
      "namespace physics { int speed = 10; }",
      "namespace = physics { int speed = 10; }",
      "define namespace physics { int speed = 10; }",
      "physics: { int speed = 10; }"
    ]
  },
  {
    "q": "Which type of smart pointer allows access to an object managed by shared_ptr without increasing the reference count?",
    "o": [
      "std::weak_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::raw_ptr"
    ]
  },
  {
    "q": "What is the purpose of the scope resolution operator (::) in C++?",
    "o": [
      "To access a global or namespace-level identifier",
      "To call a member function",
      "To declare a variable",
      "To import a module"
    ]
  },
  {
    "q": "Which smart pointer should be used when multiple owners need to share access to a resource?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::weak_ptr"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nnamespace A {\n    int value = 5;\n}\nnamespace B {\n    int value = 10;\n}\nint main() {\n    std::cout << A::value;\n    return 0;\n}",
    "o": [
      "5",
      "10",
      "Compilation Error",
      "0"
    ]
  },
  {
    "q": "Why is move semantics introduced in modern C++?",
    "o": [
      "To avoid unnecessary deep copies and improve performance",
      "To replace pointers entirely",
      "To enforce pass-by-value behavior",
      "To make functions inline automatically"
    ]
  },
  {
    "q": "Which of the following statements about std::weak_ptr is true?",
    "o": [
      "It does not affect the reference count of std::shared_ptr",
      "It increases the reference count like shared_ptr",
      "It can be used to delete an object",
      "It is used to implement move semantics"
    ]
  },
  {
    "q": "What is required to start a new thread in C++?",
    "o": [
      "Include the <thread> header and call std::thread",
      "Include the <concurrency> header and call run_thread()",
      "Declare a thread block and use thread_start()",
      "Call pthread_create() directly in standard C++"
    ]
  },
  {
    "q": "What happens if std::unique_ptr is copied instead of moved?",
    "o": [
      "Compilation error",
      "Silent copy with shared ownership",
      "The resource is duplicated",
      "The pointer becomes null"
    ]
  },
  {
    "q": "Which of the following operations will compile successfully?",
    "c": "#include <memory>\nint main() {\n    std::unique_ptr<int> a = std::make_unique<int>(42);\n    std::unique_ptr<int> b = std::move(a);\n    return 0;\n}",
    "o": [
      "std::unique_ptr<int> b = std::move(a);",
      "std::unique_ptr<int> b = a;",
      "std::unique_ptr<int> b(a);",
      "b = a;"
    ]
  },
  {
    "q": "Which C++11 feature allows efficient transfer of temporary resources?",
    "o": [
      "Rvalue references",
      "Lvalue references",
      "Const references",
      "Virtual functions"
    ]
  },
  {
    "q": "What must be done to avoid a race condition when multiple threads access shared data?",
    "o": [
      "Use mutexes or locks to synchronize access",
      "Use static variables",
      "Use global variables",
      "Use fast I/O streams"
    ]
  },
  {
    "q": "Which keyword is used to define a namespace in C++?",
    "o": [
      "namespace",
      "module",
      "package",
      "space"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\nnamespace Physics {\n    int value = 9;\n}\nint value = 5;\nint main() {\n    std::cout << ::value << \" \" << Physics::value;\n    return 0;\n}",
    "o": [
      "5 9",
      "9 5",
      "0 9",
      "Compilation error"
    ]
  },
  {
    "q": "What does std::make_shared<T>() do?",
    "o": [
      "Creates a shared_ptr with a new object of type T",
      "Creates a weak_ptr of type T",
      "Creates a unique_ptr and shares it",
      "Allocates raw memory for T"
    ]
  },
  {
    "q": "Which of the following best describes std::move?",
    "o": [
      "It casts an object to an rvalue reference",
      "It copies an object by value",
      "It deletes the object",
      "It locks an object for thread-safe access"
    ]
  },
  {
    "q": "Which smart pointer automatically deletes the object when the last reference goes out of scope?",
    "o": [
      "std::shared_ptr",
      "std::weak_ptr",
      "std::raw_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "#include <memory>\n#include <iostream>\nint main() {\n    std::unique_ptr<int> p1 = std::make_unique<int>(7);\n    std::cout << *p1;\n    return 0;\n}",
    "o": [
      "7",
      "0",
      "Undefined behavior",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following must be avoided to prevent data races in multithreaded C++ programs?",
    "o": [
      "Unsynchronized access to shared resources",
      "Using std::vector in threads",
      "Using mutexes",
      "Creating threads with std::thread"
    ]
  },
  {
    "q": "How can you safely pass ownership of a resource from one std::unique_ptr to another?",
    "o": [
      "Using std::move",
      "Using copy constructor",
      "Using raw pointer assignment",
      "Using std::swap only"
    ]
  },
  {
    "q": "Which of the following is true about std::thread in C++?",
    "o": [
      "Each std::thread object represents a single thread of execution",
      "std::thread is only available in C++98",
      "std::thread cannot be joined",
      "std::thread must be declared global"
    ]
  },
  {
    "q": "What is a major advantage of using smart pointers over raw pointers?",
    "o": [
      "Automatic memory management",
      "Faster code execution",
      "Simplified syntax",
      "Ability to use raw memory more easily"
    ]
  },
  {
    "q": "What does the '::' operator do in C++?",
    "o": [
      "Accesses a member from a namespace or class",
      "Defines a new namespace",
      "Initializes a variable",
      "Indicates a pointer dereference"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nnamespace A { int x = 3; }\nnamespace B { int x = 5; }\nint main() {\n    std::cout << A::x + B::x;\n    return 0;\n}",
    "o": [
      "8",
      "3",
      "5",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer should be used when ownership must be shared?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What does std::unique_ptr prevent?",
    "o": [
      "Multiple ownership of a resource",
      "Object construction",
      "Object destruction",
      "Copying by value"
    ]
  },
  {
    "q": "Which of the following best defines move semantics?",
    "o": [
      "Transfer of ownership without copying",
      "Copying values between objects",
      "Allocation of memory on the heap",
      "Binding to const references"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "#include <iostream>\n#include <utility>\nstd::string getName() {\n    std::string name = \"Alice\";\n    return std::move(name);\n}\nint main() {\n    std::string n = getName();\n    std::cout << n;\n    return 0;\n}",
    "o": [
      "Alice",
      "Compilation error",
      "Undefined",
      "Move constructor not defined"
    ]
  },
  {
    "q": "Which header is required for using std::thread?",
    "o": [
      "<thread>",
      "<concurrency>",
      "<multithread>",
      "<system>"
    ]
  },
  {
    "q": "What happens if you don’t join a thread before the program exits?",
    "o": [
      "The thread is terminated abruptly",
      "The program waits for the thread to finish",
      "The compiler optimizes it",
      "Nothing happens"
    ]
  },
  {
    "q": "Which smart pointer does not manage the lifetime of the object directly?",
    "o": [
      "std::weak_ptr",
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "Which of the following can cause a data race?",
    "o": [
      "Multiple threads accessing the same variable without synchronization",
      "Using std::mutex",
      "Using const variables in threads",
      "Spawning multiple threads"
    ]
  },
  {
    "q": "Which of the following ensures that only one thread can access a critical section at a time in C++?",
    "o": [
      "std::mutex",
      "std::thread",
      "std::lock_guard",
      "std::unique_lock"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> p1 = std::make_unique<int>(42);\n    // std::unique_ptr<int> p2 = p1; // invalid\n    std::cout << *p1;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "Garbage value",
      "Compilation error"
    ]
  },
  {
    "q": "What is the purpose of std::move in C++?",
    "o": [
      "To enable move semantics and avoid deep copies",
      "To copy values between objects",
      "To destroy an object explicitly",
      "To allocate memory on the heap"
    ]
  },
  {
    "q": "Which of these can be used to reference a symbol inside a namespace?",
    "o": [
      "Scope resolution operator (::)",
      "Dot operator (.)",
      "Arrow operator (->)",
      "Tilde operator (~)"
    ]
  },
  {
    "q": "Which smart pointer allows multiple shared owners and reference counting?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <thread>\nvoid task() { std::cout << \"Running in thread\\n\"; }\nint main() {\n    std::thread t(task);\n    t.join();\n    return 0;\n}",
    "o": [
      "Running in thread",
      "Compilation error",
      "Segmentation fault",
      "No output"
    ]
  },
  {
    "q": "Which of the following is true about std::weak_ptr?",
    "o": [
      "It does not increase the reference count of the object",
      "It owns the object",
      "It automatically deletes the object",
      "It is a replacement for raw pointers"
    ]
  },
  {
    "q": "Which of the following best describes the relationship between std::unique_ptr and std::move?",
    "o": [
      "std::move transfers ownership of a unique_ptr",
      "std::move copies a unique_ptr",
      "std::move increases the reference count",
      "std::move disables object destruction"
    ]
  },
  {
    "q": "Which of the following ensures automatic destruction of a dynamic object when the last shared_ptr goes out of scope?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What is the purpose of std::lock_guard?",
    "o": [
      "To acquire and release a mutex automatically",
      "To create a thread-safe object",
      "To prevent deadlock detection",
      "To allocate dynamic memory for threads"
    ]
  },
  {
    "q": "Which keyword is used to access a symbol from a namespace explicitly?",
    "o": [
      "namespace::symbol",
      "namespace.symbol",
      "symbol::namespace",
      "symbol->namespace"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nnamespace Math {\n    int add(int a, int b) { return a + b; }\n}\nint main() {\n    std::cout << Math::add(3, 4);\n    return 0;\n}",
    "o": [
      "7",
      "34",
      "Error: function not found",
      "0"
    ]
  },
  {
    "q": "Which smart pointer is best suited when ownership must be shared among multiple entities?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What is the purpose of std::move when used with a resource-managing object?",
    "o": [
      "To transfer ownership without copying",
      "To reset the resource",
      "To delete the resource",
      "To clone the resource"
    ]
  },
  {
    "q": "Which of the following will cause a compilation error?",
    "c": "#include <memory>\nint main() {\n    std::unique_ptr<int> p1 = std::make_unique<int>(10);\n    std::unique_ptr<int> p2 = p1;\n    return 0;\n}",
    "o": [
      "Compilation error due to copy of unique_ptr",
      "Program prints 10",
      "Runtime segmentation fault",
      "No output"
    ]
  },
  {
    "q": "Which thread operation ensures that the main thread waits for the spawned thread to complete?",
    "o": [
      "join()",
      "detach()",
      "sleep_for()",
      "terminate()"
    ]
  },
  {
    "q": "What is a potential danger if two threads modify the same variable simultaneously without synchronization?",
    "o": [
      "Race condition",
      "Deadlock",
      "Memory leak",
      "Stack overflow"
    ]
  },
  {
    "q": "What does std::weak_ptr help prevent in a shared_ptr reference cycle?",
    "o": [
      "Memory leak",
      "Null pointer dereference",
      "Stack overflow",
      "Thread contention"
    ]
  },
  {
    "q": "Which feature of C++11 enables resources to be moved instead of copied?",
    "o": [
      "Rvalue references",
      "Function overloading",
      "Smart pointers",
      "Virtual functions"
    ]
  },
  {
    "q": "Which of the following can create a thread that runs a given function?",
    "o": [
      "std::thread t(func);",
      "thread t = start_thread(func);",
      "start(func);",
      "std::launch(func);"
    ]
  },
  {
    "q": "What is the correct way to access a variable 'x' defined in the 'Physics' namespace?",
    "o": [
      "Physics::x",
      "x::Physics",
      "Physics.x",
      "Physics->x"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nnamespace A {\n    int value = 100;\n}\nnamespace B {\n    int value = 200;\n}\nint main() {\n    using namespace A;\n    std::cout << value;\n    return 0;\n}",
    "o": [
      "100",
      "200",
      "Compilation error due to ambiguity",
      "0"
    ]
  },
  {
    "q": "Which of the following is true about std::unique_ptr?",
    "o": [
      "It ensures sole ownership of a dynamically allocated object",
      "It allows multiple shared ownerships",
      "It automatically copies the pointer",
      "It uses reference counting"
    ]
  },
  {
    "q": "Which standard header is required for using std::shared_ptr?",
    "o": [
      "<memory>",
      "<shared_ptr>",
      "<pointer>",
      "<stdcpp>"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> sp1 = std::make_shared<int>(5);\n    std::shared_ptr<int> sp2 = sp1;\n    std::cout << *sp2;\n    return 0;\n}",
    "o": [
      "5",
      "0",
      "Runtime error",
      "Compilation error"
    ]
  },
  {
    "q": "What will happen if a std::unique_ptr is copied?",
    "o": [
      "Compilation error",
      "The original pointer is set to null",
      "Both pointers own the resource",
      "Memory leak occurs"
    ]
  },
  {
    "q": "Which of the following allows transferring ownership of a resource?",
    "o": [
      "std::move",
      "std::copy",
      "std::transfer",
      "std::assign"
    ]
  },
  {
    "q": "What does the following code do?",
    "c": "#include <iostream>\n#include <utility>\nint main() {\n    std::string s1 = \"Hello\";\n    std::string s2 = std::move(s1);\n    std::cout << s2;\n    return 0;\n}",
    "o": [
      "Hello",
      "Error: std::move can't be used with std::string",
      "Nothing",
      "0"
    ]
  },
  {
    "q": "Which header is needed for std::thread in C++?",
    "o": [
      "<thread>",
      "<pthread>",
      "<chrono>",
      "<concurrency>"
    ]
  },
  {
    "q": "What is the purpose of std::mutex in multithreading?",
    "o": [
      "To prevent race conditions by locking shared resources",
      "To create threads",
      "To measure time intervals",
      "To detach threads from main execution"
    ]
  },
  {
    "q": "Which of the following best describes the purpose of a namespace in C++?",
    "o": [
      "To avoid name conflicts in large projects",
      "To allocate memory for variables",
      "To define a new class",
      "To manage file input/output"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "#include <iostream>\nnamespace Alpha {\n    int x = 42;\n}\nint main() {\n    int x = 10;\n    std::cout << Alpha::x;\n    return 0;\n}",
    "o": [
      "42",
      "10",
      "Compilation Error",
      "0"
    ]
  },
  {
    "q": "Which smart pointer does not use reference counting?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::linked_ptr"
    ]
  },
  {
    "q": "What does std::weak_ptr help prevent?",
    "o": [
      "Cyclic reference in shared pointers",
      "Memory allocation",
      "Race conditions",
      "Smart pointer initialization"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    auto ptr = std::make_unique<int>(100);\n    std::cout << *ptr;\n    return 0;\n}",
    "o": [
      "100",
      "0",
      "Compilation Error",
      "Undefined"
    ]
  },
  {
    "q": "Which of the following statements is true about move semantics in C++?",
    "o": [
      "They transfer ownership of resources instead of copying",
      "They always perform a deep copy",
      "They are used only for integers",
      "They prevent object reuse"
    ]
  },
  {
    "q": "What does the following code demonstrate?",
    "c": "#include <iostream>\n#include <string>\n#include <utility>\nint main() {\n    std::string a = \"ABC\";\n    std::string b = std::move(a);\n    std::cout << b;\n    return 0;\n}",
    "o": [
      "Move semantics",
      "Copy semantics",
      "Smart pointers",
      "Namespace usage"
    ]
  },
  {
    "q": "What is the correct way to create a thread in modern C++?",
    "o": [
      "std::thread t(myFunction);",
      "thread.create(myFunction);",
      "start_thread(myFunction);",
      "std::start(myFunction);"
    ]
  },
  {
    "q": "What happens if two threads access the same data simultaneously without synchronization?",
    "o": [
      "It can cause race conditions",
      "The program will run faster",
      "Compilation error will occur",
      "It guarantees data integrity"
    ]
  },
  {
    "q": "Which function is used to wait for a thread to finish execution?",
    "o": [
      "join()",
      "wait()",
      "exit()",
      "terminate()"
    ]
  },
  {
    "q": "Which scope resolution usage is correct to access a variable from a namespace?",
    "o": [
      "MyNamespace::myVar",
      "myVar::MyNamespace",
      "MyNamespace->myVar",
      "MyNamespace.myVar"
    ]
  },
  {
    "q": "What will this program print?",
    "c": "#include <iostream>\nnamespace A {\n    int val = 1;\n}\nnamespace B {\n    int val = 2;\n}\nint main() {\n    std::cout << A::val << B::val;\n    return 0;\n}",
    "o": [
      "12",
      "21",
      "Error",
      "11"
    ]
  },
  {
    "q": "What happens when you pass a std::unique_ptr by value?",
    "o": [
      "Ownership is transferred to the function",
      "A copy of the unique_ptr is created",
      "It throws a compilation error",
      "It creates a shared reference"
    ]
  },
  {
    "q": "Which header must be included to use std::shared_ptr?",
    "o": [
      "<memory>",
      "<utility>",
      "<shared_ptr>",
      "<ptr>"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> p1 = std::make_shared<int>(99);\n    std::shared_ptr<int> p2 = p1;\n    std::cout << *p2;\n    return 0;\n}",
    "o": [
      "99",
      "0",
      "Error",
      "Undefined behavior"
    ]
  },
  {
    "q": "What keyword is used to enable move semantics in custom classes?",
    "o": [
      "std::move",
      "std::copy",
      "std::forward",
      "std::clone"
    ]
  },
  {
    "q": "What does the following line do?\nstd::string b = std::move(a);",
    "o": [
      "Transfers ownership of a's resources to b",
      "Copies a to b",
      "Deletes a",
      "References a without copying"
    ]
  },
  {
    "q": "Which of these is a potential hazard when using multithreading?",
    "o": [
      "Race condition",
      "Memory leak",
      "Syntax error",
      "Infinite loop"
    ]
  },
  {
    "q": "What will the following code print (assuming no synchronization)?",
    "c": "#include <iostream>\n#include <thread>\nvoid task() { std::cout << \"Run \"; }\nint main() {\n    std::thread t1(task);\n    std::thread t2(task);\n    t1.join();\n    t2.join();\n    return 0;\n}",
    "o": [
      "Run Run ",
      "RunRun",
      "Run ",
      "Compile-time error"
    ]
  },
  {
    "q": "Which is true about std::thread in C++11?",
    "o": [
      "It creates a new thread of execution",
      "It replaces the main thread",
      "It shares memory automatically",
      "It only works with static functions"
    ]
  },
  {
    "q": "Which operator is used for scope resolution in C++?",
    "o": [
      "::",
      "->",
      ".",
      ":="
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nnamespace Alpha {\n    int value = 100;\n}\nint main() {\n    using Alpha::value;\n    std::cout << value;\n    return 0;\n}",
    "o": [
      "100",
      "0",
      "Compilation error",
      "Undefined behavior"
    ]
  },
  {
    "q": "What is a key difference between std::unique_ptr and std::shared_ptr?",
    "o": [
      "unique_ptr has sole ownership; shared_ptr allows multiple owners",
      "shared_ptr has better performance than unique_ptr",
      "unique_ptr uses reference counting",
      "shared_ptr cannot be copied"
    ]
  },
  {
    "q": "Which of the following will correctly create a std::unique_ptr?",
    "o": [
      "std::unique_ptr<int> p = std::make_unique<int>(10);",
      "std::unique_ptr<int> p = new int(10);",
      "std::unique_ptr<int> p = make_shared<int>(10);",
      "std::unique_ptr<int> p(10);"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> ptr1 = std::make_unique<int>(7);\n    std::unique_ptr<int> ptr2 = std::move(ptr1);\n    std::cout << *ptr2;\n    return 0;\n}",
    "o": [
      "7",
      "0",
      "Runtime error",
      "Compilation error"
    ]
  },
  {
    "q": "Why are move constructors important in C++?",
    "o": [
      "To optimize performance by avoiding deep copies",
      "To prevent runtime errors",
      "To allow copying of const objects",
      "To manage heap memory explicitly"
    ]
  },
  {
    "q": "What does this code snippet represent?",
    "c": "#include <iostream>\n#include <utility>\nint main() {\n    std::string a = \"hello\";\n    std::string b = std::move(a);\n    std::cout << b;\n    return 0;\n}",
    "o": [
      "hello",
      "a",
      "b",
      "empty"
    ]
  },
  {
    "q": "What must be called on a std::thread object to wait for its completion?",
    "o": [
      "join()",
      "wait()",
      "finish()",
      "close()"
    ]
  },
  {
    "q": "What is the output if both threads execute concurrently?",
    "c": "#include <iostream>\n#include <thread>\nvoid func() { std::cout << \"Thread \"; }\nint main() {\n    std::thread t1(func);\n    std::thread t2(func);\n    t1.join(); t2.join();\n    return 0;\n}",
    "o": [
      "Thread Thread ",
      "ThreadThread",
      "Thread ",
      "No output"
    ]
  },
  {
    "q": "Which is true about std::move?",
    "o": [
      "It casts an object to an rvalue reference",
      "It moves the object physically in memory",
      "It deletes the source object",
      "It is required for copy constructors"
    ]
  },
  {
    "q": "Why are namespaces useful in C++?",
    "o": [
      "To avoid naming conflicts in large projects",
      "To speed up code execution",
      "To improve memory management",
      "To enable runtime polymorphism"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\nnamespace X {\n  int var = 5;\n}\nint main() {\n  std::cout << X::var;\n  return 0;\n}",
    "o": [
      "5",
      "0",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "Which of the following is a correct use of std::shared_ptr?",
    "o": [
      "std::shared_ptr<int> ptr = std::make_shared<int>(42);",
      "std::shared_ptr<int> ptr = new int(42);",
      "std::shared_ptr<int> ptr(42);",
      "std::shared_ptr<int> ptr = make_unique<int>(42);"
    ]
  },
  {
    "q": "What is a key characteristic of std::weak_ptr?",
    "o": [
      "It does not increase the reference count of shared_ptr",
      "It deletes the managed object automatically",
      "It can be used with unique_ptr",
      "It owns the resource exclusively"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n  auto ptr1 = std::make_shared<int>(10);\n  auto ptr2 = ptr1;\n  std::cout << *ptr2;\n  return 0;\n}",
    "o": [
      "10",
      "0",
      "Garbage value",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following best describes move semantics?",
    "o": [
      "Transfers ownership of resources from one object to another",
      "Copies data by value",
      "Forces a deep copy of resources",
      "Creates a duplicate in memory"
    ]
  },
  {
    "q": "What is the purpose of std::move in C++?",
    "o": [
      "To cast an object as an rvalue and enable move semantics",
      "To delete the object and free memory",
      "To convert a pointer to an object",
      "To guarantee thread-safety"
    ]
  },
  {
    "q": "What does this code print?",
    "c": "#include <iostream>\n#include <string>\n#include <utility>\nint main() {\n  std::string a = \"Hi\";\n  std::string b = std::move(a);\n  std::cout << b;\n  return 0;\n}",
    "o": [
      "Hi",
      "a",
      "Empty",
      "Undefined"
    ]
  },
  {
    "q": "Which header is required for std::thread?",
    "o": [
      "<thread>",
      "<pthread.h>",
      "<concurrency>",
      "<threading>"
    ]
  },
  {
    "q": "What happens if you forget to join a thread in C++?",
    "o": [
      "The program may terminate or throw an exception",
      "It runs fine and the thread is automatically joined",
      "The compiler throws an error",
      "The thread is silently detached"
    ]
  },
  {
    "q": "Which scope resolution operator allows accessing a global variable hidden by a local one?",
    "o": [
      "::globalVar",
      ".globalVar",
      "#globalVar",
      "->globalVar"
    ]
  },
  {
    "q": "What is the output of the following C++ code?",
    "c": "#include <iostream>\nnamespace A {\n  int value = 100;\n}\nnamespace B {\n  int value = 200;\n}\nint main() {\n  std::cout << A::value;\n  return 0;\n}",
    "o": [
      "100",
      "200",
      "0",
      "Compilation Error"
    ]
  },
  {
    "q": "Which smart pointer allows unique ownership and transfers ownership using std::move?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What is the main purpose of std::weak_ptr?",
    "o": [
      "To prevent circular references with std::shared_ptr",
      "To manage unique ownership of resources",
      "To handle ownership transfer",
      "To lock shared resources in threads"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n  std::unique_ptr<int> ptr1 = std::make_unique<int>(20);\n  std::unique_ptr<int> ptr2 = std::move(ptr1);\n  std::cout << *ptr2;\n  return 0;\n}",
    "o": [
      "20",
      "0",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "Which of the following is true about move constructors?",
    "o": [
      "They take an rvalue reference as a parameter",
      "They are called on const objects",
      "They are used to perform deep copies",
      "They require manual memory allocation"
    ]
  },
  {
    "q": "Which function explicitly enables move semantics in C++?",
    "o": [
      "std::move()",
      "std::copy()",
      "std::forward()",
      "std::swap()"
    ]
  },
  {
    "q": "What does this code print?",
    "c": "#include <iostream>\n#include <string>\n#include <utility>\nint main() {\n  std::string str1 = \"World\";\n  std::string str2 = std::move(str1);\n  std::cout << str2;\n  return 0;\n}",
    "o": [
      "World",
      "str1",
      "0",
      "Undefined"
    ]
  },
  {
    "q": "Which header provides std::mutex and std::thread in C++?",
    "o": [
      "<thread>",
      "<future>",
      "<atomic>",
      "<condition_variable>"
    ]
  },
  {
    "q": "What is the purpose of std::thread::join()?",
    "o": [
      "To wait for the thread to finish before continuing",
      "To detach the thread from the calling thread",
      "To kill a thread forcefully",
      "To restart a finished thread"
    ]
  },
  {
    "q": "What is the purpose of the scope resolution operator (::) in C++?",
    "o": [
      "To access identifiers from a specific namespace or class scope",
      "To define a pointer",
      "To create a reference variable",
      "To declare a macro"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nnamespace Math {\n    int value = 42;\n}\nint value = 10;\nint main() {\n    std::cout << Math::value;\n    return 0;\n}",
    "o": [
      "42",
      "10",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following smart pointers automatically destroys the managed object when no more shared_ptrs point to it?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::weak_ptr"
    ]
  },
  {
    "q": "Which smart pointer is non-copyable but movable?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> sp1 = std::make_shared<int>(100);\n    std::shared_ptr<int> sp2 = sp1;\n    std::cout << *sp2;\n    return 0;\n}",
    "o": [
      "100",
      "0",
      "Garbage value",
      "Compilation error"
    ]
  },
  {
    "q": "What does move semantics primarily improve in C++?",
    "o": [
      "Performance by eliminating unnecessary deep copies",
      "Code readability",
      "Support for dynamic typing",
      "Runtime type checking"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <utility>\nint main() {\n    std::string a = \"Hello\";\n    std::string b = std::move(a);\n    std::cout << b;\n    return 0;\n}",
    "o": [
      "Hello",
      "a",
      "Nothing",
      "Compilation Error"
    ]
  },
  {
    "q": "What is the correct way to launch a thread in C++?",
    "o": [
      "std::thread t(myFunction);",
      "thread::std t(myFunction);",
      "thread t = new std::thread(myFunction);",
      "launch thread(myFunction);"
    ]
  },
  {
    "q": "What happens if std::thread::join() is not called and the main thread ends?",
    "o": [
      "The program may terminate unexpectedly",
      "The thread will continue running safely",
      "The thread is automatically joined",
      "Compilation error occurs"
    ]
  },
  {
    "q": "Which of the following is used to prevent data races in multithreaded C++ programs?",
    "o": [
      "std::mutex",
      "std::unique_ptr",
      "std::forward",
      "std::move"
    ]
  },
  {
    "q": "Which keyword is used to bring a specific namespace into the current scope?",
    "o": [
      "using",
      "include",
      "namespace",
      "public"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\nnamespace X { int num = 7; }\nnamespace Y { int num = 10; }\nint main() {\n    std::cout << X::num;\n    return 0;\n}",
    "o": [
      "7",
      "10",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following smart pointers provides reference counting?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::weak_ptr"
    ]
  },
  {
    "q": "Which smart pointer is used when you want a non-owning reference to a shared object?",
    "o": [
      "std::weak_ptr",
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What is the output of the code below?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    auto ptr = std::make_unique<int>(50);\n    std::cout << *ptr;\n    return 0;\n}",
    "o": [
      "50",
      "0",
      "Compilation error",
      "Garbage value"
    ]
  },
  {
    "q": "Which of the following best describes move semantics?",
    "o": [
      "It transfers ownership of resources instead of copying them",
      "It enables parallel execution",
      "It delays execution of expressions",
      "It locks shared resources"
    ]
  },
  {
    "q": "What is the purpose of std::move?",
    "o": [
      "To enable move semantics by converting an lvalue to an rvalue",
      "To make a deep copy of an object",
      "To delete dynamic memory",
      "To transfer a thread"
    ]
  },
  {
    "q": "What is the output of this code snippet?",
    "c": "#include <iostream>\n#include <string>\nint main() {\n    std::string a = \"first\";\n    std::string b = std::move(a);\n    std::cout << a.empty();\n    return 0;\n}",
    "o": [
      "1",
      "0",
      "first",
      "Compilation error"
    ]
  },
  {
    "q": "Which header is required to use std::thread?",
    "o": [
      "<thread>",
      "<mutex>",
      "<atomic>",
      "<chrono>"
    ]
  },
  {
    "q": "What is the purpose of std::lock_guard in multithreading?",
    "o": [
      "To automatically acquire and release a mutex using RAII",
      "To create new threads",
      "To stop a running thread",
      "To pause a thread for some time"
    ]
  },
  {
    "q": "Which operator is used to access a member of a namespace?",
    "o": [
      "::",
      ".",
      "->",
      "&&"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\nnamespace A {\n  int x = 100;\n}\nint main() {\n  std::cout << A::x;\n  return 0;\n}",
    "o": [
      "100",
      "0",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "Which smart pointer type ensures exclusive ownership of a dynamically allocated object?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What happens when the last std::shared_ptr managing an object is destroyed?",
    "o": [
      "The managed object is deleted",
      "The program crashes",
      "The object becomes const",
      "Nothing happens"
    ]
  },
  {
    "q": "What is the output of this code snippet?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n  std::shared_ptr<int> p1 = std::make_shared<int>(42);\n  std::shared_ptr<int> p2 = p1;\n  std::cout << *p2;\n  return 0;\n}",
    "o": [
      "42",
      "0",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "What keyword is used to define a move constructor?",
    "o": [
      "&&",
      "const",
      "*",
      "->"
    ]
  },
  {
    "q": "Which of the following best describes move semantics in C++?",
    "o": [
      "It avoids deep copy and transfers ownership of resources",
      "It allows copying of large arrays efficiently",
      "It disables constructors",
      "It increases memory usage"
    ]
  },
  {
    "q": "What will be the output of the following move operation?",
    "c": "#include <iostream>\n#include <string>\nint main() {\n  std::string s1 = \"hello\";\n  std::string s2 = std::move(s1);\n  std::cout << s2;\n  return 0;\n}",
    "o": [
      "hello",
      "s1",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following headers must be included to use std::thread?",
    "o": [
      "<thread>",
      "<future>",
      "<condition_variable>",
      "<mutex>"
    ]
  },
  {
    "q": "What is the correct way to create a new thread executing a function 'runTask'?",
    "o": [
      "std::thread t(runTask);",
      "thread t = new runTask();",
      "std::thread::run(runTask);",
      "createThread(runTask);"
    ]
  },
  {
    "q": "Which of the following is true about unnamed (anonymous) namespaces in C++?",
    "o": [
      "They limit the scope of the declared identifiers to the current translation unit.",
      "They allow reuse of the same variable name globally.",
      "They automatically import all standard functions.",
      "They can be accessed using the 'global::' prefix."
    ]
  },
  {
    "q": "What does the scope resolution operator (::) do in C++?",
    "o": [
      "It accesses global or namespace-level identifiers.",
      "It creates a new namespace.",
      "It links two classes together.",
      "It declares a new scope."
    ]
  },
  {
    "q": "What is the output of this code snippet using smart pointers?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n  std::unique_ptr<int> ptr = std::make_unique<int>(20);\n  std::cout << *ptr;\n  return 0;\n}",
    "o": [
      "20",
      "0",
      "nullptr",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is a key difference between std::unique_ptr and std::shared_ptr?",
    "o": [
      "std::unique_ptr has sole ownership, while std::shared_ptr allows shared ownership.",
      "std::unique_ptr can be copied, while std::shared_ptr cannot.",
      "std::shared_ptr can’t be used with custom deleters.",
      "std::unique_ptr is slower than std::shared_ptr."
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "#include <iostream>\n#include <utility>\nstd::string createMessage() {\n  return \"Moved Message\";\n}\nint main() {\n  std::string msg = std::move(createMessage());\n  std::cout << msg;\n  return 0;\n}",
    "o": [
      "Moved Message",
      "createMessage",
      "Compilation error",
      "Undefined behavior"
    ]
  },
  {
    "q": "Which feature of C++11 allows transferring ownership of resources without copying them?",
    "o": [
      "Move Semantics",
      "Copy Constructors",
      "RAII",
      "Const References"
    ]
  },
  {
    "q": "Which of the following best describes a use-case of std::weak_ptr?",
    "o": [
      "To break circular references created by std::shared_ptr.",
      "To manage resource ownership exclusively.",
      "To create a deep copy of raw pointers.",
      "To automatically delete resources when out of scope."
    ]
  },
  {
    "q": "What will this multithreading code output?",
    "c": "#include <iostream>\n#include <thread>\nvoid task() { std::cout << \"Task running\\n\"; }\nint main() {\n  std::thread t(task);\n  t.join();\n  return 0;\n}",
    "o": [
      "Task running",
      "Compilation error",
      "Program crash",
      "Nothing"
    ]
  },
  {
    "q": "Which function must be called on a std::thread object to ensure it completes before main() exits?",
    "o": [
      "join()",
      "close()",
      "wait()",
      "sync()"
    ]
  },
  {
    "q": "What is a common consequence of not calling join() or detach() on a std::thread?",
    "o": [
      "The program may terminate abnormally.",
      "The thread will run in the background forever.",
      "All variables will be locked.",
      "It automatically detaches the thread."
    ]
  },
  {
    "q": "How can you access a global variable when a local variable has the same name?",
    "o": [
      "::variableName",
      "global.variableName",
      "this->variableName",
      "scope.variableName"
    ]
  },
  {
    "q": "What does std::make_shared<T>() do?",
    "o": [
      "Creates and returns a shared_ptr that points to a newly allocated object of type T",
      "Creates a raw pointer for T",
      "Deletes existing shared_ptr",
      "Creates a deep copy of shared_ptr"
    ]
  },
  {
    "q": "Which of the following best demonstrates move semantics?",
    "c": "#include <iostream>\n#include <utility>\n#include <vector>\nint main() {\n  std::vector<int> a = {1, 2, 3};\n  std::vector<int> b = std::move(a);\n  std::cout << b.size();\n  return 0;\n}",
    "o": [
      "3",
      "0",
      "undefined",
      "Segmentation fault"
    ]
  },
  {
    "q": "What is the main purpose of move semantics?",
    "o": [
      "To avoid unnecessary deep copies and improve performance",
      "To increase memory usage for safety",
      "To create copies automatically",
      "To disable constructors"
    ]
  },
  {
    "q": "Which smart pointer provides exclusive ownership?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "Which namespace includes the C++ Standard Library components?",
    "o": [
      "std",
      "stdlib",
      "cxx",
      "cpp"
    ]
  },
  {
    "q": "Which function is used to detach a thread from the calling thread?",
    "o": [
      "detach()",
      "exit()",
      "terminate()",
      "yield()"
    ]
  },
  {
    "q": "Which of the following ensures that a thread completes before moving on?",
    "o": [
      "join()",
      "sleep()",
      "sync()",
      "attach()"
    ]
  },
  {
    "q": "What is the output of this multithreading example?",
    "c": "#include <iostream>\n#include <thread>\nvoid fun() { std::cout << \"Thread!\\n\"; }\nint main() {\n  std::thread t1(fun);\n  t1.join();\n  return 0;\n}",
    "o": [
      "Thread!",
      "Error",
      "Nothing",
      "Fun"
    ]
  },
  {
    "q": "Which of the following is true about std::weak_ptr?",
    "o": [
      "It does not contribute to the reference count.",
      "It is used for exclusive ownership.",
      "It throws exceptions on null access.",
      "It is faster than raw pointers."
    ]
  },
  {
    "q": "What is the purpose of the scope resolution operator (::) in C++?",
    "o": [
      "To access global variables or members from a namespace",
      "To call a constructor",
      "To define a lambda function",
      "To create a smart pointer"
    ]
  },
  {
    "q": "Which of the following creates a unique_ptr to an int initialized to 42?",
    "o": [
      "std::unique_ptr<int> p = std::make_unique<int>(42);",
      "std::unique_ptr<int> p = new int(42);",
      "std::shared_ptr<int> p = make_unique<int>(42);",
      "std::weak_ptr<int> p = make_unique<int>(42);"
    ]
  },
  {
    "q": "What happens to a unique_ptr after moving it to another unique_ptr?",
    "o": [
      "It becomes null and relinquishes ownership",
      "It throws an exception",
      "It keeps ownership",
      "It resets to a new value"
    ]
  },
  {
    "q": "Which header is required to use std::thread in C++?",
    "o": [
      "#include <thread>",
      "#include <pthread>",
      "#include <concurrency>",
      "#include <future>"
    ]
  },
  {
    "q": "Which of the following best describes std::move?",
    "o": [
      "It casts an object to an rvalue to enable move semantics",
      "It deletes an object safely",
      "It copies an object into a new location",
      "It swaps two pointers"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> sp1 = std::make_shared<int>(10);\n    std::shared_ptr<int> sp2 = sp1;\n    std::cout << sp1.use_count();\n    return 0;\n}",
    "o": [
      "2",
      "1",
      "0",
      "undefined"
    ]
  },
  {
    "q": "Which of the following is NOT true about std::unique_ptr?",
    "o": [
      "It allows shared ownership.",
      "It cannot be copied.",
      "It can be moved.",
      "It automatically deletes the object it owns."
    ]
  },
  {
    "q": "Which function transfers ownership from one unique_ptr to another?",
    "o": [
      "std::move()",
      "std::copy()",
      "std::forward()",
      "std::assign()"
    ]
  },
  {
    "q": "Which namespace must you use to access standard C++ features?",
    "o": [
      "std",
      "cpp",
      "cxx",
      "global"
    ]
  },
  {
    "q": "What is a potential risk of not calling join() or detach() on a std::thread?",
    "o": [
      "The program will terminate at runtime",
      "It will compile with a warning",
      "The thread will silently fail",
      "It causes stack overflow"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "#include <iostream>\nnamespace A {\n    int value = 5;\n}\nnamespace B {\n    int value = 10;\n}\nint main() {\n    std::cout << A::value << std::endl;\n    return 0;\n}",
    "o": [
      "5",
      "10",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following smart pointers provides reference counting?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What does 'std::move' do to the original object?",
    "o": [
      "Casts it to an rvalue and allows moving resources",
      "Deletes the object",
      "Creates a copy of the object",
      "Forces the object to null"
    ]
  },
  {
    "q": "Which statement is true about std::thread?",
    "o": [
      "It allows concurrent execution by creating a new thread of execution.",
      "It can only execute after main() finishes.",
      "It is only available in C++98.",
      "It does not require headers to use."
    ]
  },
  {
    "q": "How do you correctly create a thread that runs the function 'print'?",
    "o": [
      "std::thread t(print);",
      "thread t = print();",
      "std::make_thread(print);",
      "start_thread(print);"
    ]
  },
  {
    "q": "Which of the following is a valid use of the scope resolution operator?",
    "o": [
      "To define a class method outside its declaration",
      "To define a variable inside a function",
      "To include a library",
      "To inherit a class"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> p1(new int(100));\n    std::unique_ptr<int> p2 = std::move(p1);\n    std::cout << *p2;\n    return 0;\n}",
    "o": [
      "100",
      "0",
      "Undefined behavior",
      "Runtime error"
    ]
  },
  {
    "q": "Which C++11 feature enables safe and automatic memory deallocation?",
    "o": [
      "Smart pointers",
      "Raw pointers",
      "Macros",
      "Virtual destructors"
    ]
  },
  {
    "q": "What does 'join()' do in multithreading?",
    "o": [
      "Waits for the thread to finish execution",
      "Starts the thread",
      "Pauses the thread forever",
      "Detaches the thread"
    ]
  },
  {
    "q": "Which smart pointer avoids circular references?",
    "o": [
      "std::weak_ptr",
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "Which keyword is used to access a global variable hidden by a local variable?",
    "o": [
      "::",
      "global",
      "scope",
      "extern"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "#include <iostream>\nnamespace outer {\n    int x = 20;\n    namespace inner {\n        int x = 10;\n    }\n}\nint main() {\n    std::cout << outer::inner::x;\n    return 0;\n}",
    "o": [
      "10",
      "20",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer allows ownership transfer but does not support copy semantics?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What is the purpose of std::move?",
    "o": [
      "To cast an object to an rvalue to enable move semantics",
      "To deallocate memory manually",
      "To copy large objects efficiently",
      "To convert raw pointers into smart pointers"
    ]
  },
  {
    "q": "What is a potential issue when two shared_ptrs reference each other?",
    "o": [
      "Memory leak due to circular reference",
      "Segmentation fault",
      "Undefined behavior",
      "Automatic deallocation"
    ]
  },
  {
    "q": "What is the output of the code?",
    "c": "#include <iostream>\n#include <thread>\nvoid run() { std::cout << \"Thread running\"; }\nint main() {\n    std::thread t(run);\n    t.join();\n    return 0;\n}",
    "o": [
      "Thread running",
      "Compilation error",
      "Nothing",
      "Runtime error"
    ]
  },
  {
    "q": "Which of these smart pointers does NOT support reference counting?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::intrusive_ptr"
    ]
  },
  {
    "q": "What does 'detach()' do in std::thread?",
    "o": [
      "It lets the thread run independently in the background.",
      "It terminates the thread immediately.",
      "It blocks the main thread until the detached thread finishes.",
      "It joins multiple threads into one."
    ]
  },
  {
    "q": "In the context of C++, what does the scope resolution operator help with?",
    "o": [
      "Accessing identifiers from a specific namespace or class",
      "Resolving runtime linking issues",
      "Declaring template classes",
      "Specifying inheritance type"
    ]
  },
  {
    "q": "Which of the following is a valid move constructor declaration?",
    "o": [
      "MyClass(MyClass&& other);",
      "MyClass(const MyClass other);",
      "MyClass(MyClass& other);",
      "MyClass(MyClass* other);"
    ]
  },
  {
    "q": "Which of the following is true about smart pointers in C++?",
    "o": [
      "They automatically deallocate memory when no longer in use",
      "They are slower than raw pointers in all scenarios",
      "They require manual delete",
      "They don't support custom deleters"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> ptr(new int(42));\n    std::cout << *ptr;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "Compilation error",
      "Runtime error"
    ]
  },
  {
    "q": "How can you prevent circular references when using std::shared_ptr?",
    "o": [
      "Use std::weak_ptr for one of the references",
      "Use std::unique_ptr instead",
      "Avoid pointers altogether",
      "Use raw pointers"
    ]
  },
  {
    "q": "Which syntax correctly accesses a variable in an unnamed namespace from the same translation unit?",
    "o": [
      "Just use the variable name directly",
      "Prefix with ::",
      "Prefix with global::",
      "Use extern"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "#include <iostream>\n#include <thread>\nvoid task() {\n    std::cout << \"Hello from thread\";\n}\nint main() {\n    std::thread t(task);\n    t.join();\n    return 0;\n}",
    "o": [
      "Hello from thread",
      "Compilation error",
      "Segmentation fault",
      "Nothing is printed"
    ]
  },
  {
    "q": "What is true about move constructors?",
    "o": [
      "They avoid unnecessary deep copies by transferring resources",
      "They copy all data members",
      "They are slower than copy constructors",
      "They are required to be explicit"
    ]
  },
  {
    "q": "Which of the following correctly moves a std::unique_ptr?",
    "o": [
      "std::unique_ptr<int> p2 = std::move(p1);",
      "std::unique_ptr<int> p2 = p1;",
      "std::unique_ptr<int> p2(p1);",
      "p2 = p1;"
    ]
  },
  {
    "q": "What does the scope resolution operator (::) allow in C++?",
    "o": [
      "Access to global variables or namespace members",
      "Access to private class members",
      "Casting objects to other types",
      "Creating templates"
    ]
  },
  {
    "q": "What happens if you don't call join() or detach() on a std::thread?",
    "o": [
      "The program terminates with an exception",
      "The thread is silently discarded",
      "The thread blocks main forever",
      "The compiler gives a warning"
    ]
  },
  {
    "q": "Which of the following is a feature of std::shared_ptr?",
    "o": [
      "It keeps a reference count to manage ownership",
      "It cannot be copied",
      "It uses manual memory management",
      "It throws on assignment"
    ]
  },
  {
    "q": "Which of the following smart pointers allows shared ownership of a dynamically allocated object?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::raw_ptr"
    ]
  },
  {
    "q": "What does the '::' operator do in C++?",
    "o": [
      "Resolves scope to access global or namespace-level entities",
      "Defines a new class",
      "Casts a variable",
      "Performs dynamic memory allocation"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nnamespace A {\n    int x = 10;\n}\nint main() {\n    std::cout << A::x;\n    return 0;\n}",
    "o": [
      "10",
      "0",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "Which of the following best describes move semantics in C++?",
    "o": [
      "Transfers ownership of resources to avoid deep copies",
      "Duplicates memory to speed up execution",
      "Protects shared data in multithreaded programs",
      "Ensures automatic garbage collection"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> a(new int(100));\n    std::unique_ptr<int> b = std::move(a);\n    std::cout << *b;\n    return 0;\n}",
    "o": [
      "100",
      "0",
      "Garbage value",
      "Compilation error"
    ]
  },
  {
    "q": "Which C++ feature prevents copying but allows transferring ownership of resources?",
    "o": [
      "std::move",
      "std::copy",
      "std::transfer",
      "std::clone"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\n#include <thread>\nvoid greet() {\n    std::cout << \"Thread started\";\n}\nint main() {\n    std::thread t(greet);\n    t.join();\n    return 0;\n}",
    "o": [
      "Thread started",
      "Compilation error",
      "Segmentation fault",
      "No output"
    ]
  },
  {
    "q": "Which smart pointer should be used when you need exclusive ownership of a resource?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "In multithreading, which method is used to detach a thread so it runs independently?",
    "o": [
      "detach()",
      "join()",
      "start()",
      "release()"
    ]
  },
  {
    "q": "Which is true about unnamed namespaces?",
    "o": [
      "They limit visibility to the current translation unit",
      "They can be accessed globally",
      "They are deprecated in C++17",
      "They require explicit naming"
    ]
  },
  {
    "q": "Which C++ operator is used for scope resolution?",
    "o": [
      "::",
      ".",
      "->",
      ":="
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "#include <iostream>\nnamespace Math {\n    int square(int x) { return x * x; }\n}\nint main() {\n    std::cout << Math::square(4);\n    return 0;\n}",
    "o": [
      "16",
      "8",
      "4",
      "Error"
    ]
  },
  {
    "q": "Which smart pointer type does not participate in reference counting?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "Which of the following is true about move semantics?",
    "o": [
      "They avoid unnecessary deep copies by transferring resources.",
      "They duplicate resources for performance.",
      "They replace references with values.",
      "They are available only in C++98."
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    auto ptr = std::make_shared<int>(42);\n    std::cout << *ptr;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "Null",
      "Compile Error"
    ]
  },
  {
    "q": "Which function launches a thread that runs independently and can’t be joined?",
    "o": [
      "detach()",
      "join()",
      "run()",
      "release()"
    ]
  },
  {
    "q": "What happens when you move a std::unique_ptr?",
    "o": [
      "Ownership transfers and the original pointer becomes null.",
      "Both pointers point to the same resource.",
      "Nothing changes.",
      "The original pointer is copied."
    ]
  },
  {
    "q": "What does the following multithreaded code do?",
    "c": "#include <iostream>\n#include <thread>\nvoid task() { std::cout << \"Running \"; }\nint main() {\n    std::thread t(task);\n    t.join();\n    return 0;\n}",
    "o": [
      "Running ",
      "Compilation error",
      "Nothing",
      "Runtime error"
    ]
  },
  {
    "q": "Which of the following ensures that a shared_ptr does not keep the object alive by itself?",
    "o": [
      "std::weak_ptr",
      "std::unique_ptr",
      "std::raw_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "Which of the following is the correct way to access a global variable hidden by a local one?",
    "o": [
      "::var_name",
      "global::var_name",
      "this->var_name",
      "extern var_name"
    ]
  },
  {
    "q": "Which keyword prevents multiple threads from accessing a critical section simultaneously?",
    "o": [
      "mutex",
      "thread",
      "shared",
      "unique"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> p1 = std::make_unique<int>(100);\n    std::unique_ptr<int> p2 = std::move(p1);\n    std::cout << *p2;\n    return 0;\n}",
    "o": [
      "100",
      "0",
      "null",
      "Compile-time error"
    ]
  },
  {
    "q": "What is the use of std::lock_guard in C++?",
    "o": [
      "To provide a convenient RAII-style mechanism for owning a mutex",
      "To create a thread-safe smart pointer",
      "To manage memory in shared resources",
      "To delay execution of threads"
    ]
  },
  {
    "q": "What is the purpose of the 'std::move' function?",
    "o": [
      "To enable move semantics by converting an lvalue to an rvalue",
      "To copy objects efficiently",
      "To synchronize threads",
      "To switch contexts between threads"
    ]
  },
  {
    "q": "What is the output of this code using a namespace?",
    "c": "#include <iostream>\nnamespace A { int value = 10; }\nnamespace B { int value = 20; }\nint main() {\n    std::cout << A::value;\n    return 0;\n}",
    "o": [
      "10",
      "20",
      "30",
      "Compile error"
    ]
  },
  {
    "q": "Which smart pointer allows multiple shared owners of a single resource?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "Which of the following best describes 'move constructor' in C++?",
    "o": [
      "Transfers ownership of resources from a temporary object",
      "Copies object data member-wise",
      "Creates multiple references to the same object",
      "Destroys and reallocates resources"
    ]
  },
  {
    "q": "Which function of std::thread is used to block the current thread until the associated thread finishes execution?",
    "o": [
      "join()",
      "wait()",
      "block()",
      "end()"
    ]
  },
  {
    "q": "What is the purpose of scope resolution operator (::) in C++?",
    "o": [
      "To access global variables or namespace members",
      "To declare classes",
      "To define loops",
      "To handle exceptions"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "#include <iostream>\n#include <thread>\nvoid print() { std::cout << \"Hello from thread\\n\"; }\nint main() {\n    std::thread t(print);\n    t.join();\n    return 0;\n}",
    "o": [
      "Hello from thread",
      "Nothing",
      "Error at runtime",
      "Program crash"
    ]
  },
  {
    "q": "Which of the following is true about std::weak_ptr?",
    "o": [
      "It does not contribute to the reference count of a shared_ptr",
      "It behaves exactly like unique_ptr",
      "It is used to transfer ownership of resources",
      "It can only be used in single-threaded programs"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nnamespace X { int a = 50; }\nnamespace Y { int a = 100; }\nint main() {\n    using namespace Y;\n    std::cout << X::a;\n    return 0;\n}",
    "o": [
      "50",
      "100",
      "0",
      "Compilation Error"
    ]
  },
  {
    "q": "Which smart pointer would you use to ensure exclusive ownership of a dynamically allocated object?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "Which of the following best describes std::move?",
    "o": [
      "Casts an object to an rvalue to enable move semantics",
      "Copies data from one object to another",
      "Frees the memory of an object",
      "Pauses a running thread"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> sp1 = std::make_shared<int>(10);\n    std::shared_ptr<int> sp2 = sp1;\n    std::cout << sp1.use_count();\n    return 0;\n}",
    "o": [
      "2",
      "1",
      "0",
      "Runtime Error"
    ]
  },
  {
    "q": "Which method starts the execution of a std::thread object?",
    "o": [
      "Constructor with callable",
      "start()",
      "run()",
      "launch()"
    ]
  },
  {
    "q": "Why is std::mutex important in multithreaded programming?",
    "o": [
      "It prevents race conditions by allowing only one thread to access a resource at a time",
      "It allows threads to communicate directly",
      "It spawns new threads automatically",
      "It replaces the need for shared_ptr in threading"
    ]
  },
  {
    "q": "What is the output of this program involving move semantics?",
    "c": "#include <iostream>\n#include <string>\n#include <utility>\nint main() {\n    std::string a = \"Hello\";\n    std::string b = std::move(a);\n    std::cout << b;\n    return 0;\n}",
    "o": [
      "Hello",
      "a",
      "b",
      "Compilation Error"
    ]
  },
  {
    "q": "Which scope does the :: operator in C++ resolve?",
    "o": [
      "Global or namespace scope",
      "Class scope only",
      "Block scope",
      "Local variable scope"
    ]
  },
  {
    "q": "What happens if you call join() on a std::thread that has already been joined or hasn't started?",
    "o": [
      "It throws a std::system_error exception",
      "It silently fails",
      "It retries to join until thread ends",
      "It blocks forever"
    ]
  },
  {
    "q": "What does the scope resolution operator (::) allow you to do in C++?",
    "o": [
      "Access global or namespace-level variables/functions",
      "Dynamically allocate memory",
      "Terminate a thread",
      "Convert smart pointers"
    ]
  },
  {
    "q": "Which smart pointer automatically deletes the managed object when the last reference to it is destroyed?",
    "o": [
      "std::shared_ptr",
      "std::weak_ptr",
      "std::unique_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What does std::move actually do?",
    "o": [
      "Casts an lvalue to an rvalue reference",
      "Performs a deep copy",
      "Moves a thread to another core",
      "Automatically synchronizes threads"
    ]
  },
  {
    "q": "In multithreading, what does std::lock_guard do?",
    "o": [
      "Automatically acquires and releases a mutex",
      "Spawns a new thread",
      "Pauses a thread for a given time",
      "Joins multiple threads into one"
    ]
  },
  {
    "q": "Which of the following code snippets correctly creates a shared pointer to an integer?",
    "c": "#include <memory>\nint main() {\n    auto ptr = std::make_shared<int>(42);\n    return 0;\n}",
    "o": [
      "It creates a shared pointer with value 42",
      "It creates a weak pointer",
      "It creates a unique pointer",
      "Compilation error due to missing header"
    ]
  },
  {
    "q": "How many threads are spawned by the following code?",
    "c": "#include <thread>\n#include <iostream>\nvoid task() { std::cout << \"Running\"; }\nint main() {\n    std::thread t1(task);\n    t1.join();\n    return 0;\n}",
    "o": [
      "1",
      "0",
      "2",
      "Depends on the system"
    ]
  },
  {
    "q": "Why should you use std::unique_ptr instead of raw pointers?",
    "o": [
      "It prevents memory leaks by enforcing exclusive ownership",
      "It shares ownership like shared_ptr",
      "It avoids compilation errors with threads",
      "It allows deep copying of objects"
    ]
  },
  {
    "q": "What happens to the source object after a move operation?",
    "o": [
      "Its resources are transferred and it's left in a valid but unspecified state",
      "It becomes a dangling pointer",
      "It throws an exception",
      "It is automatically deleted"
    ]
  },
  {
    "q": "What is the correct way to pass a std::unique_ptr to a function that takes ownership?",
    "o": [
      "By std::move(ptr)",
      "By reference",
      "By const reference",
      "By copying"
    ]
  },
  {
    "q": "Which of the following statements is true about std::thread?",
    "o": [
      "It begins executing immediately when constructed with a valid callable",
      "It must be manually started using a start() method",
      "It requires a mutex to run",
      "It only works with static member functions"
    ]
  },
  {
    "q": "Which statement correctly uses a symbol from the std namespace without importing the entire namespace?",
    "o": [
      "std::cout << \"Hello\";",
      "cout << \"Hello\";",
      "namespace std { cout << \"Hello\"; }",
      "using namespace std::cout;"
    ]
  },
  {
    "q": "What is one major advantage of using std::unique_ptr?",
    "o": [
      "Ensures only one owner of the resource at a time",
      "Allows multiple owners of the same resource",
      "Shares ownership between threads",
      "Automatically deep copies the resource"
    ]
  },
  {
    "q": "When is std::move most useful?",
    "o": [
      "To transfer ownership of a resource without copying",
      "To duplicate an object efficiently",
      "To convert a raw pointer to a smart pointer",
      "To lock a thread mutex"
    ]
  },
  {
    "q": "Which C++ smart pointer can detect if the object it points to has been deleted?",
    "o": [
      "std::weak_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What does std::thread::join() do?",
    "o": [
      "Waits for the thread to finish execution",
      "Starts a new thread",
      "Combines two threads",
      "Kills a running thread"
    ]
  },
  {
    "q": "What will happen if a std::thread object is destroyed without being joined or detached?",
    "o": [
      "The program will terminate",
      "The thread continues to run silently",
      "The thread is automatically detached",
      "It throws a compile-time error"
    ]
  },
  {
    "q": "What is the purpose of the 'using namespace' directive?",
    "o": [
      "It allows direct access to all elements of a namespace without prefixing",
      "It limits the scope of variables in a namespace",
      "It creates a nested namespace",
      "It deletes all other namespaces"
    ]
  },
  {
    "q": "Which of the following is NOT true about std::shared_ptr?",
    "o": [
      "It always has exactly one owner",
      "It manages reference counting",
      "Multiple shared_ptrs can own the same object",
      "It automatically deletes the object when no shared_ptr owns it"
    ]
  },
  {
    "q": "What type of argument should be used in a constructor to enable move semantics?",
    "o": [
      "An rvalue reference (e.g., T&&)",
      "A const reference",
      "A pointer",
      "An lvalue reference"
    ]
  },
  {
    "q": "Which keyword is used to define a namespace in C++?",
    "o": [
      "namespace",
      "using",
      "scope",
      "group"
    ]
  },
  {
    "q": "Which of the following is true about a 'namespace' in C++?",
    "o": [
      "A namespace is a container for identifiers to prevent name conflicts",
      "Namespaces can only contain variables, not functions",
      "A namespace must be defined within a class",
      "Namespaces cannot be nested inside other namespaces"
    ]
  },
  {
    "q": "What happens when you call std::move on a variable?",
    "o": [
      "It casts the variable to an rvalue reference, enabling move semantics",
      "It creates a copy of the variable",
      "It prevents the variable from being modified",
      "It creates a new instance of the variable"
    ]
  },
  {
    "q": "What is the output of the following code snippet?\n\n#include <iostream>\n\nint main() {\n    int x = 10;\n    int &&y = std::move(x);\n    std::cout << y;\n    return 0;\n}",
    "o": [
      "10",
      "undefined behavior",
      "error: cannot move a lvalue",
      "0"
    ]
  },
  {
    "q": "Which of the following best describes the purpose of smart pointers in C++?",
    "o": [
      "To automatically manage the lifetime of dynamically allocated objects",
      "To store pointers in a container",
      "To manually manage memory allocation and deallocation",
      "To define custom data types for smart objects"
    ]
  },
  {
    "q": "What does the term 'move semantics' refer to in C++?",
    "o": [
      "The transfer of resources from one object to another without copying",
      "The process of assigning the same value to two objects",
      "Copying a resource to multiple locations for redundancy",
      "Locking resources to prevent data races"
    ]
  },
  {
    "q": "What will happen if you use std::shared_ptr in a multithreaded environment?",
    "o": [
      "It will automatically manage reference counting across threads",
      "It requires explicit thread synchronization for thread safety",
      "It cannot be used in multithreaded environments",
      "It causes a segmentation fault"
    ]
  },
  {
    "q": "Which of the following is true about std::unique_ptr?",
    "o": [
      "It ensures a single owner for the object and automatically deletes the object when the unique_ptr goes out of scope",
      "It can share ownership with other unique_ptr objects",
      "It allows manual memory management without automatic deletion",
      "It creates a copy of the object it points to when it goes out of scope"
    ]
  },
  {
    "q": "Which C++ keyword is used to indicate that a function or object is moved instead of copied?",
    "o": [
      "std::move",
      "std::copy",
      "std::transfer",
      "std::share"
    ]
  },
  {
    "q": "In C++, which of the following statements is true about multithreading?",
    "o": [
      "Threads share the same memory space and can communicate via shared variables",
      "Each thread has its own isolated memory, preventing data sharing",
      "Threads cannot be synchronized",
      "Multithreading is not supported in C++"
    ]
  },
  {
    "q": "What is the primary benefit of using std::weak_ptr in C++?",
    "o": [
      "It allows access to an object without affecting its reference count",
      "It creates a copy of the object and manages its lifetime",
      "It shares ownership of the object with std::shared_ptr",
      "It automatically deletes the object once the last reference is gone"
    ]
  },
  {
    "q": "What does the keyword 'namespace' allow in C++?",
    "o": [
      "It defines a scope to avoid naming conflicts in large programs",
      "It creates an anonymous class for variables",
      "It helps to reduce code complexity by hiding variables",
      "It enables multiple inheritance"
    ]
  },
  {
    "q": "What is the main purpose of move semantics in C++?",
    "o": [
      "To optimize resource management by transferring ownership of resources",
      "To copy resources efficiently between objects",
      "To prevent memory leaks by forcing object destruction",
      "To share resources between multiple threads"
    ]
  },
  {
    "q": "What is the output of the following code snippet?\n\n#include <iostream>\n\nint main() {\n    int a = 5;\n    int b = std::move(a);\n    std::cout << a << ' ' << b;\n    return 0;\n}",
    "o": [
      "0 5",
      "5 0",
      "5 5",
      "undefined behavior"
    ]
  },
  {
    "q": "What is a benefit of using std::shared_ptr in C++?",
    "o": [
      "It automatically manages the reference count of the object it points to",
      "It requires manual memory management by the developer",
      "It guarantees thread safety by itself",
      "It does not allow ownership transfer"
    ]
  },
  {
    "q": "Which of the following is true about smart pointers in C++?",
    "o": [
      "They automatically deallocate memory when it is no longer in use",
      "They require explicit memory deallocation",
      "They are faster than raw pointers in all cases",
      "They do not allow resource management"
    ]
  },
  {
    "q": "What will happen if you use std::move on an already moved-from object?",
    "o": [
      "It results in undefined behavior",
      "The object will be copied",
      "The move operation will be ignored",
      "The object will be reset to its initial state"
    ]
  },
  {
    "q": "Which of the following correctly describes std::mutex in C++ multithreading?",
    "o": [
      "It provides mutual exclusion to ensure only one thread accesses shared data at a time",
      "It automatically syncs threads without the need for synchronization primitives",
      "It is used to manage the reference count of an object",
      "It allows threads to run concurrently without synchronization"
    ]
  },
  {
    "q": "What will happen if a std::shared_ptr goes out of scope in C++?",
    "o": [
      "The object it points to will be automatically deleted if no other shared_ptr points to it",
      "The object will be copied to another shared_ptr",
      "The object will be transferred to a unique_ptr",
      "The object will remain alive indefinitely"
    ]
  },
  {
    "q": "In C++, what is the advantage of using std::move on a non-const object?",
    "o": [
      "It allows the ownership of resources to be transferred, avoiding unnecessary copies",
      "It forces the compiler to make a copy of the object",
      "It locks the object for modification",
      "It allows the object to be passed by value without copying"
    ]
  },
  {
    "q": "Which of the following correctly describes the C++ scope resolution operator (::)?",
    "o": [
      "It allows you to specify the scope of a variable, function, or class",
      "It is used to create new namespaces",
      "It is used to define classes in a particular namespace",
      "It is a synonym for the 'this' pointer"
    ]
  },
  {
    "q": "Which of the following is a correct use of the scope resolution operator in C++?",
    "o": [
      "Using it to access a global variable when a local variable has the same name",
      "Using it to define a class constructor outside of the class definition",
      "Using it to create a new class",
      "Using it to assign values to a static variable"
    ]
  },
  {
    "q": "Which C++ feature allows for automatic resource management with no manual cleanup required?",
    "o": [
      "Smart pointers like std::unique_ptr and std::shared_ptr",
      "Traditional pointers",
      "Memory pools",
      "Manual memory allocation"
    ]
  },
  {
    "q": "What does the 'std::move' function in C++ do to an object?",
    "o": [
      "It casts an object to an rvalue reference to enable move semantics",
      "It creates a copy of the object",
      "It deletes the object",
      "It locks the object from further modifications"
    ]
  },
  {
    "q": "What happens when a thread calls 'std::mutex::lock' and the mutex is already locked by another thread?",
    "o": [
      "The calling thread will block until the mutex is available",
      "The calling thread will throw an exception",
      "The mutex will be unlocked automatically",
      "The calling thread will continue execution without waiting"
    ]
  },
  {
    "q": "Which of the following is true regarding move semantics in C++?",
    "o": [
      "Move semantics transfer ownership of resources without copying them",
      "Move semantics make deep copies of objects",
      "Move semantics are used only for dynamic memory management",
      "Move semantics prevent objects from being reused"
    ]
  },
  {
    "q": "Which of the following statements is true about smart pointers in C++?",
    "o": [
      "std::unique_ptr cannot be copied but can be moved",
      "std::shared_ptr can only be used in multithreaded environments",
      "std::shared_ptr always causes memory leaks if not explicitly freed",
      "std::weak_ptr is used to enforce ownership of resources"
    ]
  },
  {
    "q": "What is the result of calling std::move on an object that has already been moved from in C++?",
    "o": [
      "It results in undefined behavior",
      "It copies the object",
      "It resets the object to its default state",
      "It causes a compile-time error"
    ]
  },
  {
    "q": "Which of the following is true about mutexes in C++?",
    "o": [
      "Mutexes are used to protect shared data from concurrent access by multiple threads",
      "Mutexes are used to lock variables and prevent compilation",
      "Mutexes automatically synchronize thread execution",
      "Mutexes are always used with std::thread"
    ]
  },
  {
    "q": "What happens if a move constructor is not defined for a class in C++?",
    "o": [
      "The compiler will automatically generate one if needed",
      "A deep copy constructor will be used instead",
      "The code will not compile",
      "The class will only be able to be copied but not moved"
    ]
  },
  {
    "q": "Which of the following is a valid use of a smart pointer in C++?",
    "o": [
      "std::shared_ptr can be used to share ownership of an object across multiple pointers",
      "std::unique_ptr is used to manage shared resources between threads",
      "std::weak_ptr is used to share ownership without affecting reference counts",
      "std::shared_ptr can be copied freely between different threads without performance cost"
    ]
  },
  {
    "q": "Which keyword is used to access members of a namespace in C++?",
    "o": [
      "using",
      "include",
      "define",
      "access"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\n\nnamespace MyNamespace {\n    int value = 10;\n}\n\nint main() {\n    std::cout << MyNamespace::value << std::endl;\n    return 0;\n}",
    "o": [
      "10",
      "0",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "Which of the following is a smart pointer in C++?",
    "o": [
      "std::unique_ptr",
      "std::pointer",
      "std::raw_ptr",
      "std::smart_pointer"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::unique_ptr<int> ptr = std::make_unique<int>(42);\n    std::cout << *ptr << std::endl;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "Compilation error",
      "Garbage value"
    ]
  },
  {
    "q": "Which of the following best describes move semantics in C++?",
    "o": [
      "Transfers ownership of resources instead of copying them",
      "Duplicates resources for safety",
      "Destroys the original object",
      "Ignores rvalue references"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\n#include <utility>\n#include <string>\n\nint main() {\n    std::string a = \"Hello\";\n    std::string b = std::move(a);\n    std::cout << b << std::endl;\n    return 0;\n}",
    "o": [
      "Hello",
      "a",
      "Compilation error",
      "Nothing"
    ]
  },
  {
    "q": "Which C++ header is required to use std::thread?",
    "o": [
      "<thread>",
      "<mutex>",
      "<future>",
      "<atomic>"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\n#include <thread>\n\nvoid func() {\n    std::cout << \"Thread running\" << std::endl;\n}\n\nint main() {\n    std::thread t(func);\n    t.join();\n    return 0;\n}",
    "o": [
      "Thread running",
      "Compilation error",
      "No output",
      "Runtime error"
    ]
  },
  {
    "q": "Which operator is used to access elements inside a namespace?",
    "o": [
      "::",
      "->",
      ".",
      ":"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\n\nnamespace A {\n    int val = 1;\n}\n\nnamespace B {\n    int val = 2;\n}\n\nint main() {\n    std::cout << A::val << std::endl;\n    return 0;\n}",
    "o": [
      "1",
      "2",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer allows shared ownership of an object?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What will be the output of this code snippet using shared_ptr?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::shared_ptr<int> a = std::make_shared<int>(100);\n    std::shared_ptr<int> b = a;\n    std::cout << *b << std::endl;\n    return 0;\n}",
    "o": [
      "100",
      "0",
      "Garbage value",
      "Compilation error"
    ]
  },
  {
    "q": "What does std::move do in C++?",
    "o": [
      "Converts an lvalue into an rvalue",
      "Moves variables to the heap",
      "Converts a pointer to a reference",
      "Duplicates an object"
    ]
  },
  {
    "q": "What is the state of the original string after std::move?",
    "c": "#include <iostream>\n#include <string>\n#include <utility>\n\nint main() {\n    std::string s1 = \"C++\";\n    std::string s2 = std::move(s1);\n    std::cout << s1 << std::endl;\n    return 0;\n}",
    "o": [
      "Undefined/Empty",
      "C++",
      "s2",
      "Compilation error"
    ]
  },
  {
    "q": "Which function is used to synchronize threads in C++?",
    "o": [
      "join()",
      "sync()",
      "run()",
      "lock()"
    ]
  },
  {
    "q": "What is the output of the following code snippet with multiple threads?",
    "c": "#include <iostream>\n#include <thread>\n\nvoid task1() {\n    std::cout << \"Task 1\" << std::endl;\n}\n\nvoid task2() {\n    std::cout << \"Task 2\" << std::endl;\n}\n\nint main() {\n    std::thread t1(task1);\n    std::thread t2(task2);\n    t1.join();\n    t2.join();\n    return 0;\n}",
    "o": [
      "Task 1\nTask 2",
      "Task 2\nTask 1",
      "Compilation error",
      "Task1Task2"
    ]
  },
  {
    "q": "How can you avoid writing the namespace qualifier repeatedly in C++?",
    "o": [
      "By using the 'using namespace' directive",
      "By defining all variables globally",
      "By using #define for the namespace",
      "By inheriting the namespace"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\n\nnamespace Alpha {\n    int val = 7;\n}\n\nusing namespace Alpha;\n\nint main() {\n    std::cout << val << std::endl;\n    return 0;\n}",
    "o": [
      "7",
      "0",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "Which of the following smart pointers does not allow copying?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What will be printed by the following code?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::unique_ptr<int> ptr1 = std::make_unique<int>(10);\n    // std::unique_ptr<int> ptr2 = ptr1; // error!\n    std::cout << *ptr1 << std::endl;\n    return 0;\n}",
    "o": [
      "10",
      "0",
      "Compilation error",
      "Undefined behavior"
    ]
  },
  {
    "q": "Which of the following best describes the purpose of move semantics?",
    "o": [
      "To optimize resource management by reusing memory/resources from temporary objects",
      "To prevent dangling pointers",
      "To improve code readability",
      "To allow multiple ownership of a resource"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\n#include <vector>\n#include <utility>\n\nint main() {\n    std::vector<int> v1 = {1, 2, 3};\n    std::vector<int> v2 = std::move(v1);\n    std::cout << v2.size() << std::endl;\n    return 0;\n}",
    "o": [
      "3",
      "0",
      "Compilation error",
      "Undefined behavior"
    ]
  },
  {
    "q": "Which header file is required to use std::mutex in C++?",
    "o": [
      "<mutex>",
      "<thread>",
      "<condition_variable>",
      "<synchronization>"
    ]
  },
  {
    "q": "What is the output of the following C++ code using mutex?",
    "c": "#include <iostream>\n#include <thread>\n#include <mutex>\n\nstd::mutex mtx;\n\nvoid printMessage(const std::string& msg) {\n    mtx.lock();\n    std::cout << msg << std::endl;\n    mtx.unlock();\n}\n\nint main() {\n    std::thread t1(printMessage, \"Thread A\");\n    std::thread t2(printMessage, \"Thread B\");\n    t1.join();\n    t2.join();\n    return 0;\n}",
    "o": [
      "Thread A\nThread B (order may vary)",
      "Thread B\nThread A (order may vary)",
      "Only Thread A",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following allows defining multiple functions or classes with the same name without conflict?",
    "o": [
      "Namespaces",
      "Macros",
      "Templates",
      "Friend functions"
    ]
  },
  {
    "q": "What is the output of the following code using nested namespaces?",
    "c": "#include <iostream>\n\nnamespace A {\n    namespace B {\n        void greet() {\n            std::cout << \"Hello from B\" << std::endl;\n        }\n    }\n}\n\nint main() {\n    A::B::greet();\n    return 0;\n}",
    "o": [
      "Hello from B",
      "Hello B",
      "Compilation error",
      "Nothing"
    ]
  },
  {
    "q": "Which smart pointer is used to observe an object managed by std::shared_ptr without owning it?",
    "o": [
      "std::weak_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::observer_ptr"
    ]
  },
  {
    "q": "What will be the output of the following smart pointer code?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::shared_ptr<int> sp = std::make_shared<int>(25);\n    std::weak_ptr<int> wp = sp;\n    std::cout << wp.use_count() << std::endl;\n    return 0;\n}",
    "o": [
      "1",
      "0",
      "2",
      "Undefined"
    ]
  },
  {
    "q": "Which scenario is ideal for using move semantics?",
    "o": [
      "When returning a large object from a function",
      "When passing a const reference",
      "When using polymorphism",
      "When implementing recursion"
    ]
  },
  {
    "q": "What is the output of this C++ code using move semantics?",
    "c": "#include <iostream>\n#include <vector>\n#include <utility>\n\nint main() {\n    std::vector<int> v1 = {4, 5, 6};\n    std::vector<int> v2 = std::move(v1);\n    std::cout << v1.empty() << std::endl;\n    return 0;\n}",
    "o": [
      "1",
      "0",
      "3",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following methods prevents race conditions in multithreaded code?",
    "o": [
      "Using mutexes",
      "Using global variables",
      "Calling join() only",
      "Using constexpr"
    ]
  },
  {
    "q": "What is the output of the following code using lambda and thread?",
    "c": "#include <iostream>\n#include <thread>\n\nint main() {\n    std::thread t([]() {\n        std::cout << \"Lambda thread\" << std::endl;\n    });\n    t.join();\n    return 0;\n}",
    "o": [
      "Lambda thread",
      "thread",
      "Lambda",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following allows avoiding name conflicts between different libraries?",
    "o": [
      "Using namespaces",
      "Using macros",
      "Using function overloading",
      "Using inline functions"
    ]
  },
  {
    "q": "What is the output of the following code using inline namespaces?",
    "c": "#include <iostream>\n\nnamespace Library {\n    inline namespace V1 {\n        void print() { std::cout << \"Version 1\" << std::endl; }\n    }\n\n    namespace V2 {\n        void print() { std::cout << \"Version 2\" << std::endl; }\n    }\n}\n\nint main() {\n    Library::print();\n    return 0;\n}",
    "o": [
      "Version 1",
      "Version 2",
      "Compilation error",
      "Undefined behavior"
    ]
  },
  {
    "q": "Which smart pointer provides exclusive ownership of a dynamically allocated object?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What is the output of this code with a custom deleter?",
    "c": "#include <iostream>\n#include <memory>\n\nvoid deleter(int* p) {\n    std::cout << \"Deleting: \" << *p << std::endl;\n    delete p;\n}\n\nint main() {\n    std::unique_ptr<int, void(*)(int*)> ptr(new int(99), deleter);\n    return 0;\n}",
    "o": [
      "Deleting: 99",
      "99",
      "Compilation error",
      "Deleting: 0"
    ]
  },
  {
    "q": "Which of the following is a valid syntax for a move constructor?",
    "o": [
      "ClassName(ClassName&& other);",
      "ClassName(const ClassName& other);",
      "ClassName(ClassName other);",
      "ClassName(ClassName& other);"
    ]
  },
  {
    "q": "What is the output of this code using a move constructor?",
    "c": "#include <iostream>\n#include <string>\n\nclass A {\npublic:\n    std::string name;\n    A(std::string n) : name(n) {}\n    A(A&& other) { name = std::move(other.name); }\n};\n\nint main() {\n    A a1(\"Original\");\n    A a2(std::move(a1));\n    std::cout << a2.name << std::endl;\n    return 0;\n}",
    "o": [
      "Original",
      "a1",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "Which standard library feature allows launching asynchronous operations?",
    "o": [
      "std::async",
      "std::thread_pool",
      "std::atomic_exec",
      "std::task"
    ]
  },
  {
    "q": "What is the output of the following asynchronous code?",
    "c": "#include <iostream>\n#include <future>\n\nint compute() { return 42; }\n\nint main() {\n    std::future<int> fut = std::async(compute);\n    std::cout << fut.get() << std::endl;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "Compilation error",
      "Undefined behavior"
    ]
  },
  {
    "q": "What is the purpose of the scope resolution operator (::) in C++?",
    "o": [
      "To access identifiers outside the current scope",
      "To allocate memory dynamically",
      "To create smart pointers",
      "To define macros"
    ]
  },
  {
    "q": "What is the output of this code using the scope resolution operator?",
    "c": "#include <iostream>\n\nint value = 100;\n\nint main() {\n    int value = 50;\n    std::cout << ::value << std::endl;\n    return 0;\n}",
    "o": [
      "100",
      "50",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "What happens when the last std::shared_ptr pointing to a resource is destroyed?",
    "o": [
      "The resource is deallocated",
      "Nothing happens",
      "The resource is transferred to std::weak_ptr",
      "The reference count is reset to 1"
    ]
  },
  {
    "q": "What is the output of the following code with shared_ptr reference counting?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::shared_ptr<int> a = std::make_shared<int>(10);\n    std::shared_ptr<int> b = a;\n    std::cout << a.use_count() << std::endl;\n    return 0;\n}",
    "o": [
      "2",
      "1",
      "0",
      "Undefined"
    ]
  },
  {
    "q": "Which of the following best describes move assignment?",
    "o": [
      "It transfers ownership of resources from one object to another",
      "It performs a deep copy of the object",
      "It assigns values using default constructor",
      "It allocates new resources during copy"
    ]
  },
  {
    "q": "What is the output of this code using move assignment?",
    "c": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string a = \"Hello\";\n    std::string b;\n    b = std::move(a);\n    std::cout << b << std::endl;\n    return 0;\n}",
    "o": [
      "Hello",
      "a",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "Which feature ensures that only one thread at a time accesses a critical section?",
    "o": [
      "Mutex",
      "Condition variable",
      "Atomic flag",
      "Thread pool"
    ]
  },
  {
    "q": "What is the output of this code with std::lock_guard?",
    "c": "#include <iostream>\n#include <thread>\n#include <mutex>\n\nstd::mutex m;\n\nvoid work() {\n    std::lock_guard<std::mutex> lock(m);\n    std::cout << \"Thread safe\" << std::endl;\n}\n\nint main() {\n    std::thread t1(work);\n    std::thread t2(work);\n    t1.join();\n    t2.join();\n    return 0;\n}",
    "o": [
      "Thread safe\nThread safe",
      "Thread safe",
      "Compilation error",
      "Undefined behavior"
    ]
  },
  {
    "q": "What is the effect of declaring a variable inside a namespace in C++?",
    "o": [
      "It avoids name collisions by scoping the variable",
      "It makes the variable globally accessible",
      "It makes the variable private to the class",
      "It makes the variable static"
    ]
  },
  {
    "q": "What will this code output using namespace aliasing?",
    "c": "#include <iostream>\n\nnamespace VeryLongNamespaceName {\n    void func() { std::cout << \"Aliased!\" << std::endl; }\n}\n\nnamespace VLN = VeryLongNamespaceName;\n\nint main() {\n    VLN::func();\n    return 0;\n}",
    "o": [
      "Aliased!",
      "func()",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "What happens if a std::unique_ptr goes out of scope?",
    "o": [
      "The managed object is automatically deleted",
      "Nothing happens until reset() is called",
      "It becomes a shared_ptr",
      "The reference count is decreased"
    ]
  },
  {
    "q": "What is the output of the following code using unique_ptr reset?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::unique_ptr<int> ptr = std::make_unique<int>(8);\n    ptr.reset();\n    std::cout << (ptr ? \"Valid\" : \"Null\") << std::endl;\n    return 0;\n}",
    "o": [
      "Null",
      "Valid",
      "8",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is true about rvalue references in move semantics?",
    "o": [
      "They can bind to temporary objects to enable move operations",
      "They can bind to const references only",
      "They cannot be used in constructors",
      "They are used for implicit conversions"
    ]
  },
  {
    "q": "What will the following code output using rvalue reference?",
    "c": "#include <iostream>\n\nvoid process(std::string&& s) {\n    std::cout << \"Moved: \" << s << std::endl;\n}\n\nint main() {\n    std::string name = \"Test\";\n    process(std::move(name));\n    return 0;\n}",
    "o": [
      "Moved: Test",
      "Moved: ",
      "Test",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following C++ standard library components is used to synchronize threads?",
    "o": [
      "std::mutex",
      "std::move",
      "std::unique_ptr",
      "std::map"
    ]
  },
  {
    "q": "What is the output of the following C++ multithreading code?",
    "c": "#include <iostream>\n#include <thread>\n\nvoid run() {\n    std::cout << \"Thread running\" << std::endl;\n}\n\nint main() {\n    std::thread t(run);\n    t.join();\n    return 0;\n}",
    "o": [
      "Thread running",
      "Running",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "Which of the following best describes the purpose of unnamed (anonymous) namespaces in C++?",
    "o": [
      "To limit the visibility of identifiers to a single translation unit",
      "To allow overloading of global functions",
      "To create default constructors",
      "To declare friend functions"
    ]
  },
  {
    "q": "What is the output of the following code using anonymous namespace?",
    "c": "#include <iostream>\n\nnamespace {\n    void hidden() {\n        std::cout << \"Hidden function\" << std::endl;\n    }\n}\n\nint main() {\n    hidden();\n    return 0;\n}",
    "o": [
      "Hidden function",
      "Function",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "What is the correct way to check if a std::shared_ptr is managing an object?",
    "o": [
      "if (ptr)",
      "if (ptr.get() == nullptr)",
      "if (ptr.use_count() == 0)",
      "if (*ptr)"
    ]
  },
  {
    "q": "What does this smart pointer code output?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::shared_ptr<int> p1;\n    if (!p1) std::cout << \"Empty\" << std::endl;\n    return 0;\n}",
    "o": [
      "Empty",
      "0",
      "nullptr",
      "Compilation error"
    ]
  },
  {
    "q": "What does std::move do when applied to an object?",
    "o": [
      "Casts the object to an rvalue reference",
      "Performs a deep copy of the object",
      "Transfers ownership permanently",
      "Deletes the source object"
    ]
  },
  {
    "q": "What is the output of this move semantics code?",
    "c": "#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> v1 = {10, 20};\n    std::vector<int> v2 = std::move(v1);\n    std::cout << v2[0] << std::endl;\n    return 0;\n}",
    "o": [
      "10",
      "0",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "What is the purpose of std::thread::join() in C++ multithreading?",
    "o": [
      "To block the calling thread until the thread finishes",
      "To terminate the thread immediately",
      "To create a detached thread",
      "To synchronize data access"
    ]
  },
  {
    "q": "What will be printed by this multithreaded program?",
    "c": "#include <iostream>\n#include <thread>\n\nvoid job() { std::cout << \"Job done\" << std::endl; }\n\nint main() {\n    std::thread t(job);\n    t.join();\n    return 0;\n}",
    "o": [
      "Job done",
      "Done",
      "Compilation error",
      "Undefined behavior"
    ]
  },
  {
    "q": "Which keyword allows access to names from a namespace without qualification?",
    "o": [
      "using",
      "extern",
      "friend",
      "include"
    ]
  },
  {
    "q": "What is the output of this code involving 'using' directive?",
    "c": "#include <iostream>\n\nnamespace alpha {\n    void greet() { std::cout << \"Hello from alpha\" << std::endl; }\n}\n\nusing namespace alpha;\n\nint main() {\n    greet();\n    return 0;\n}",
    "o": [
      "Hello from alpha",
      "alpha::greet()",
      "Compilation error",
      "Undefined behavior"
    ]
  },
  {
    "q": "Which of the following prevents cyclic references when using smart pointers?",
    "o": [
      "std::weak_ptr",
      "std::unique_ptr",
      "std::shared_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What is the output of this smart pointer code involving weak_ptr?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::shared_ptr<int> sp = std::make_shared<int>(42);\n    std::weak_ptr<int> wp = sp;\n    std::cout << wp.use_count() << std::endl;\n    return 0;\n}",
    "o": [
      "1",
      "0",
      "42",
      "Undefined behavior"
    ]
  },
  {
    "q": "Which of the following situations best justifies using move semantics?",
    "o": [
      "Transferring ownership of large resources",
      "Assigning from a const reference",
      "Duplicating shared resources",
      "Swapping primitive types"
    ]
  },
  {
    "q": "What is the output of this code using move semantics?",
    "c": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string s1 = \"Data\";\n    std::string s2 = std::move(s1);\n    std::cout << s2.length() << std::endl;\n    return 0;\n}",
    "o": [
      "4",
      "0",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "Which of the following is true about detached threads in C++?",
    "o": [
      "They run independently and cannot be joined later",
      "They are automatically joined before main ends",
      "They share the same stack as main thread",
      "They are always created in suspended state"
    ]
  },
  {
    "q": "What is the output of this multithreading code using detach?",
    "c": "#include <iostream>\n#include <thread>\n#include <chrono>\n\nvoid task() {\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    std::cout << \"Detached\\n\";\n}\n\nint main() {\n    std::thread t(task);\n    t.detach();\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    return 0;\n}",
    "o": [
      "Detached",
      "Compilation error",
      "Nothing",
      "Undefined"
    ]
  },
  {
    "q": "Which of the following allows accessing a global variable when a local variable has the same name?",
    "o": [
      "Using the scope resolution operator ::",
      "Using the 'global' keyword",
      "Using a typedef",
      "Using extern"
    ]
  },
  {
    "q": "What is the output of this code using the global scope resolution operator?",
    "c": "#include <iostream>\n\nint value = 99;\n\nint main() {\n    int value = 42;\n    std::cout << ::value << std::endl;\n    return 0;\n}",
    "o": [
      "99",
      "42",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "Which smart pointer does not allow copying and transfers ownership upon assignment?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What does the following unique_ptr code output?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::unique_ptr<int> ptr = std::make_unique<int>(5);\n    std::cout << *ptr << std::endl;\n    return 0;\n}",
    "o": [
      "5",
      "0",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "Which of the following best describes move constructors in C++?",
    "o": [
      "They transfer resources from one object to another without copying",
      "They copy the contents of an object to another",
      "They are used only for primitive types",
      "They are automatically called for const references"
    ]
  },
  {
    "q": "What is the output of the following code using move constructor?",
    "c": "#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> a = {1, 2, 3};\n    std::vector<int> b(std::move(a));\n    std::cout << b.size() << std::endl;\n    return 0;\n}",
    "o": [
      "3",
      "0",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "What does std::thread::join() ensure when used in a program?",
    "o": [
      "That the main thread waits for the child thread to complete",
      "That the child thread becomes independent",
      "That the thread starts running",
      "That the thread terminates early"
    ]
  },
  {
    "q": "What is the output of the following thread code?",
    "c": "#include <iostream>\n#include <thread>\n\nvoid print_msg() {\n    std::cout << \"Running\" << std::endl;\n}\n\nint main() {\n    std::thread t(print_msg);\n    t.join();\n    return 0;\n}",
    "o": [
      "Running",
      "run",
      "Compilation error",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following statements about namespaces is true in C++?",
    "o": [
      "They help prevent name conflicts by grouping entities under a named scope",
      "They make all functions static by default",
      "They remove the need for header files",
      "They automatically inline all functions"
    ]
  },
  {
    "q": "What is the output of the following code using nested namespaces?",
    "c": "#include <iostream>\n\nnamespace A {\n    namespace B {\n        void display() { std::cout << \"Inside A::B\" << std::endl; }\n    }\n}\n\nint main() {\n    A::B::display();\n    return 0;\n}",
    "o": [
      "Inside A::B",
      "display",
      "Compilation error",
      "Undefined behavior"
    ]
  },
  {
    "q": "Which smart pointer type shares ownership of a dynamically allocated object?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What is the output of the following shared_ptr code?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    auto p1 = std::make_shared<int>(100);\n    auto p2 = p1;\n    std::cout << p1.use_count() << std::endl;\n    return 0;\n}",
    "o": [
      "2",
      "1",
      "0",
      "100"
    ]
  },
  {
    "q": "What is a major advantage of move semantics in C++?",
    "o": [
      "It avoids unnecessary deep copies of large objects",
      "It increases the size of objects for performance",
      "It allows implicit conversions to const references",
      "It guarantees exception safety in all cases"
    ]
  },
  {
    "q": "What does this move operation do to vector 'source'?",
    "c": "#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> source = {10, 20};\n    std::vector<int> dest = std::move(source);\n    std::cout << source.size() << std::endl;\n    return 0;\n}",
    "o": [
      "0",
      "2",
      "10",
      "20"
    ]
  },
  {
    "q": "Which of the following is required to create a thread in C++?",
    "o": [
      "#include <thread>",
      "#include <mutex>",
      "#include <future>",
      "#include <condition_variable>"
    ]
  },
  {
    "q": "What does this multithreaded code do?",
    "c": "#include <iostream>\n#include <thread>\n\nvoid work(int id) {\n    std::cout << \"Worker \" << id << std::endl;\n}\n\nint main() {\n    std::thread t1(work, 1);\n    t1.join();\n    return 0;\n}",
    "o": [
      "Worker 1",
      "1",
      "Worker",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following correctly uses a namespace alias in C++?",
    "o": [
      "namespace io = std;",
      "using namespace = std::io;",
      "namespace std::io;",
      "alias std = io;"
    ]
  },
  {
    "q": "What is the output of this code with a namespace alias?",
    "c": "#include <iostream>\n#include <string>\n\nnamespace text = std;\n\nint main() {\n    text::string s = \"Aliased namespace\";\n    std::cout << s << std::endl;\n    return 0;\n}",
    "o": [
      "Aliased namespace",
      "text",
      "std::string",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following smart pointer types is typically used for observing shared resources without extending their lifetime?",
    "o": [
      "std::weak_ptr",
      "std::shared_ptr",
      "std::unique_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What will be the result of this smart pointer snippet?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::shared_ptr<int> sp1 = std::make_shared<int>(50);\n    std::weak_ptr<int> wp = sp1;\n    std::cout << wp.expired() << std::endl;\n    return 0;\n}",
    "o": [
      "0",
      "1",
      "50",
      "Compilation error"
    ]
  },
  {
    "q": "Which rule applies to move constructors in C++?",
    "o": [
      "They must accept an rvalue reference as parameter",
      "They can be called with lvalue references",
      "They always allocate new memory",
      "They are defined using const references"
    ]
  },
  {
    "q": "What will this move assignment operation output?",
    "c": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string a = \"original\";\n    std::string b = \"temp\";\n    a = std::move(b);\n    std::cout << a << std::endl;\n    return 0;\n}",
    "o": [
      "temp",
      "original",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "Which of the following statements about C++ threads is true?",
    "o": [
      "A thread must be joined or detached before destruction",
      "Threads are automatically joined when they go out of scope",
      "You can copy std::thread objects freely",
      "The main thread always terminates after all other threads"
    ]
  },
  {
    "q": "What is the output of this thread-safety violating code likely to be?",
    "c": "#include <iostream>\n#include <thread>\n\nint counter = 0;\n\nvoid increment() {\n    for (int i = 0; i < 1000; ++i) ++counter;\n}\n\nint main() {\n    std::thread t1(increment);\n    std::thread t2(increment);\n    t1.join();\n    t2.join();\n    std::cout << counter << std::endl;\n    return 0;\n}",
    "o": [
      "Likely less than 2000 due to race condition",
      "Exactly 2000",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is the correct syntax to define a function inside a custom namespace?",
    "o": [
      "namespace MySpace { void func() {} }",
      "def MySpace::func() {}",
      "namespace::MySpace { void func(); }",
      "MySpace func() {}"
    ]
  },
  {
    "q": "What is the output of this namespace scope resolution code?",
    "c": "#include <iostream>\n\nint value = 5;\n\nnamespace demo {\n    int value = 10;\n}\n\nint main() {\n    std::cout << ::value << std::endl;\n    return 0;\n}",
    "o": [
      "5",
      "10",
      "demo::value",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer enforces unique ownership semantics?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::retain_ptr"
    ]
  },
  {
    "q": "What will this unique_ptr code print?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::unique_ptr<int> ptr(new int(99));\n    std::cout << *ptr << std::endl;\n    return 0;\n}",
    "o": [
      "99",
      "0",
      "nullptr",
      "Compilation error"
    ]
  },
  {
    "q": "What is a key characteristic of rvalue references used in move semantics?",
    "o": [
      "They bind to temporary objects",
      "They require const qualification",
      "They are used only with arrays",
      "They cannot be used with user-defined types"
    ]
  },
  {
    "q": "What is the output of the following move operation?",
    "c": "#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> v1 = {7, 8};\n    std::vector<int> v2 = std::move(v1);\n    std::cout << v2[0] << std::endl;\n    return 0;\n}",
    "o": [
      "7",
      "8",
      "0",
      "Undefined"
    ]
  },
  {
    "q": "Which header must be included to use std::thread in C++?",
    "o": [
      "<thread>",
      "<chrono>",
      "<mutex>",
      "<threading>"
    ]
  },
  {
    "q": "What is the output of this simple thread execution?",
    "c": "#include <iostream>\n#include <thread>\n\nvoid greet() { std::cout << \"Hello from thread\\n\"; }\n\nint main() {\n    std::thread t(greet);\n    t.join();\n    return 0;\n}",
    "o": [
      "Hello from thread",
      "Thread",
      "Compilation error",
      "No output"
    ]
  },
  {
    "q": "Which of the following is true about unnamed namespaces in C++?",
    "o": [
      "They provide internal linkage similar to the static keyword",
      "They allow multiple definitions across translation units",
      "They can be accessed using the 'using' keyword globally",
      "They require a name to avoid ambiguity"
    ]
  },
  {
    "q": "What will this namespace-related code output?",
    "c": "#include <iostream>\n\nnamespace A {\n    int value = 1;\n}\nnamespace B {\n    int value = 2;\n}\n\nint main() {\n    std::cout << A::value << std::endl;\n    return 0;\n}",
    "o": [
      "1",
      "2",
      "Compilation error",
      "0"
    ]
  },
  {
    "q": "Which smart pointer automatically deletes the object when the last reference goes out of scope?",
    "o": [
      "std::shared_ptr",
      "std::weak_ptr",
      "std::unique_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What does this smart pointer code output?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::shared_ptr<int> sp = std::make_shared<int>(42);\n    std::cout << *sp << std::endl;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "Compilation error",
      "undefined"
    ]
  },
  {
    "q": "What does the std::move function do?",
    "o": [
      "It casts an object to an rvalue reference",
      "It moves memory contents to a new location",
      "It deep copies the object",
      "It resets a pointer to null"
    ]
  },
  {
    "q": "What will this move constructor usage print?",
    "c": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string s1 = \"Move!\";\n    std::string s2 = std::move(s1);\n    std::cout << s2 << std::endl;\n    return 0;\n}",
    "o": [
      "Move!",
      "s1",
      "undefined",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following correctly creates and starts a thread in C++?",
    "o": [
      "std::thread t(myFunction);",
      "thread t = start(myFunction);",
      "std::begin_thread(myFunction);",
      "pthread_create(myFunction);"
    ]
  },
  {
    "q": "What is the output of this multithreading code snippet?",
    "c": "#include <iostream>\n#include <thread>\n\nvoid task() {\n    std::cout << \"Task executed\\n\";\n}\n\nint main() {\n    std::thread t(task);\n    t.join();\n    return 0;\n}",
    "o": [
      "Task executed",
      "Executed",
      "Compilation error",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following correctly uses the scope resolution operator to access a global variable?",
    "o": [
      "::variableName",
      "variableName::global",
      "global::variableName",
      "scope::variableName"
    ]
  },
  {
    "q": "What does this code print using nested namespaces and scope resolution?",
    "c": "#include <iostream>\n\nnamespace X {\n    namespace Y {\n        int value = 20;\n    }\n}\n\nint main() {\n    std::cout << X::Y::value << std::endl;\n    return 0;\n}",
    "o": [
      "20",
      "X::Y",
      "Compilation error",
      "0"
    ]
  },
  {
    "q": "Which smart pointer is best suited for exclusive ownership and efficient resource release?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What will this code using unique_ptr output?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::unique_ptr<int> uptr = std::make_unique<int>(55);\n    std::cout << *uptr << std::endl;\n    return 0;\n}",
    "o": [
      "55",
      "0",
      "Compilation error",
      "null"
    ]
  },
  {
    "q": "When is a move constructor typically invoked?",
    "o": [
      "When an rvalue is used to initialize a new object",
      "When a copy of an object is needed",
      "During function overloading",
      "To convert between types"
    ]
  },
  {
    "q": "What will be printed by this move constructor example?",
    "c": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string s1 = \"ABC\";\n    std::string s2(std::move(s1));\n    std::cout << s2 << std::endl;\n    return 0;\n}",
    "o": [
      "ABC",
      "s1",
      "move",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is true about std::thread in C++?",
    "o": [
      "It represents a single thread of execution",
      "It requires explicit context switching",
      "It uses cooperative multitasking",
      "It cannot be joined after launching"
    ]
  },
  {
    "q": "What does this multithreading code output?",
    "c": "#include <iostream>\n#include <thread>\n\nvoid print() {\n    std::cout << \"Running in thread\\n\";\n}\n\nint main() {\n    std::thread t(print);\n    t.join();\n    return 0;\n}",
    "o": [
      "Running in thread",
      "Thread started",
      "Compilation error",
      "No output"
    ]
  },
  {
    "q": "What does the following code demonstrate about namespaces?",
    "c": "#include <iostream>\n\nnamespace outer {\n    int x = 100;\n    namespace inner {\n        int y = 200;\n    }\n}\n\nint main() {\n    std::cout << outer::inner::y << std::endl;\n    return 0;\n}",
    "o": [
      "200",
      "100",
      "Compilation error",
      "Namespace error"
    ]
  },
  {
    "q": "Which of the following prevents name clashes in large C++ programs?",
    "o": [
      "Using namespaces",
      "Using global variables",
      "Using #define macros",
      "Using friend functions"
    ]
  },
  {
    "q": "Which smart pointer allows shared ownership and reference counting?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What is the output of this code using shared_ptr?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    auto p1 = std::make_shared<int>(20);\n    auto p2 = p1;\n    std::cout << *p2 << std::endl;\n    return 0;\n}",
    "o": [
      "20",
      "0",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "Which of the following best describes move semantics?",
    "o": [
      "Transfers ownership of resources without copying",
      "Makes a deep copy of objects",
      "Prevents object movement",
      "Copies data and then deletes the source"
    ]
  },
  {
    "q": "What is the result of this move operation?",
    "c": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string str1 = \"Hello\";\n    std::string str2 = std::move(str1);\n    std::cout << str2 << std::endl;\n    return 0;\n}",
    "o": [
      "Hello",
      "str1",
      "move",
      "Compilation error"
    ]
  },
  {
    "q": "What must be done before destroying a std::thread object?",
    "o": [
      "It must be joined or detached",
      "It must be copied",
      "It must be terminated manually",
      "Nothing, it auto-joins"
    ]
  },
  {
    "q": "What does this simple thread example output?",
    "c": "#include <iostream>\n#include <thread>\n\nvoid show() {\n    std::cout << \"Thread running\" << std::endl;\n}\n\nint main() {\n    std::thread t(show);\n    t.join();\n    return 0;\n}",
    "o": [
      "Thread running",
      "Thread created",
      "No output",
      "Compilation error"
    ]
  },
  {
    "q": "What does the following code output using inline namespaces?",
    "c": "#include <iostream>\n\nnamespace A {\n    inline namespace B {\n        void display() { std::cout << \"B\"; }\n    }\n    namespace C {\n        void display() { std::cout << \"C\"; }\n    }\n}\n\nint main() {\n    A::display();\n    return 0;\n}",
    "o": [
      "B",
      "C",
      "Compilation error",
      "Undefined behavior"
    ]
  },
  {
    "q": "Which of the following is a valid use case for anonymous namespaces?",
    "o": [
      "To restrict visibility of functions and variables to a translation unit",
      "To define global functions across multiple files",
      "To overload operators",
      "To avoid dynamic memory allocation"
    ]
  },
  {
    "q": "What does this smart pointer code print?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::shared_ptr<int> sp1 = std::make_shared<int>(100);\n    std::shared_ptr<int> sp2 = sp1;\n    std::cout << sp1.use_count() << std::endl;\n    return 0;\n}",
    "o": [
      "2",
      "1",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is true about std::weak_ptr?",
    "o": [
      "It does not increase the reference count of a shared object",
      "It owns the object it points to",
      "It can be used with std::unique_ptr",
      "It is invalid without a custom deleter"
    ]
  },
  {
    "q": "Which situation best demonstrates the need for move semantics?",
    "o": [
      "Returning large objects from a function",
      "Passing integers by value",
      "Copying constant expressions",
      "Throwing exceptions"
    ]
  },
  {
    "q": "What will this code print regarding move assignment?",
    "c": "#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> v1 = {10, 20};\n    std::vector<int> v2;\n    v2 = std::move(v1);\n    std::cout << v2[0] << std::endl;\n    return 0;\n}",
    "o": [
      "10",
      "20",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following methods ensures that only one thread accesses a resource at a time?",
    "o": [
      "Using std::mutex with std::lock_guard",
      "Using std::thread without locking",
      "Using global variables",
      "Using std::shared_ptr"
    ]
  },
  {
    "q": "What is the output of the following multithreaded program?",
    "c": "#include <iostream>\n#include <thread>\n#include <mutex>\n\nstd::mutex mtx;\n\nvoid print_safe(int x) {\n    std::lock_guard<std::mutex> lock(mtx);\n    std::cout << \"Value: \" << x << std::endl;\n}\n\nint main() {\n    std::thread t1(print_safe, 1);\n    std::thread t2(print_safe, 2);\n    t1.join();\n    t2.join();\n    return 0;\n}",
    "o": [
      "Value: 1\\nValue: 2",
      "Value: 2\\nValue: 1",
      "Random output",
      "Compilation error"
    ]
  },
  {
    "q": "Which keyword allows aliasing a namespace to a shorter name?",
    "o": [
      "namespace",
      "typedef",
      "using",
      "alias"
    ]
  },
  {
    "q": "What does this code output involving namespace aliasing?",
    "c": "#include <iostream>\n\nnamespace longname {\n    int val = 42;\n}\n\nint main() {\n    namespace ln = longname;\n    std::cout << ln::val << std::endl;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "Compilation error",
      "longname"
    ]
  },
  {
    "q": "Which smart pointer is best suited for observing an object without taking ownership?",
    "o": [
      "std::weak_ptr",
      "std::shared_ptr",
      "std::unique_ptr",
      "std::observer_ptr"
    ]
  },
  {
    "q": "What will this code using weak_ptr print?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::shared_ptr<int> sp = std::make_shared<int>(10);\n    std::weak_ptr<int> wp = sp;\n    if (auto tmp = wp.lock()) {\n        std::cout << *tmp << std::endl;\n    }\n    return 0;\n}",
    "o": [
      "10",
      "0",
      "Compilation error",
      "undefined"
    ]
  },
  {
    "q": "Which of the following is a key feature of move constructors?",
    "o": [
      "They avoid deep copies by stealing resources",
      "They copy every data member individually",
      "They are slower than copy constructors",
      "They require manual memory management"
    ]
  },
  {
    "q": "What does this code demonstrate?",
    "c": "#include <iostream>\n#include <string>\n\nclass A {\npublic:\n    std::string name;\n    A(std::string n) : name(std::move(n)) {}\n    void print() { std::cout << name; }\n};\n\nint main() {\n    std::string s = \"MoveSemantics\";\n    A a(s);\n    a.print();\n    return 0;\n}",
    "o": [
      "MoveSemantics",
      "s",
      "Compilation error",
      "Runtime error"
    ]
  },
  {
    "q": "Which header is essential for using std::thread in C++?",
    "o": [
      "<thread>",
      "<concurrency>",
      "<process>",
      "<future>"
    ]
  },
  {
    "q": "What happens if you forget to join or detach a std::thread before destruction?",
    "o": [
      "The program terminates with std::terminate",
      "The thread continues silently",
      "The compiler throws an error",
      "The thread blocks main forever"
    ]
  },
  {
    "q": "What does the scope resolution operator (::) allow you to do in C++?",
    "o": [
      "Access global or namespace-scoped variables/functions",
      "Create anonymous namespaces",
      "Define private class members",
      "Dynamically allocate memory"
    ]
  },
  {
    "q": "What is the output of this code using nested namespaces?",
    "c": "#include <iostream>\n\nnamespace A {\n    namespace B {\n        void func() { std::cout << \"Hello from B\"; }\n    }\n}\n\nint main() {\n    A::B::func();\n    return 0;\n}",
    "o": [
      "Hello from B",
      "func",
      "Compilation error",
      "Namespace B"
    ]
  },
  {
    "q": "Which smart pointer ensures single ownership of a dynamically allocated object?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What will be the result of this unique_ptr example?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::unique_ptr<int> up = std::make_unique<int>(5);\n    std::cout << *up << std::endl;\n    return 0;\n}",
    "o": [
      "5",
      "0",
      "nullptr",
      "Compilation error"
    ]
  },
  {
    "q": "What happens to an object after it has been moved from?",
    "o": [
      "Its state is valid but unspecified",
      "It is deleted immediately",
      "It is copied instead of moved",
      "It becomes a dangling pointer"
    ]
  },
  {
    "q": "What does the following code print after move assignment?",
    "c": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string a = \"abc\";\n    std::string b = std::move(a);\n    std::cout << b;\n    return 0;\n}",
    "o": [
      "abc",
      "a",
      "Compilation error",
      "Undefined behavior"
    ]
  },
  {
    "q": "Which of the following is used to create a thread in C++?",
    "o": [
      "std::thread",
      "std::pthread",
      "std::runtime",
      "std::task"
    ]
  },
  {
    "q": "What is true about std::thread::join()?",
    "o": [
      "It blocks until the thread finishes execution",
      "It detaches the thread from the calling thread",
      "It terminates the thread",
      "It resets the thread handle"
    ]
  },
  {
    "q": "What does the following code print using scope resolution?",
    "c": "#include <iostream>\nint value = 100;\n\nint main() {\n    int value = 50;\n    std::cout << ::value;\n    return 0;\n}",
    "o": [
      "100",
      "50",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "Which statement best describes a use-case for unnamed namespaces?",
    "o": [
      "They restrict linkage to the current translation unit",
      "They allow easier overloading of global operators",
      "They optimize memory alignment of global data",
      "They are required to define inline functions"
    ]
  },
  {
    "q": "Which smart pointer transfers ownership and sets the original to null?",
    "o": [
      "std::move with std::unique_ptr",
      "std::shared_ptr assignment",
      "std::weak_ptr promotion",
      "std::auto_ptr copy"
    ]
  },
  {
    "q": "What does this code print?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::unique_ptr<int> p1 = std::make_unique<int>(10);\n    std::unique_ptr<int> p2 = std::move(p1);\n    if (!p1) std::cout << \"null\";\n    return 0;\n}",
    "o": [
      "null",
      "10",
      "Compilation error",
      "Segmentation fault"
    ]
  },
  {
    "q": "What is a correct use-case of move semantics in a class?",
    "o": [
      "To transfer ownership of a resource during object return",
      "To make copies faster",
      "To initialize static data",
      "To reduce runtime errors"
    ]
  },
  {
    "q": "What does this code output when using std::move?",
    "c": "#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> a = {1, 2, 3};\n    std::vector<int> b = std::move(a);\n    std::cout << b.size();\n    return 0;\n}",
    "o": [
      "3",
      "0",
      "Compilation error",
      "Undefined behavior"
    ]
  },
  {
    "q": "Which of the following will safely protect shared resources in multithreaded code?",
    "o": [
      "std::lock_guard<std::mutex>",
      "Global variables",
      "volatile keyword",
      "std::move"
    ]
  },
  {
    "q": "What does this multithreading code print?",
    "c": "#include <iostream>\n#include <thread>\n\nvoid task() {\n    std::cout << \"Running\" << std::endl;\n}\n\nint main() {\n    std::thread t(task);\n    t.join();\n    return 0;\n}",
    "o": [
      "Running",
      "Compiling",
      "Nothing",
      "Error"
    ]
  },
  {
    "q": "How can you avoid naming conflicts when using multiple libraries in C++?",
    "o": [
      "By using namespaces",
      "By using macros",
      "By overloading functions",
      "By making functions inline"
    ]
  },
  {
    "q": "What is the output of this code using global namespace access?",
    "c": "#include <iostream>\nint val = 7;\n\nint main() {\n    int val = 21;\n    std::cout << ::val;\n    return 0;\n}",
    "o": [
      "7",
      "21",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "Which smart pointer allows multiple owners of a resource?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::weak_ptr"
    ]
  },
  {
    "q": "What is the output of this shared_ptr example?",
    "c": "#include <iostream>\n#include <memory>\n\nint main() {\n    std::shared_ptr<int> sp1 = std::make_shared<int>(42);\n    std::shared_ptr<int> sp2 = sp1;\n    std::cout << *sp2;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "Compilation error",
      "Segmentation fault"
    ]
  },
  {
    "q": "What is the main advantage of move semantics over copy semantics?",
    "o": [
      "Efficient resource transfer",
      "Stronger type safety",
      "Avoiding memory leaks",
      "Ensuring const correctness"
    ]
  },
  {
    "q": "What is the output of this code using move constructor?",
    "c": "#include <iostream>\n#include <string>\n\nint main() {\n    std::string str1 = \"C++\";\n    std::string str2 = std::move(str1);\n    std::cout << str2;\n    return 0;\n}",
    "o": [
      "C++",
      "str1",
      "0",
      "Error"
    ]
  },
  {
    "q": "Which function is used to wait for a thread to complete its execution?",
    "o": [
      "join()",
      "detach()",
      "wait()",
      "pause()"
    ]
  },
  {
    "q": "What does this multithreading example print?",
    "c": "#include <iostream>\n#include <thread>\nvoid say_hello() { std::cout << \"Hello \"; }\n\nint main() {\n    std::thread t(say_hello);\n    t.join();\n    std::cout << \"World!\";\n    return 0;\n}",
    "o": [
      "Hello World!",
      "World! Hello",
      "World!",
      "Compilation error"
    ]
  },
  {
    "q": "What is the purpose of the `using` directive inside a namespace?",
    "o": [
      "It allows bringing symbols from another namespace into the current one",
      "It defines an alias for a type",
      "It declares a friend function",
      "It restricts access to a symbol"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "#include <iostream>\nnamespace A {\n    int value = 1;\n    namespace B {\n        int value = 2;\n    }\n}\nint main() {\n    std::cout << A::B::value;\n    return 0;\n}",
    "o": [
      "2",
      "1",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer should be used for exclusive ownership?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    auto ptr = std::make_unique<int>(99);\n    std::cout << *ptr;\n    return 0;\n}",
    "o": [
      "99",
      "0",
      "nullptr",
      "Error"
    ]
  },
  {
    "q": "Which of the following statements best describes move semantics?",
    "o": [
      "They enable resources to be transferred without copying",
      "They enforce strict immutability",
      "They prevent memory leaks in copy constructors",
      "They require templates to function"
    ]
  },
  {
    "q": "What will this code using `std::move` output?",
    "c": "#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v1 = {4, 5};\n    std::vector<int> v2 = std::move(v1);\n    std::cout << v2[0];\n    return 0;\n}",
    "o": [
      "4",
      "5",
      "0",
      "Error"
    ]
  },
  {
    "q": "Which C++ standard introduced `std::thread`?",
    "o": [
      "C++11",
      "C++98",
      "C++03",
      "C++17"
    ]
  },
  {
    "q": "What does this threading example demonstrate?",
    "c": "#include <iostream>\n#include <thread>\nvoid task(int x) { std::cout << x; }\nint main() {\n    std::thread t(task, 7);\n    t.join();\n    return 0;\n}",
    "o": [
      "7",
      "0",
      "task",
      "Compilation error"
    ]
  },
  {
    "q": "Which feature of namespaces helps to avoid name collisions in large projects?",
    "o": [
      "Encapsulation of identifiers",
      "Faster compilation",
      "Type deduction",
      "Automatic linking"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nnamespace X {\n    int data = 10;\n}\nint main() {\n    using X::data;\n    std::cout << data;\n    return 0;\n}",
    "o": [
      "10",
      "0",
      "Compilation error",
      "data"
    ]
  },
  {
    "q": "What does `std::weak_ptr` help prevent in a shared ownership model?",
    "o": [
      "Cyclic references",
      "Memory allocation",
      "Exclusive access",
      "Shallow copies"
    ]
  },
  {
    "q": "What is the output of this weak_ptr usage?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> sp = std::make_shared<int>(25);\n    std::weak_ptr<int> wp = sp;\n    std::cout << wp.use_count();\n    return 0;\n}",
    "o": [
      "1",
      "0",
      "25",
      "2"
    ]
  },
  {
    "q": "Which condition justifies writing a move constructor?",
    "o": [
      "When your class manages a resource like dynamic memory",
      "When your class is trivially copyable",
      "When your class only uses static variables",
      "When your class does not use any constructors"
    ]
  },
  {
    "q": "What is the effect of this move constructor?",
    "c": "#include <iostream>\n#include <string>\nclass A {\npublic:\n    std::string name;\n    A(std::string n) : name(std::move(n)) {}\n};\nint main() {\n    std::string temp = \"demo\";\n    A a(std::move(temp));\n    std::cout << a.name;\n    return 0;\n}",
    "o": [
      "demo",
      "temp",
      "Error",
      "Undefined"
    ]
  },
  {
    "q": "Which method is used to detach a thread from the main thread?",
    "o": [
      "detach()",
      "join()",
      "terminate()",
      "release()"
    ]
  },
  {
    "q": "What is the output of the following multithreading code?",
    "c": "#include <iostream>\n#include <thread>\nvoid run() { std::cout << \"Run\"; }\nint main() {\n    std::thread t(run);\n    t.detach();\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    return 0;\n}",
    "o": [
      "Run",
      "Error",
      "Nothing",
      "Compilation failed"
    ]
  },
  {
    "q": "Which keyword is used to access a global variable when it is shadowed by a local one?",
    "o": [
      "Scope resolution operator (::)",
      "extern",
      "static",
      "global"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "#include <iostream>\nint x = 30;\nint main() {\n    int x = 10;\n    std::cout << ::x;\n    return 0;\n}",
    "o": [
      "30",
      "10",
      "Compilation Error",
      "Undefined"
    ]
  },
  {
    "q": "Which smart pointer automatically deletes the object when the last owner goes out of scope?",
    "o": [
      "std::shared_ptr",
      "std::weak_ptr",
      "std::unique_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What is the output of this code using shared_ptr?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> a = std::make_shared<int>(5);\n    std::shared_ptr<int> b = a;\n    std::cout << a.use_count();\n    return 0;\n}",
    "o": [
      "2",
      "1",
      "5",
      "0"
    ]
  },
  {
    "q": "Why is move semantics preferred over copy semantics for large resources?",
    "o": [
      "To avoid unnecessary deep copies",
      "To ensure object safety",
      "To simplify constructor logic",
      "To enhance type casting"
    ]
  },
  {
    "q": "What does this code output after move operation?",
    "c": "#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v1 = {7, 8};\n    std::vector<int> v2 = std::move(v1);\n    std::cout << v2.size();\n    return 0;\n}",
    "o": [
      "2",
      "0",
      "7",
      "Compilation error"
    ]
  },
  {
    "q": "Which method in C++ joins the execution of a thread with the main thread?",
    "o": [
      "join()",
      "run()",
      "wait()",
      "sync()"
    ]
  },
  {
    "q": "What does this thread code do?",
    "c": "#include <iostream>\n#include <thread>\nvoid greet() { std::cout << \"Hi\"; }\nint main() {\n    std::thread t1(greet);\n    t1.join();\n    return 0;\n}",
    "o": [
      "Hi",
      "Nothing",
      "Error",
      "main"
    ]
  },
  {
    "q": "Which of the following allows defining a namespace inside another namespace?",
    "o": [
      "Nested namespaces",
      "Inline namespaces",
      "Static namespaces",
      "Global namespaces"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nnamespace Outer {\n    namespace Inner {\n        int x = 12;\n    }\n}\nint main() {\n    std::cout << Outer::Inner::x;\n    return 0;\n}",
    "o": [
      "12",
      "0",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "Which smart pointer type can be created only once and transferred but not copied?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What is the output of this unique_ptr transfer?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> p1 = std::make_unique<int>(100);\n    std::unique_ptr<int> p2 = std::move(p1);\n    std::cout << *p2;\n    return 0;\n}",
    "o": [
      "100",
      "0",
      "Undefined",
      "Error"
    ]
  },
  {
    "q": "Which statement is true about move constructors?",
    "o": [
      "They enable transferring ownership of resources",
      "They duplicate dynamic memory safely",
      "They delete all heap data",
      "They enforce const correctness"
    ]
  },
  {
    "q": "What is the effect of the following move assignment?",
    "c": "#include <iostream>\n#include <string>\nint main() {\n    std::string s1 = \"Hello\";\n    std::string s2;\n    s2 = std::move(s1);\n    std::cout << s2;\n    return 0;\n}",
    "o": [
      "Hello",
      "s1",
      "Error",
      "Nothing"
    ]
  },
  {
    "q": "Which header must be included to use std::thread in C++?",
    "o": [
      "<thread>",
      "<pthread>",
      "<concurrency>",
      "<multithreading>"
    ]
  },
  {
    "q": "What does this multithreaded code output?",
    "c": "#include <iostream>\n#include <thread>\nvoid hello() { std::cout << \"Hello\"; }\nint main() {\n    std::thread t(hello);\n    t.join();\n    return 0;\n}",
    "o": [
      "Hello",
      "main",
      "Error",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following enables aliasing a deeply nested namespace with a shorter name?",
    "o": [
      "Namespace alias",
      "Inline namespace",
      "Anonymous namespace",
      "Global namespace"
    ]
  },
  {
    "q": "What is the output of this aliasing example?",
    "c": "#include <iostream>\nnamespace company {\n    namespace project {\n        void display() { std::cout << \"Alias Works\"; }\n    }\n}\nnamespace cp = company::project;\nint main() {\n    cp::display();\n    return 0;\n}",
    "o": [
      "Alias Works",
      "Error",
      "display",
      "Nothing"
    ]
  },
  {
    "q": "Which smart pointer provides non-owning reference to an object managed by shared_ptr?",
    "o": [
      "std::weak_ptr",
      "std::unique_ptr",
      "std::shared_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What will this weak_ptr-related code print?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> sp = std::make_shared<int>(7);\n    std::weak_ptr<int> wp = sp;\n    if (auto temp = wp.lock()) {\n        std::cout << *temp;\n    }\n    return 0;\n}",
    "o": [
      "7",
      "0",
      "null",
      "Compilation error"
    ]
  },
  {
    "q": "What happens when a moved-from object is used without reinitialization?",
    "o": [
      "Its state is valid but unspecified",
      "It causes a runtime crash",
      "It behaves like a null pointer",
      "It throws a move exception"
    ]
  },
  {
    "q": "What is the result of this move constructor usage?",
    "c": "#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v1 = {1, 2, 3};\n    std::vector<int> v2(std::move(v1));\n    std::cout << v2.size();\n    return 0;\n}",
    "o": [
      "3",
      "0",
      "1",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following best describes `std::thread::join()`?",
    "o": [
      "Blocks the calling thread until the thread finishes execution",
      "Terminates the thread immediately",
      "Runs the thread asynchronously",
      "Waits for user input before joining"
    ]
  },
  {
    "q": "What is the output of this thread demo?",
    "c": "#include <iostream>\n#include <thread>\nvoid show() { std::cout << \"Threaded\"; }\nint main() {\n    std::thread t1(show);\n    t1.join();\n    return 0;\n}",
    "o": [
      "Threaded",
      "show",
      "Compilation error",
      "0"
    ]
  },
  {
    "q": "What does an anonymous namespace restrict access to?",
    "o": [
      "Current translation unit",
      "Global scope",
      "All classes",
      "Friend functions"
    ]
  },
  {
    "q": "What is the output of the following namespace example?",
    "c": "#include <iostream>\nnamespace {\n    int secret() { return 99; }\n}\nint main() {\n    std::cout << secret();\n    return 0;\n}",
    "o": [
      "99",
      "0",
      "Error",
      "secret"
    ]
  },
  {
    "q": "What happens when `std::unique_ptr` goes out of scope?",
    "o": [
      "It automatically deletes the managed object",
      "It transfers ownership",
      "It throws an exception",
      "It resets the memory to zero"
    ]
  },
  {
    "q": "What does this code print using unique_ptr?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> up = std::make_unique<int>(42);\n    std::cout << *up;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "nullptr",
      "Error"
    ]
  },
  {
    "q": "What is the role of `std::move` in move semantics?",
    "o": [
      "Converts an l-value to an r-value reference",
      "Transfers memory ownership to the OS",
      "Performs a shallow copy",
      "Prevents resource leaks"
    ]
  },
  {
    "q": "What is the effect of the following move assignment?",
    "c": "#include <iostream>\n#include <string>\nint main() {\n    std::string a = \"data\";\n    std::string b = std::move(a);\n    std::cout << b;\n    return 0;\n}",
    "o": [
      "data",
      "a",
      "Error",
      "Empty string"
    ]
  },
  {
    "q": "What does `std::this_thread::sleep_for()` do?",
    "o": [
      "Pauses current thread for a given duration",
      "Blocks all active threads",
      "Suspends thread creation",
      "Terminates thread execution"
    ]
  },
  {
    "q": "What does this multithreading code output?",
    "c": "#include <iostream>\n#include <thread>\nvoid work() { std::cout << \"Working\"; }\nint main() {\n    std::thread t(work);\n    t.join();\n    return 0;\n}",
    "o": [
      "Working",
      "Error",
      "Compilation failure",
      "0"
    ]
  },
  {
    "q": "What is the purpose of the scope resolution operator `::` in C++?",
    "o": [
      "To access global or namespace-level identifiers",
      "To access private class members",
      "To declare default arguments",
      "To initialize member variables"
    ]
  },
  {
    "q": "What is the output of the following scope resolution example?",
    "c": "#include <iostream>\nint value = 20;\nint main() {\n    int value = 10;\n    std::cout << ::value;\n    return 0;\n}",
    "o": [
      "20",
      "10",
      "0",
      "Compilation Error"
    ]
  },
  {
    "q": "Which smart pointer is recommended when multiple owners share the same resource?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::weak_ptr",
      "std::raw_ptr"
    ]
  },
  {
    "q": "What will this shared_ptr code output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    auto sp = std::make_shared<int>(100);\n    std::cout << *sp;\n    return 0;\n}",
    "o": [
      "100",
      "0",
      "nullptr",
      "Error"
    ]
  },
  {
    "q": "Which of the following best describes move assignment?",
    "o": [
      "Transfers resources from one object to another without copying",
      "Copies data using deep copy",
      "Allocates a new resource every time",
      "Deletes the original object"
    ]
  },
  {
    "q": "What is the output of this move operation?",
    "c": "#include <iostream>\n#include <string>\nint main() {\n    std::string x = \"abc\";\n    std::string y = std::move(x);\n    std::cout << y;\n    return 0;\n}",
    "o": [
      "abc",
      "x",
      "Error",
      "0"
    ]
  },
  {
    "q": "Which of the following creates and runs a new thread in C++?",
    "o": [
      "std::thread t(func);",
      "thread.create(func);",
      "pthread_run(func);",
      "std::launch::async(func);"
    ]
  },
  {
    "q": "What is the output of this basic thread program?",
    "c": "#include <iostream>\n#include <thread>\nvoid hello() { std::cout << \"Hello Thread\"; }\nint main() {\n    std::thread t(hello);\n    t.join();\n    return 0;\n}",
    "o": [
      "Hello Thread",
      "Hello",
      "Thread",
      "Error"
    ]
  },
  {
    "q": "Which of the following allows referring to a variable in the global namespace when a local variable shadows it?",
    "o": [
      "The scope resolution operator (::)",
      "The dot operator (.)",
      "The arrow operator (->)",
      "The ampersand (&)"
    ]
  },
  {
    "q": "What is the output of this scope resolution usage?",
    "c": "#include <iostream>\nint number = 50;\nint main() {\n    int number = 10;\n    std::cout << ::number;\n    return 0;\n}",
    "o": [
      "50",
      "10",
      "0",
      "Error"
    ]
  },
  {
    "q": "Which smart pointer automatically manages memory and ensures a single owner?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What will this smart pointer code output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> ptr(new int(88));\n    std::cout << *ptr;\n    return 0;\n}",
    "o": [
      "88",
      "0",
      "nullptr",
      "Error"
    ]
  },
  {
    "q": "Which C++11 feature is essential for implementing move semantics?",
    "o": [
      "Rvalue references",
      "Virtual destructors",
      "Explicit constructors",
      "Operator overloading"
    ]
  },
  {
    "q": "What will this code output using move semantics?",
    "c": "#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v1 = {5, 6, 7};\n    std::vector<int> v2 = std::move(v1);\n    std::cout << v2[0];\n    return 0;\n}",
    "o": [
      "5",
      "0",
      "Error",
      "7"
    ]
  },
  {
    "q": "Which C++ standard introduced `std::thread`?",
    "o": [
      "C++11",
      "C++03",
      "C++98",
      "C++17"
    ]
  },
  {
    "q": "What does the following multithreaded code output?",
    "c": "#include <iostream>\n#include <thread>\nvoid run() { std::cout << \"Running...\"; }\nint main() {\n    std::thread t(run);\n    t.join();\n    return 0;\n}",
    "o": [
      "Running...",
      "run",
      "Compilation error",
      "Nothing"
    ]
  },
  {
    "q": "What does the `inline namespace` feature in C++ allow?",
    "o": [
      "Accessing its members without explicit qualification",
      "Creating anonymous scopes",
      "Preventing multiple definition errors",
      "Avoiding name collisions with global functions"
    ]
  },
  {
    "q": "What is the output of this namespace alias example?",
    "c": "#include <iostream>\nnamespace longname {\n    void greet() { std::cout << \"Hello!\"; }\n}\nnamespace ln = longname;\nint main() {\n    ln::greet();\n    return 0;\n}",
    "o": [
      "Hello!",
      "greet",
      "longname",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following correctly declares a shared ownership of a resource?",
    "o": [
      "std::shared_ptr<int> p = std::make_shared<int>(5);",
      "std::unique_ptr<int> p = new int(5);",
      "std::weak_ptr<int> p = std::make_shared<int>(5);",
      "std::auto_ptr<int> p(new int(5));"
    ]
  },
  {
    "q": "What will be printed by this smart pointer code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    auto p1 = std::make_shared<int>(123);\n    auto p2 = p1;\n    std::cout << *p2;\n    return 0;\n}",
    "o": [
      "123",
      "0",
      "nullptr",
      "Error"
    ]
  },
  {
    "q": "Which operator must be overloaded to support move assignment?",
    "o": [
      "operator=",
      "operator>>",
      "operator->",
      "operator&"
    ]
  },
  {
    "q": "What will the following move constructor code output?",
    "c": "#include <iostream>\n#include <utility>\nclass A {\npublic:\n    A() { std::cout << \"Default \"; }\n    A(A&&) { std::cout << \"Move \"; }\n};\nint main() {\n    A a;\n    A b = std::move(a);\n    return 0;\n}",
    "o": [
      "Default Move ",
      "Move Default ",
      "Move ",
      "Default "
    ]
  },
  {
    "q": "What is required to safely update shared data in multiple threads?",
    "o": [
      "A mutex or synchronization primitive",
      "A volatile variable",
      "Separate functions",
      "Using inline functions"
    ]
  },
  {
    "q": "What does this simple threaded program print?",
    "c": "#include <iostream>\n#include <thread>\nvoid print() { std::cout << \"Thread Active\"; }\nint main() {\n    std::thread t(print);\n    t.join();\n    return 0;\n}",
    "o": [
      "Thread Active",
      "Active",
      "Thread",
      "Compilation failed"
    ]
  },
  {
    "q": "Which keyword in C++ can be used to open a nested namespace with less syntax?",
    "o": [
      "namespace A::B",
      "namespace A->B",
      "namespace A.B",
      "namespace A:B"
    ]
  },
  {
    "q": "What is the output of the following code using scope resolution?",
    "c": "#include <iostream>\nint value = 100;\nint main() {\n    int value = 50;\n    std::cout << ::value;\n    return 0;\n}",
    "o": [
      "100",
      "50",
      "0",
      "Error"
    ]
  },
  {
    "q": "Which smart pointer allows observing an object managed by a shared_ptr without affecting its reference count?",
    "o": [
      "std::weak_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::shared_ptr"
    ]
  },
  {
    "q": "What does the following smart pointer code output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    auto sp = std::make_shared<int>(77);\n    std::weak_ptr<int> wp = sp;\n    std::cout << *wp.lock();\n    return 0;\n}",
    "o": [
      "77",
      "0",
      "Error",
      "nullptr"
    ]
  },
  {
    "q": "When is a move constructor called?",
    "o": [
      "When an r-value is used to initialize an object",
      "When an object is copied using `=`",
      "When a pointer is passed to a function",
      "When a reference is used to bind to a const object"
    ]
  },
  {
    "q": "What is the output of the following move constructor usage?",
    "c": "#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> a = {1, 2, 3};\n    std::vector<int> b = std::move(a);\n    std::cout << b.size();\n    return 0;\n}",
    "o": [
      "3",
      "0",
      "1",
      "Error"
    ]
  },
  {
    "q": "Which of the following ensures that a thread completes before main thread exits?",
    "o": [
      "Calling join() on the thread",
      "Calling detach() on the thread",
      "Using thread.sleep()",
      "Declaring thread as static"
    ]
  },
  {
    "q": "What does this multithreading code output?",
    "c": "#include <iostream>\n#include <thread>\nvoid task() { std::cout << \"Task Done\"; }\nint main() {\n    std::thread t(task);\n    t.join();\n    return 0;\n}",
    "o": [
      "Task Done",
      "Done",
      "Error",
      "Nothing"
    ]
  },
  {
    "q": "What does the scope resolution operator `::` allow in C++?",
    "o": [
      "Accessing a global variable when a local variable has the same name",
      "Defining a class inside a function",
      "Creating an anonymous namespace",
      "Overloading an operator"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nnamespace X {\n    int val = 42;\n}\nint main() {\n    std::cout << X::val;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "Error",
      "X"
    ]
  },
  {
    "q": "Which smart pointer automatically deletes the object when the last reference is destroyed?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What will this smart pointer code output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> sp1 = std::make_shared<int>(9);\n    std::shared_ptr<int> sp2 = sp1;\n    std::cout << sp1.use_count();\n    return 0;\n}",
    "o": [
      "2",
      "1",
      "0",
      "Error"
    ]
  },
  {
    "q": "Which of the following best describes move semantics?",
    "o": [
      "It transfers ownership of a resource without copying",
      "It duplicates data into a new object",
      "It prevents rvalues from being passed to functions",
      "It uses reference counting"
    ]
  },
  {
    "q": "What is the output of this move operation?",
    "c": "#include <iostream>\n#include <string>\nint main() {\n    std::string a = \"test\";\n    std::string b = std::move(a);\n    std::cout << b;\n    return 0;\n}",
    "o": [
      "test",
      "a",
      "b",
      "Error"
    ]
  },
  {
    "q": "What is the purpose of `std::thread::join()` in multithreading?",
    "o": [
      "Waits for the thread to finish execution",
      "Starts a new thread",
      "Detaches the thread from main thread",
      "Kills a running thread"
    ]
  },
  {
    "q": "What does this multithreading code output?",
    "c": "#include <iostream>\n#include <thread>\nvoid job() { std::cout << \"Working...\"; }\nint main() {\n    std::thread t(job);\n    t.join();\n    return 0;\n}",
    "o": [
      "Working...",
      "Error",
      "job",
      "Nothing"
    ]
  },
  {
    "q": "Which C++ feature allows you to group logically related identifiers and avoid naming conflicts?",
    "o": [
      "Namespace",
      "Class",
      "Struct",
      "Macro"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "#include <iostream>\nint x = 20;\nint main() {\n    int x = 10;\n    std::cout << ::x;\n    return 0;\n}",
    "o": [
      "20",
      "10",
      "0",
      "Compilation Error"
    ]
  },
  {
    "q": "Which smart pointer type enforces unique ownership and cannot be copied?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What is the output of this code using unique_ptr?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> uptr = std::make_unique<int>(5);\n    std::cout << *uptr;\n    return 0;\n}",
    "o": [
      "5",
      "0",
      "nullptr",
      "Compilation Error"
    ]
  },
  {
    "q": "Which C++11 feature allows moving resources instead of copying them?",
    "o": [
      "Move semantics",
      "RAII",
      "Templates",
      "Virtual functions"
    ]
  },
  {
    "q": "What will the following move operation output?",
    "c": "#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> a = {4, 5};\n    std::vector<int> b = std::move(a);\n    std::cout << b[0];\n    return 0;\n}",
    "o": [
      "4",
      "5",
      "0",
      "Error"
    ]
  },
  {
    "q": "Which function is used to check if a thread is joinable before joining?",
    "o": [
      "joinable()",
      "check()",
      "isRunning()",
      "active()"
    ]
  },
  {
    "q": "What does this multithreading code output?",
    "c": "#include <iostream>\n#include <thread>\nvoid sayHi() { std::cout << \"Hi\"; }\nint main() {\n    std::thread t1(sayHi);\n    if (t1.joinable()) t1.join();\n    return 0;\n}",
    "o": [
      "Hi",
      "Error",
      "Nothing",
      "Thread"
    ]
  },
  {
    "q": "Which keyword allows you to avoid repeating a namespace name for every identifier?",
    "o": [
      "using",
      "auto",
      "typedef",
      "extern"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "#include <iostream>\nnamespace A {\n    int value = 10;\n}\nnamespace B {\n    int value = 20;\n}\nint main() {\n    std::cout << A::value;\n    return 0;\n}",
    "o": [
      "10",
      "20",
      "0",
      "Error"
    ]
  },
  {
    "q": "Which smart pointer type does not manage the lifetime of the object it points to?",
    "o": [
      "std::weak_ptr",
      "std::unique_ptr",
      "std::shared_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What will this code using weak_ptr output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> sp = std::make_shared<int>(100);\n    std::weak_ptr<int> wp = sp;\n    if (auto spt = wp.lock()) {\n        std::cout << *spt;\n    }\n    return 0;\n}",
    "o": [
      "100",
      "0",
      "Error",
      "null"
    ]
  },
  {
    "q": "Which special member function is explicitly defined to enable move semantics?",
    "o": [
      "Move constructor",
      "Copy constructor",
      "Virtual destructor",
      "Default constructor"
    ]
  },
  {
    "q": "What is the result of this move operation?",
    "c": "#include <iostream>\n#include <string>\nint main() {\n    std::string x = \"Hello\";\n    std::string y = std::move(x);\n    std::cout << y;\n    return 0;\n}",
    "o": [
      "Hello",
      "x",
      "y",
      "Error"
    ]
  },
  {
    "q": "Which of the following headers is required for using std::thread?",
    "o": [
      "<thread>",
      "<pthread.h>",
      "<future>",
      "<mutex>"
    ]
  },
  {
    "q": "What does the following code output if executed?",
    "c": "#include <iostream>\n#include <thread>\nvoid func() {\n    std::cout << \"Running\";\n}\nint main() {\n    std::thread t(func);\n    t.join();\n    return 0;\n}",
    "o": [
      "Running",
      "Nothing",
      "Error",
      "Main"
    ]
  },
  {
    "q": "What is the primary purpose of the scope resolution operator `::`?",
    "o": [
      "To access global or namespace-level identifiers",
      "To define a function inside a class",
      "To initialize member variables",
      "To dereference a pointer"
    ]
  },
  {
    "q": "What is the output of this code using nested namespaces?",
    "c": "#include <iostream>\nnamespace A {\n    namespace B {\n        int value = 50;\n    }\n}\nint main() {\n    std::cout << A::B::value;\n    return 0;\n}",
    "o": [
      "50",
      "0",
      "Error",
      "A::B"
    ]
  },
  {
    "q": "Which of the following smart pointers can detect if the managed object has already been deleted?",
    "o": [
      "std::weak_ptr",
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What is the output of the following shared pointer usage?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    auto p = std::make_shared<int>(99);\n    std::cout << *p;\n    return 0;\n}",
    "o": [
      "99",
      "0",
      "Error",
      "null"
    ]
  },
  {
    "q": "What does move semantics optimize in C++?",
    "o": [
      "Avoiding unnecessary deep copies of temporary objects",
      "Reducing compile-time warnings",
      "Creating threads in parallel",
      "Overloading operators"
    ]
  },
  {
    "q": "What is the output of the following move constructor example?",
    "c": "#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v1 = {1, 2};\n    std::vector<int> v2(std::move(v1));\n    std::cout << v2.size();\n    return 0;\n}",
    "o": [
      "2",
      "0",
      "1",
      "Error"
    ]
  },
  {
    "q": "Which of the following is true about `std::thread::detach()`?",
    "o": [
      "It allows the thread to run independently of the main thread",
      "It blocks the main thread until the thread finishes",
      "It terminates the thread immediately",
      "It joins two threads together"
    ]
  },
  {
    "q": "What will be printed when this detached thread code runs?",
    "c": "#include <iostream>\n#include <thread>\nvoid work() { std::cout << \"Working\"; }\nint main() {\n    std::thread t(work);\n    t.detach();\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    return 0;\n}",
    "o": [
      "Working",
      "Error",
      "Nothing",
      "Detached"
    ]
  },
  {
    "q": "What does the keyword `inline` mean when used with a namespace?",
    "o": [
      "It allows multiple definitions of the same namespace across translation units.",
      "It inlines all functions defined in the namespace.",
      "It forces all members to be optimized.",
      "It limits scope of the namespace to a single file."
    ]
  },
  {
    "q": "What is the output of the following scope resolution example?",
    "c": "#include <iostream>\nint value = 7;\nint main() {\n    int value = 3;\n    std::cout << ::value;\n    return 0;\n}",
    "o": [
      "7",
      "3",
      "0",
      "Compilation Error"
    ]
  },
  {
    "q": "What will happen if `std::unique_ptr` is copied?",
    "o": [
      "It will cause a compilation error.",
      "It transfers ownership automatically.",
      "It behaves like `shared_ptr`.",
      "It will silently fail."
    ]
  },
  {
    "q": "What is the output of the following smart pointer code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> ptr(new int(42));\n    std::cout << *ptr;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "nullptr",
      "Error"
    ]
  },
  {
    "q": "Which operation is used to transfer resources during a move operation?",
    "o": [
      "std::move",
      "std::copy",
      "std::forward",
      "std::swap"
    ]
  },
  {
    "q": "What does the following move assignment code output?",
    "c": "#include <iostream>\n#include <string>\nint main() {\n    std::string a = \"One\";\n    std::string b = \"Two\";\n    b = std::move(a);\n    std::cout << b;\n    return 0;\n}",
    "o": [
      "One",
      "Two",
      "Error",
      "Move"
    ]
  },
  {
    "q": "Which of the following best describes `std::thread::join()`?",
    "o": [
      "It blocks the current thread until the associated thread finishes.",
      "It runs the thread in parallel with the current one.",
      "It merges two thread functions into one.",
      "It resumes a paused thread."
    ]
  },
  {
    "q": "What is the output of this multithreaded program?",
    "c": "#include <iostream>\n#include <thread>\nvoid task() {\n    std::cout << \"Threading\";\n}\nint main() {\n    std::thread t(task);\n    t.join();\n    return 0;\n}",
    "o": [
      "Threading",
      "Error",
      "Nothing",
      "Main"
    ]
  },
  {
    "q": "Which of the following best describes a namespace alias?",
    "o": [
      "It provides a shorter name for a long namespace.",
      "It creates a duplicate namespace.",
      "It inherits another namespace's content.",
      "It copies a namespace to another file."
    ]
  },
  {
    "q": "What will this program print?",
    "c": "#include <iostream>\nnamespace long_namespace_name {\n    int value = 21;\n}\nnamespace lnn = long_namespace_name;\nint main() {\n    std::cout << lnn::value;\n    return 0;\n}",
    "o": [
      "21",
      "0",
      "lnn::value",
      "Compilation Error"
    ]
  },
  {
    "q": "Which smart pointer automatically deletes the object when the last reference goes out of scope?",
    "o": [
      "std::shared_ptr",
      "std::weak_ptr",
      "std::unique_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    auto ptr1 = std::make_shared<int>(9);\n    auto ptr2 = ptr1;\n    std::cout << *ptr2;\n    return 0;\n}",
    "o": [
      "9",
      "0",
      "Error",
      "nullptr"
    ]
  },
  {
    "q": "When should move semantics be preferred over copy semantics?",
    "o": [
      "When working with temporary or expensive-to-copy resources",
      "When variables are constant",
      "When using primitive types",
      "When using multiple inheritance"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> a = {4, 5};\n    std::vector<int> b;\n    b = std::move(a);\n    std::cout << b[0];\n    return 0;\n}",
    "o": [
      "4",
      "5",
      "0",
      "Error"
    ]
  },
  {
    "q": "Which of the following is true about std::thread?",
    "o": [
      "Each std::thread represents a single thread of execution.",
      "It requires a thread pool to operate.",
      "It only works on POSIX systems.",
      "It is a blocking object by default."
    ]
  },
  {
    "q": "What does this code do?",
    "c": "#include <iostream>\n#include <thread>\nvoid job() {\n    std::cout << \"Job done\";\n}\nint main() {\n    std::thread t(job);\n    t.join();\n    return 0;\n}",
    "o": [
      "Prints 'Job done'",
      "Terminates with exception",
      "Does nothing",
      "Deadlocks"
    ]
  },
  {
    "q": "What is the correct way to access a global variable when a local variable of the same name exists?",
    "o": [
      "Use the scope resolution operator (::)",
      "Use the 'global' keyword",
      "Use the 'extern' keyword",
      "Use type casting"
    ]
  },
  {
    "q": "What is the output of this code using global scope resolution?",
    "c": "#include <iostream>\nint value = 100;\nint main() {\n    int value = 50;\n    std::cout << ::value;\n    return 0;\n}",
    "o": [
      "100",
      "50",
      "Error",
      "0"
    ]
  },
  {
    "q": "Which smart pointer type ensures exclusive ownership of a resource?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What does this code print when using unique_ptr?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> ptr = std::make_unique<int>(25);\n    std::cout << *ptr;\n    return 0;\n}",
    "o": [
      "25",
      "0",
      "nullptr",
      "Error"
    ]
  },
  {
    "q": "Which situation best benefits from move semantics?",
    "o": [
      "Transferring ownership of large objects without copying",
      "Sharing ownership between multiple objects",
      "Referencing an object without extending its lifetime",
      "Creating compile-time constants"
    ]
  },
  {
    "q": "What will this program output after a move assignment?",
    "c": "#include <iostream>\n#include <string>\nint main() {\n    std::string a = \"Alpha\";\n    std::string b;\n    b = std::move(a);\n    std::cout << b;\n    return 0;\n}",
    "o": [
      "Alpha",
      "a",
      "b",
      "Error"
    ]
  },
  {
    "q": "Which header file is required to use std::thread?",
    "o": [
      "<thread>",
      "<pthread>",
      "<multithread>",
      "<concurrency>"
    ]
  },
  {
    "q": "What does this code print using two threads?",
    "c": "#include <iostream>\n#include <thread>\nvoid task() { std::cout << \"Run \"; }\nint main() {\n    std::thread t1(task);\n    std::thread t2(task);\n    t1.join(); t2.join();\n    return 0;\n}",
    "o": [
      "Run Run ",
      "Run",
      "RunRunRun",
      "Error"
    ]
  },
  {
    "q": "Which of the following allows resolving ambiguity between functions from different namespaces?",
    "o": [
      "Using the scope resolution operator",
      "Using dynamic_cast",
      "Using inline keyword",
      "Using typedef"
    ]
  },
  {
    "q": "What is the output of the following program using nested namespaces?",
    "c": "#include <iostream>\nnamespace A { namespace B { int x = 10; } }\nint main() {\n    std::cout << A::B::x;\n    return 0;\n}",
    "o": [
      "10",
      "0",
      "Error",
      "undefined"
    ]
  },
  {
    "q": "Which smart pointer can help avoid cyclic references?",
    "o": [
      "std::weak_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What is the output of this code using shared_ptr and weak_ptr?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> sp = std::make_shared<int>(88);\n    std::weak_ptr<int> wp = sp;\n    if (!wp.expired()) std::cout << *wp.lock();\n    return 0;\n}",
    "o": [
      "88",
      "0",
      "Error",
      "nullptr"
    ]
  },
  {
    "q": "What does std::move do?",
    "o": [
      "Converts an lvalue to an rvalue reference",
      "Performs a deep copy of an object",
      "Forces a shallow copy of an object",
      "Deallocates memory safely"
    ]
  },
  {
    "q": "What will be printed after this move constructor usage?",
    "c": "#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> a = {10, 20};\n    std::vector<int> b(std::move(a));\n    std::cout << b[1];\n    return 0;\n}",
    "o": [
      "20",
      "10",
      "0",
      "Error"
    ]
  },
  {
    "q": "Which of the following is a valid reason to call std::thread::detach()?",
    "o": [
      "To allow the thread to run independently of the main thread",
      "To cancel the thread after a timeout",
      "To block the main thread until the thread completes",
      "To share resources between threads"
    ]
  },
  {
    "q": "What will this multithreading code print?",
    "c": "#include <iostream>\n#include <thread>\nvoid run() { std::cout << \"Hello \"; }\nint main() {\n    std::thread t(run);\n    t.detach();\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    return 0;\n}",
    "o": [
      "Hello ",
      "Nothing",
      "Runtime Error",
      "Compilation Error"
    ]
  },
  {
    "q": "Which of the following is true about unnamed namespaces in C++?",
    "o": [
      "They restrict the visibility of identifiers to the translation unit.",
      "They are accessible globally.",
      "They allow function overloading across translation units.",
      "They prevent linking with standard libraries."
    ]
  },
  {
    "q": "What is the output of this program using unnamed namespace?",
    "c": "#include <iostream>\nnamespace {\n    int secret = 42;\n}\nint main() {\n    std::cout << secret;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "Error",
      "undefined"
    ]
  },
  {
    "q": "Which smart pointer type does not manage ownership and must be used with another smart pointer?",
    "o": [
      "std::weak_ptr",
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What will be the output of this shared_ptr use count example?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> a = std::make_shared<int>(5);\n    std::shared_ptr<int> b = a;\n    std::cout << a.use_count();\n    return 0;\n}",
    "o": [
      "2",
      "1",
      "0",
      "Error"
    ]
  },
  {
    "q": "Which is a key characteristic of move constructors?",
    "o": [
      "They take an rvalue reference as a parameter.",
      "They are always implicitly generated.",
      "They accept only const references.",
      "They increase the use count of smart pointers."
    ]
  },
  {
    "q": "What is the output of this code involving a moved string?",
    "c": "#include <iostream>\n#include <string>\nint main() {\n    std::string s1 = \"world\";\n    std::string s2 = std::move(s1);\n    std::cout << s2;\n    return 0;\n}",
    "o": [
      "world",
      "s1",
      "Error",
      "undefined"
    ]
  },
  {
    "q": "What does std::thread::join() do in C++ multithreading?",
    "o": [
      "Waits for the thread to finish execution before proceeding.",
      "Terminates the thread immediately.",
      "Detaches the thread from the main thread.",
      "Pauses the thread indefinitely."
    ]
  },
  {
    "q": "What is a potential issue if std::thread::join is not called?",
    "o": [
      "The program may terminate abnormally.",
      "The thread will continue running forever.",
      "Memory will leak permanently.",
      "All threads will be joined automatically."
    ]
  },
  {
    "q": "Which keyword allows functions or variables to be accessed from another namespace?",
    "o": [
      "using",
      "static",
      "export",
      "mutable"
    ]
  },
  {
    "q": "What is the output of the following code using 'using' directive?",
    "c": "#include <iostream>\nnamespace A { int x = 99; }\nusing namespace A;\nint main() {\n    std::cout << x;\n    return 0;\n}",
    "o": [
      "99",
      "0",
      "Error",
      "undefined"
    ]
  },
  {
    "q": "Which smart pointer is best suited for exclusive resource ownership and non-copyable semantics?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::intrusive_ptr"
    ]
  },
  {
    "q": "What is the output of the following unique_ptr usage?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> p(new int(123));\n    std::cout << *p;\n    return 0;\n}",
    "o": [
      "123",
      "0",
      "Error",
      "nullptr"
    ]
  },
  {
    "q": "Which feature enables transferring resources instead of copying them?",
    "o": [
      "Move semantics",
      "Copy constructors",
      "Smart pointers",
      "Virtual functions"
    ]
  },
  {
    "q": "What is the effect of calling std::move on a container?",
    "o": [
      "Transfers ownership without copying data",
      "Performs a deep copy of all elements",
      "Clears the container immediately",
      "Returns a shared_ptr of the container"
    ]
  },
  {
    "q": "Which of the following functions as a unit of execution in C++?",
    "o": [
      "std::thread",
      "std::mutex",
      "std::future",
      "std::condition_variable"
    ]
  },
  {
    "q": "What will this multithreading program likely print?",
    "c": "#include <iostream>\n#include <thread>\nvoid f() { std::cout << \"Hi \"; }\nint main() {\n    std::thread t1(f), t2(f);\n    t1.join(); t2.join();\n    return 0;\n}",
    "o": [
      "Hi Hi ",
      "Hi",
      "Compilation Error",
      "Segmentation Fault"
    ]
  },
  {
    "q": "What does the scope resolution operator (::) allow in C++?",
    "o": [
      "Accessing global or namespace-level identifiers",
      "Invoking virtual functions at runtime",
      "Handling exceptions using try-catch",
      "Overloading operators"
    ]
  },
  {
    "q": "What will be printed by this code using global scope resolution?",
    "c": "#include <iostream>\nint x = 100;\nint main() {\n    int x = 50;\n    std::cout << ::x;\n    return 0;\n}",
    "o": [
      "100",
      "50",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "What is a key advantage of std::shared_ptr over std::unique_ptr?",
    "o": [
      "Allows multiple shared ownership of a resource",
      "Consumes less memory",
      "Automatically avoids circular dependencies",
      "Provides faster performance"
    ]
  },
  {
    "q": "What will the following program output when using shared_ptr?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    auto sp = std::make_shared<int>(42);\n    std::shared_ptr<int> sp2 = sp;\n    std::cout << sp.use_count();\n    return 0;\n}",
    "o": [
      "2",
      "1",
      "0",
      "Error"
    ]
  },
  {
    "q": "What kind of reference does a move constructor take?",
    "o": [
      "An rvalue reference (T&&)",
      "A const lvalue reference",
      "A pointer",
      "A reference to const rvalue"
    ]
  },
  {
    "q": "What does the following code demonstrate?",
    "c": "#include <iostream>\n#include <string>\nint main() {\n    std::string s1 = \"abc\";\n    std::string s2 = std::move(s1);\n    std::cout << s2;\n    return 0;\n}",
    "o": [
      "Move semantics",
      "Copy constructor",
      "Virtual destructor",
      "RAII"
    ]
  },
  {
    "q": "Which header is needed to use std::thread in C++?",
    "o": [
      "<thread>",
      "<mutex>",
      "<atomic>",
      "<chrono>"
    ]
  },
  {
    "q": "What does the following program demonstrate?",
    "c": "#include <iostream>\n#include <thread>\nvoid printMsg() { std::cout << \"Running\"; }\nint main() {\n    std::thread t(printMsg);\n    t.join();\n    return 0;\n}",
    "o": [
      "Basic multithreading with join",
      "Thread detachment",
      "Race condition",
      "Compile-time polymorphism"
    ]
  },
  {
    "q": "Which of the following allows multiple namespaces to be used in the same scope without ambiguity?",
    "o": [
      "Qualified names with scope resolution operator",
      "Macros",
      "Inline functions",
      "Preprocessor directives"
    ]
  },
  {
    "q": "What is the output of the following code using nested namespaces?",
    "c": "#include <iostream>\nnamespace A { namespace B { void func() { std::cout << \"Hello\"; } } }\nint main() {\n    A::B::func();\n    return 0;\n}",
    "o": [
      "Hello",
      "func",
      "Error",
      "B::func"
    ]
  },
  {
    "q": "Which smart pointer automatically deletes the object it owns when it goes out of scope and cannot be copied?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What will the following code output when using unique_ptr?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> p1 = std::make_unique<int>(42);\n    std::cout << *p1;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "nullptr",
      "Error"
    ]
  },
  {
    "q": "What is the key benefit of move semantics in performance-critical applications?",
    "o": [
      "Avoids deep copies by transferring ownership",
      "Ensures thread safety automatically",
      "Simplifies exception handling",
      "Avoids memory leaks by reference counting"
    ]
  },
  {
    "q": "What will be the state of the source object after a move operation?",
    "o": [
      "Valid but unspecified state",
      "Destroyed automatically",
      "Pointing to nullptr",
      "Remains unchanged"
    ]
  },
  {
    "q": "What is the purpose of std::thread::detach()?",
    "o": [
      "Allows a thread to run independently in the background",
      "Stops the thread immediately",
      "Joins multiple threads together",
      "Kills the thread"
    ]
  },
  {
    "q": "What is the output of this multithreading code?",
    "c": "#include <iostream>\n#include <thread>\nvoid run() { std::cout << \"Thread\\n\"; }\nint main() {\n    std::thread t(run);\n    t.detach();\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    return 0;\n}",
    "o": [
      "Thread",
      "Error",
      "Nothing",
      "Main"
    ]
  },
  {
    "q": "What is the primary purpose of a namespace in C++?",
    "o": [
      "To avoid name conflicts by grouping identifiers",
      "To enable function overloading",
      "To define new primitive types",
      "To speed up compilation"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "#include <iostream>\nnamespace one { int value = 10; }\nnamespace two { int value = 20; }\nint main() {\n    std::cout << one::value;\n    return 0;\n}",
    "o": [
      "10",
      "20",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer is best for observing an object managed by std::shared_ptr without affecting its lifetime?",
    "o": [
      "std::weak_ptr",
      "std::unique_ptr",
      "std::scoped_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What will this smart pointer code output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> a = std::make_shared<int>(5);\n    std::weak_ptr<int> b = a;\n    std::cout << a.use_count();\n    return 0;\n}",
    "o": [
      "1",
      "0",
      "2",
      "undefined"
    ]
  },
  {
    "q": "Which of the following best describes move semantics?",
    "o": [
      "Transfers resources instead of copying them",
      "Creates a backup copy of objects in memory",
      "Deletes the object after use",
      "Wraps object pointers in try-catch"
    ]
  },
  {
    "q": "What is the purpose of std::move?",
    "o": [
      "Casts an lvalue to an rvalue to enable move semantics",
      "Deletes dynamically allocated memory",
      "Invokes copy constructor",
      "Forces destructor call"
    ]
  },
  {
    "q": "Which of the following is required to run threads concurrently in C++?",
    "o": [
      "std::thread",
      "std::sync",
      "std::task",
      "std::concurrent"
    ]
  },
  {
    "q": "What is the output of the following multithreading example?",
    "c": "#include <iostream>\n#include <thread>\nvoid job() { std::cout << \"Work\"; }\nint main() {\n    std::thread t1(job);\n    t1.join();\n    return 0;\n}",
    "o": [
      "Work",
      "job",
      "Error",
      "Nothing"
    ]
  },
  {
    "q": "What happens if you use 'using namespace std;' in a large C++ project?",
    "o": [
      "It may cause name collisions with identifiers in other libraries",
      "It improves performance by reducing compilation time",
      "It prevents scope resolution issues",
      "It avoids the need for forward declarations"
    ]
  },
  {
    "q": "What does the following code demonstrate?",
    "c": "#include <iostream>\nnamespace outer {\n    int val = 1;\n    namespace inner {\n        int val = 2;\n    }\n}\nint main() {\n    std::cout << outer::inner::val;\n    return 0;\n}",
    "o": [
      "2",
      "1",
      "Compilation error",
      "Undefined behavior"
    ]
  },
  {
    "q": "Which smart pointer automatically deletes the object when the last reference to it is destroyed?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::raw_ptr",
      "std::weak_ptr"
    ]
  },
  {
    "q": "What is the output of the following smart pointer code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    auto p = std::make_shared<int>(100);\n    auto q = p;\n    std::cout << p.use_count();\n    return 0;\n}",
    "o": [
      "2",
      "1",
      "0",
      "100"
    ]
  },
  {
    "q": "Which of the following best explains the need for move constructors?",
    "o": [
      "To optimize performance by avoiding unnecessary deep copies",
      "To enable inheritance from abstract classes",
      "To ensure safe pointer arithmetic",
      "To avoid multiple inheritance ambiguity"
    ]
  },
  {
    "q": "What is the result of executing this code involving move semantics?",
    "c": "#include <iostream>\n#include <utility>\n#include <vector>\nint main() {\n    std::vector<int> v1 = {1, 2, 3};\n    std::vector<int> v2 = std::move(v1);\n    std::cout << v2.size();\n    return 0;\n}",
    "o": [
      "3",
      "0",
      "undefined",
      "Compilation error"
    ]
  },
  {
    "q": "Which function is used to block the calling thread until the associated thread finishes execution?",
    "o": [
      "join()",
      "detach()",
      "terminate()",
      "wait()"
    ]
  },
  {
    "q": "What will the following multithreading code print?",
    "c": "#include <iostream>\n#include <thread>\nvoid run() { std::cout << \"A\"; }\nint main() {\n    std::thread t(run);\n    t.join();\n    std::cout << \"B\";\n    return 0;\n}",
    "o": [
      "AB",
      "BA",
      "A",
      "B"
    ]
  },
  {
    "q": "Which keyword is used to resolve ambiguity when multiple namespaces have the same identifier?",
    "o": [
      "scope resolution operator (::)",
      "namespace_cast",
      "namespace_override",
      "identifier_resolve"
    ]
  },
  {
    "q": "What is the output of the following C++ code?",
    "c": "#include <iostream>\nnamespace A { int x = 5; }\nnamespace B { int x = 10; }\nint main() {\n    std::cout << B::x;\n    return 0;\n}",
    "o": [
      "10",
      "5",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer allows multiple shared ownerships of the same object?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What will be the output of this code using shared_ptr?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> sp1 = std::make_shared<int>(25);\n    std::shared_ptr<int> sp2 = sp1;\n    std::cout << *sp2;\n    return 0;\n}",
    "o": [
      "25",
      "0",
      "1",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following statements best describes the effect of move assignment?",
    "o": [
      "Transfers ownership of resources from one object to another",
      "Makes a deep copy of all members",
      "Allocates new memory and copies values",
      "Prevents further access to the source object"
    ]
  },
  {
    "q": "What will be printed by the following code?",
    "c": "#include <iostream>\n#include <string>\n#include <utility>\nint main() {\n    std::string a = \"Hello\";\n    std::string b = std::move(a);\n    std::cout << b;\n    return 0;\n}",
    "o": [
      "Hello",
      "a",
      "Error",
      "Nothing"
    ]
  },
  {
    "q": "Which header must be included to use std::thread in C++?",
    "o": [
      "<thread>",
      "<pthread>",
      "<mutex>",
      "<future>"
    ]
  },
  {
    "q": "What will the following multithreading code do?",
    "c": "#include <iostream>\n#include <thread>\nvoid printMsg() { std::cout << \"Running\"; }\nint main() {\n    std::thread t(printMsg);\n    t.join();\n    return 0;\n}",
    "o": [
      "Running",
      "Error",
      "Nothing",
      "compile time error"
    ]
  },
  {
    "q": "What is the main benefit of using nested namespaces in C++?",
    "o": [
      "They help organize code logically and avoid name clashes",
      "They allow faster compilation",
      "They support multiple inheritance",
      "They simplify the use of global variables"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "#include <iostream>\nnamespace Alpha {\n    namespace Beta {\n        int value = 7;\n    }\n}\nint main() {\n    std::cout << Alpha::Beta::value;\n    return 0;\n}",
    "o": [
      "7",
      "0",
      "Compilation error",
      "Undefined"
    ]
  },
  {
    "q": "Which smart pointer is exclusive and cannot be copied?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> ptr = std::make_unique<int>(42);\n    std::cout << *ptr;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "undefined",
      "compile error"
    ]
  },
  {
    "q": "What kind of constructor is required to support move semantics?",
    "o": [
      "Move constructor",
      "Default constructor",
      "Copy constructor",
      "Virtual constructor"
    ]
  },
  {
    "q": "What does the following code demonstrate?",
    "c": "#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v1 = {1, 2, 3};\n    std::vector<int> v2 = std::move(v1);\n    std::cout << v2[0];\n    return 0;\n}",
    "o": [
      "1",
      "0",
      "3",
      "undefined"
    ]
  },
  {
    "q": "What does std::thread::detach() do?",
    "o": [
      "It allows the thread to execute independently from the main thread",
      "It blocks the calling thread until the thread completes",
      "It cancels the thread",
      "It joins multiple threads into one"
    ]
  },
  {
    "q": "What will this multithreaded code print?",
    "c": "#include <iostream>\n#include <thread>\nvoid task() { std::cout << \"Task executed\"; }\nint main() {\n    std::thread t(task);\n    t.join();\n    return 0;\n}",
    "o": [
      "Task executed",
      "Error",
      "Nothing",
      "compile error"
    ]
  },
  {
    "q": "How can you avoid naming conflicts between different parts of a large C++ project?",
    "o": [
      "By organizing code into namespaces",
      "By using only global variables",
      "By prefixing variable names with 'my'",
      "By avoiding function overloading"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "#include <iostream>\nnamespace X { int value = 20; }\nnamespace Y { int value = 30; }\nint main() {\n    using namespace X;\n    std::cout << value;\n    return 0;\n}",
    "o": [
      "20",
      "30",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer provides non-owning reference to an object managed by std::shared_ptr?",
    "o": [
      "std::weak_ptr",
      "std::unique_ptr",
      "std::auto_ptr",
      "std::ref_ptr"
    ]
  },
  {
    "q": "What will be printed by the following C++ code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    auto sp = std::make_shared<int>(99);\n    std::weak_ptr<int> wp = sp;\n    std::cout << sp.use_count();\n    return 0;\n}",
    "o": [
      "1",
      "0",
      "2",
      "99"
    ]
  },
  {
    "q": "Which of the following statements about move semantics is true?",
    "o": [
      "It avoids deep copying by transferring resources from one object to another",
      "It duplicates all resources using shallow copy",
      "It performs runtime type checking for polymorphism",
      "It guarantees thread safety for all objects"
    ]
  },
  {
    "q": "What does the following code do?",
    "c": "#include <iostream>\n#include <string>\n#include <utility>\nint main() {\n    std::string a = \"Alpha\";\n    std::string b = std::move(a);\n    std::cout << b;\n    return 0;\n}",
    "o": [
      "Alpha",
      "a",
      "Nothing",
      "Runtime error"
    ]
  },
  {
    "q": "Which of the following is true about std::thread::join()?",
    "o": [
      "It blocks until the associated thread completes execution",
      "It terminates the thread forcefully",
      "It runs the thread in detached mode",
      "It starts a new thread automatically"
    ]
  },
  {
    "q": "What is the expected output of the following code?",
    "c": "#include <iostream>\n#include <thread>\nvoid hello() { std::cout << \"Hi\"; }\nint main() {\n    std::thread t(hello);\n    t.join();\n    return 0;\n}",
    "o": [
      "Hi",
      "Error",
      "0",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is the correct way to access a variable inside a namespace?",
    "o": [
      "namespace_name::variable_name",
      "variable_name::namespace_name",
      "namespace_name->variable_name",
      "namespace::variable"
    ]
  },
  {
    "q": "What will be printed by the following code?",
    "c": "#include <iostream>\nnamespace A { int value = 50; }\nint value = 10;\nint main() {\n    std::cout << A::value;\n    return 0;\n}",
    "o": [
      "50",
      "10",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "What happens when a std::unique_ptr goes out of scope?",
    "o": [
      "It automatically deletes the owned object",
      "It transfers ownership to a global pointer",
      "It throws a runtime exception",
      "It does nothing and causes a memory leak"
    ]
  },
  {
    "q": "What is the output of this code using unique_ptr?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> up = std::make_unique<int>(75);\n    std::cout << *up;\n    return 0;\n}",
    "o": [
      "75",
      "0",
      "undefined",
      "compile-time error"
    ]
  },
  {
    "q": "Which of the following is required to implement move semantics in a class?",
    "o": [
      "A move constructor or move assignment operator",
      "A destructor",
      "A copy constructor only",
      "A virtual function"
    ]
  },
  {
    "q": "What does the following code illustrate?",
    "c": "#include <iostream>\n#include <string>\n#include <utility>\nint main() {\n    std::string s1 = \"Data\";\n    std::string s2 = std::move(s1);\n    std::cout << s2;\n    return 0;\n}",
    "o": [
      "Data",
      "s1",
      "Nothing",
      "Error"
    ]
  },
  {
    "q": "Which of the following is true about detached threads?",
    "o": [
      "They execute independently and cannot be joined later",
      "They are always daemon threads",
      "They return a future object",
      "They require mutex protection by default"
    ]
  },
  {
    "q": "What is the output of this multithreading code?",
    "c": "#include <iostream>\n#include <thread>\nvoid greet() { std::cout << \"Hello from thread!\"; }\nint main() {\n    std::thread t(greet);\n    t.join();\n    return 0;\n}",
    "o": [
      "Hello from thread!",
      "No output",
      "Error",
      "Thread killed"
    ]
  },
  {
    "q": "Which keyword is used to define a namespace in C++?",
    "o": [
      "namespace",
      "package",
      "module",
      "scope"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "#include <iostream>\nnamespace One { int x = 1; }\nnamespace Two { int x = 2; }\nint main() {\n    std::cout << Two::x;\n    return 0;\n}",
    "o": [
      "2",
      "1",
      "3",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer automatically deletes the object when no shared_ptr instances own it?",
    "o": [
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr",
      "std::raw_ptr"
    ]
  },
  {
    "q": "What will the following smart pointer code output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    auto ptr = std::make_shared<int>(10);\n    std::cout << *ptr;\n    return 0;\n}",
    "o": [
      "10",
      "0",
      "undefined",
      "runtime error"
    ]
  },
  {
    "q": "Which of the following best describes move semantics?",
    "o": [
      "Transfer of resources from one object to another without deep copying",
      "Creation of new object from an existing one",
      "Destruction of temporary object",
      "Execution of polymorphic behavior"
    ]
  },
  {
    "q": "What does this code demonstrate?",
    "c": "#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> a = {1,2,3};\n    std::vector<int> b = std::move(a);\n    std::cout << b.size();\n    return 0;\n}",
    "o": [
      "3",
      "0",
      "1",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following statements about std::thread is true?",
    "o": [
      "Each std::thread represents a single thread of execution",
      "std::thread always executes in parallel",
      "Threads share the same stack",
      "std::thread automatically joins at the end of main"
    ]
  },
  {
    "q": "What will the following multithreading code output?",
    "c": "#include <iostream>\n#include <thread>\nvoid run() { std::cout << \"Running\\n\"; }\nint main() {\n    std::thread t(run);\n    t.join();\n    return 0;\n}",
    "o": [
      "Running",
      "No output",
      "Error",
      "Main only"
    ]
  },
  {
    "q": "What is the main purpose of the scope resolution operator (::) in C++?",
    "o": [
      "To access global or namespace-level identifiers",
      "To access private members of a class",
      "To cast one type to another",
      "To dereference a pointer"
    ]
  },
  {
    "q": "What does this code output?",
    "c": "#include <iostream>\nnamespace App { int version = 3; }\nint version = 1;\nint main() {\n    std::cout << App::version;\n    return 0;\n}",
    "o": [
      "3",
      "1",
      "0",
      "Compilation Error"
    ]
  },
  {
    "q": "Which of the following smart pointers ensures a single owner for a dynamically allocated object?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What is the output of this smart pointer code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> up(new int(42));\n    std::cout << *up;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "null",
      "undefined"
    ]
  },
  {
    "q": "Which of the following is true about std::move?",
    "o": [
      "It casts an object to an rvalue reference",
      "It deletes the object after moving",
      "It ensures thread-safety during transfer",
      "It prevents an object from being copied"
    ]
  },
  {
    "q": "What does the following code illustrate?",
    "c": "#include <iostream>\n#include <string>\n#include <utility>\nint main() {\n    std::string x = \"Test\";\n    std::string y = std::move(x);\n    std::cout << y;\n    return 0;\n}",
    "o": [
      "Test",
      "x",
      "Compilation Error",
      "Undefined"
    ]
  },
  {
    "q": "Which header file is required to use std::thread?",
    "o": [
      "<thread>",
      "<pthread>",
      "<concurrency>",
      "<mutex>"
    ]
  },
  {
    "q": "What will this thread-related code print?",
    "c": "#include <iostream>\n#include <thread>\nvoid job() { std::cout << \"Thread Start\"; }\nint main() {\n    std::thread t(job);\n    t.join();\n    return 0;\n}",
    "o": [
      "Thread Start",
      "No output",
      "Main",
      "Error"
    ]
  },
  {
    "q": "Which of the following best describes how to resolve naming conflicts using namespaces in C++?",
    "o": [
      "Use fully qualified names with the scope resolution operator",
      "Avoid defining similar function names in different files",
      "Define everything in the global scope",
      "Use typedefs to rename functions"
    ]
  },
  {
    "q": "What is the output of this program?",
    "c": "#include <iostream>\nnamespace A { int value = 100; }\nnamespace B { int value = 200; }\nint main() {\n    using namespace A;\n    std::cout << B::value;\n    return 0;\n}",
    "o": [
      "200",
      "100",
      "Compilation Error",
      "0"
    ]
  },
  {
    "q": "Which smart pointer allows multiple owners of the same dynamically allocated object?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::scoped_ptr",
      "std::exclusive_ptr"
    ]
  },
  {
    "q": "What does the following smart pointer code output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> sp1 = std::make_shared<int>(25);\n    std::shared_ptr<int> sp2 = sp1;\n    std::cout << *sp2;\n    return 0;\n}",
    "o": [
      "25",
      "0",
      "Error",
      "Undefined"
    ]
  },
  {
    "q": "Which of the following statements about move constructors is true?",
    "o": [
      "They accept an rvalue reference and transfer resources",
      "They duplicate all resource handles",
      "They prevent object slicing",
      "They only work with primitive types"
    ]
  },
  {
    "q": "What does the following code demonstrate?",
    "c": "#include <iostream>\n#include <vector>\n#include <utility>\nint main() {\n    std::vector<int> a = {10, 20};\n    std::vector<int> b(std::move(a));\n    std::cout << b[0];\n    return 0;\n}",
    "o": [
      "10",
      "20",
      "0",
      "undefined"
    ]
  },
  {
    "q": "Which of the following is true about joining threads in C++?",
    "o": [
      "join() blocks the caller until the thread completes",
      "join() kills the thread immediately",
      "join() is optional and automatically called by the destructor",
      "join() is required only for detached threads"
    ]
  },
  {
    "q": "What will this C++ thread code print?",
    "c": "#include <iostream>\n#include <thread>\nvoid work() { std::cout << \"Thread Running\"; }\nint main() {\n    std::thread t1(work);\n    t1.join();\n    return 0;\n}",
    "o": [
      "Thread Running",
      "Error",
      "Main Thread",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following avoids name conflicts when using multiple libraries in C++?",
    "o": [
      "Namespaces",
      "Preprocessor directives",
      "Class encapsulation",
      "Static variables"
    ]
  },
  {
    "q": "What will this C++ code print?",
    "c": "#include <iostream>\nnamespace Math { int add(int a, int b) { return a + b; } }\nint main() {\n    std::cout << Math::add(3, 4);\n    return 0;\n}",
    "o": [
      "7",
      "3",
      "4",
      "0"
    ]
  },
  {
    "q": "Which smart pointer disallows copying but allows moving?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::auto_ptr",
      "std::weak_ptr"
    ]
  },
  {
    "q": "What does this code do?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> up1 = std::make_unique<int>(5);\n    std::unique_ptr<int> up2 = std::move(up1);\n    std::cout << *up2;\n    return 0;\n}",
    "o": [
      "5",
      "0",
      "null",
      "Segmentation fault"
    ]
  },
  {
    "q": "What is the purpose of move constructors in C++?",
    "o": [
      "To transfer ownership of resources without deep copying",
      "To duplicate class members efficiently",
      "To prevent changes in immutable objects",
      "To serialize object states"
    ]
  },
  {
    "q": "What does this code print?",
    "c": "#include <iostream>\n#include <string>\n#include <utility>\nint main() {\n    std::string a = \"Hello\";\n    std::string b = std::move(a);\n    std::cout << b;\n    return 0;\n}",
    "o": [
      "Hello",
      "a",
      "undefined",
      "Segfault"
    ]
  },
  {
    "q": "Which of the following statements is true about detached threads in C++?",
    "o": [
      "Detached threads run independently and cannot be joined",
      "Detached threads automatically join on destruction",
      "Detached threads block the main thread",
      "Detached threads execute sequentially"
    ]
  },
  {
    "q": "What is the output of this multithreading code?",
    "c": "#include <iostream>\n#include <thread>\nvoid task() { std::cout << \"Task Done\"; }\nint main() {\n    std::thread t(task);\n    t.detach();\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    return 0;\n}",
    "o": [
      "Task Done",
      "No output",
      "Error",
      "Compile-time error"
    ]
  },
  {
    "q": "Which of the following can be used to avoid dangling shared_ptr references?",
    "o": [
      "std::weak_ptr",
      "std::auto_ptr",
      "std::scoped_ptr",
      "std::unique_ptr"
    ]
  },
  {
    "q": "Which C++ standard introduced std::move and rvalue references?",
    "o": [
      "C++11",
      "C++98",
      "C++03",
      "C++17"
    ]
  },
  {
    "q": "Which of the following is used to access a variable defined inside a namespace?",
    "o": [
      "The scope resolution operator (::)",
      "The dot operator (.)",
      "The arrow operator (->)",
      "The comma operator (,)"
    ]
  },
  {
    "q": "What is the output of this code snippet?",
    "c": "#include <iostream>\nnamespace Alpha { int x = 1; }\nnamespace Beta { int x = 2; }\nint main() {\n    std::cout << Alpha::x;\n    return 0;\n}",
    "o": [
      "1",
      "2",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer in C++ provides reference counting?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::weak_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "What will the following program output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    auto ptr = std::make_shared<int>(100);\n    std::shared_ptr<int> ptr2 = ptr;\n    std::cout << *ptr2;\n    return 0;\n}",
    "o": [
      "100",
      "0",
      "null",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following best describes move semantics in C++?",
    "o": [
      "Transfer of resource ownership from one object to another",
      "Copying objects efficiently",
      "Deleting resources automatically",
      "Locking an object for exclusive access"
    ]
  },
  {
    "q": "What does the following code do?",
    "c": "#include <iostream>\n#include <string>\n#include <utility>\nint main() {\n    std::string a = \"World\";\n    std::string b = std::move(a);\n    std::cout << b;\n    return 0;\n}",
    "o": [
      "World",
      "a",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which header must be included to use std::thread in C++?",
    "o": [
      "<thread>",
      "<pthread.h>",
      "<process>",
      "<chrono>"
    ]
  },
  {
    "q": "What will this C++ multithreading code output?",
    "c": "#include <iostream>\n#include <thread>\nvoid run() { std::cout << \"Running\"; }\nint main() {\n    std::thread t(run);\n    t.join();\n    return 0;\n}",
    "o": [
      "Running",
      "Compile-time error",
      "Nothing",
      "Main"
    ]
  },
  {
    "q": "Which smart pointer is best used to break circular references?",
    "o": [
      "std::weak_ptr",
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What happens if std::move is used incorrectly?",
    "o": [
      "It may lead to undefined behavior or use of a moved-from object",
      "It throws a runtime exception",
      "It converts to nullptr",
      "It always results in a deep copy"
    ]
  },
  {
    "q": "Why are namespaces used in C++?",
    "o": [
      "To prevent naming conflicts in large projects",
      "To speed up compilation",
      "To reduce memory usage",
      "To improve pointer arithmetic"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nnamespace Outer {\n    int value = 42;\n    namespace Inner {\n        int value = 84;\n    }\n}\nint main() {\n    std::cout << Outer::Inner::value;\n    return 0;\n}",
    "o": [
      "84",
      "42",
      "0",
      "Error"
    ]
  },
  {
    "q": "Which of the following smart pointers does not allow shared ownership?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What is the output of the following smart pointer example?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> up = std::make_unique<int>(10);\n    std::cout << *up;\n    return 0;\n}",
    "o": [
      "10",
      "0",
      "Error",
      "Segmentation fault"
    ]
  },
  {
    "q": "Which C++ feature transfers ownership of resources without copying?",
    "o": [
      "Move semantics",
      "RAII",
      "Copy constructor",
      "Virtual inheritance"
    ]
  },
  {
    "q": "What does the following code demonstrate?",
    "c": "#include <iostream>\n#include <vector>\n#include <utility>\nint main() {\n    std::vector<int> a = {1, 2, 3};\n    std::vector<int> b = std::move(a);\n    std::cout << b.size();\n    return 0;\n}",
    "o": [
      "3",
      "0",
      "Segfault",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following functions must be called on a joinable thread before program exits?",
    "o": [
      "join() or detach()",
      "cancel()",
      "flush()",
      "sleep()"
    ]
  },
  {
    "q": "What does this C++ thread code do?",
    "c": "#include <iostream>\n#include <thread>\nvoid task() { std::cout << \"Hello from thread\"; }\nint main() {\n    std::thread t(task);\n    t.join();\n    return 0;\n}",
    "o": [
      "Prints 'Hello from thread'",
      "Throws exception",
      "Fails to compile",
      "Hangs the program"
    ]
  },
  {
    "q": "Which smart pointer is used only for observing an object managed by std::shared_ptr?",
    "o": [
      "std::weak_ptr",
      "std::unique_ptr",
      "std::scoped_ptr",
      "std::observer_ptr"
    ]
  },
  {
    "q": "Which operator is commonly overloaded for enabling move semantics in user-defined types?",
    "o": [
      "operator=",
      "operator&",
      "operator*",
      "operator>>"
    ]
  },
  {
    "q": "What does the scope resolution operator (::) do in C++?",
    "o": [
      "It accesses members of a namespace or class",
      "It performs type conversion",
      "It calls a constructor",
      "It defines a new class"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nnamespace NS {\n    int x = 100;\n}\nint main() {\n    std::cout << NS::x;\n    return 0;\n}",
    "o": [
      "100",
      "0",
      "Compilation error",
      "Runtime error"
    ]
  },
  {
    "q": "Which smart pointer ensures only one owner of a dynamically allocated object?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What is the output of the following smart pointer usage?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> p1 = std::make_shared<int>(20);\n    std::shared_ptr<int> p2 = p1;\n    std::cout << *p2;\n    return 0;\n}",
    "o": [
      "20",
      "0",
      "null",
      "Runtime error"
    ]
  },
  {
    "q": "Which C++11 feature enables moving resources instead of copying them?",
    "o": [
      "std::move",
      "std::copy",
      "std::transfer",
      "std::allocate"
    ]
  },
  {
    "q": "What is the output of this move semantics code?",
    "c": "#include <iostream>\n#include <string>\n#include <utility>\nint main() {\n    std::string a = \"hello\";\n    std::string b = std::move(a);\n    std::cout << b;\n    return 0;\n}",
    "o": [
      "hello",
      "a",
      "null",
      "Compilation error"
    ]
  },
  {
    "q": "Which header is required to use std::thread in C++?",
    "o": [
      "<thread>",
      "<mutex>",
      "<atomic>",
      "<future>"
    ]
  },
  {
    "q": "What does this multithreading example print?",
    "c": "#include <iostream>\n#include <thread>\nvoid foo() { std::cout << \"Threading\"; }\nint main() {\n    std::thread t(foo);\n    t.join();\n    return 0;\n}",
    "o": [
      "Threading",
      "Compilation error",
      "Segfault",
      "Nothing"
    ]
  },
  {
    "q": "What does std::weak_ptr prevent that shared_ptr cannot?",
    "o": [
      "Circular references",
      "Memory leaks",
      "Null dereferencing",
      "Double deletion"
    ]
  },
  {
    "q": "What must a class define to support move semantics?",
    "o": [
      "A move constructor or move assignment operator",
      "A default constructor",
      "A copy constructor",
      "A virtual destructor"
    ]
  },
  {
    "q": "Which of the following statements correctly uses a variable from a namespace?",
    "o": [
      "int x = mynamespace::value;",
      "int x = value::mynamespace;",
      "int x = value.mynamespace;",
      "int x = mynamespace->value;"
    ]
  },
  {
    "q": "What will be the output of this code using a smart pointer?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> p = std::make_shared<int>(30);\n    std::cout << *p;\n    return 0;\n}",
    "o": [
      "30",
      "0",
      "null",
      "Compilation error"
    ]
  },
  {
    "q": "Which smart pointer can be used to safely access an object managed by shared_ptr, without increasing the reference count?",
    "o": [
      "std::weak_ptr",
      "std::unique_ptr",
      "std::scoped_ptr",
      "std::observing_ptr"
    ]
  },
  {
    "q": "What is the key benefit of move semantics in C++?",
    "o": [
      "Efficient resource transfer without deep copy",
      "Automatic memory cleanup",
      "Enforced compile-time type safety",
      "Improved readability"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\n#include <string>\nint main() {\n    std::string a = \"data\";\n    std::string b = std::move(a);\n    std::cout << b;\n    return 0;\n}",
    "o": [
      "data",
      "a",
      "Compilation error",
      "null"
    ]
  },
  {
    "q": "Which method must be used on a std::thread object before it is destroyed?",
    "o": [
      "join() or detach()",
      "start()",
      "end()",
      "run()"
    ]
  },
  {
    "q": "What does the following threading code print?",
    "c": "#include <iostream>\n#include <thread>\nvoid work() { std::cout << \"Work Done\"; }\nint main() {\n    std::thread t(work);\n    t.join();\n    return 0;\n}",
    "o": [
      "Work Done",
      "Error",
      "Nothing",
      "Segmentation fault"
    ]
  },
  {
    "q": "Which operator is associated with transferring resources in move semantics?",
    "o": [
      "std::move()",
      "std::copy()",
      "std::assign()",
      "std::bind()"
    ]
  },
  {
    "q": "How is a namespace defined in C++?",
    "o": [
      "namespace myspace { int x; }",
      "new namespace myspace() { }",
      "class namespace myspace { };",
      "namespace = myspace {};"
    ]
  },
  {
    "q": "What happens if you try to join an already joined thread in C++?",
    "o": [
      "The program throws a system_error exception",
      "It joins again without issue",
      "It silently fails",
      "It converts the thread to detached mode"
    ]
  },
  {
    "q": "What is the primary use of the scope resolution operator (::) in C++?",
    "o": [
      "To access global or namespace-level identifiers",
      "To access private class members",
      "To resolve function overloading",
      "To overload operators"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "namespace A {\n    int x = 5;\n}\nint main() {\n    int x = 10;\n    std::cout << A::x;\n    return 0;\n}",
    "o": [
      "5",
      "10",
      "Compilation Error",
      "0"
    ]
  },
  {
    "q": "Which smart pointer automatically deletes the managed object when the last owner is destroyed?",
    "o": [
      "std::shared_ptr",
      "std::unique_ptr",
      "std::raw_ptr",
      "std::weak_ptr"
    ]
  },
  {
    "q": "What is the output of the code using std::unique_ptr?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> ptr = std::make_unique<int>(42);\n    std::cout << *ptr;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "Compilation Error",
      "null"
    ]
  },
  {
    "q": "What does std::move do in C++?",
    "o": [
      "It casts an object to an rvalue reference",
      "It performs a deep copy of the object",
      "It allocates memory dynamically",
      "It creates a new thread"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <string>\nint main() {\n    std::string s1 = \"abc\";\n    std::string s2 = std::move(s1);\n    std::cout << s2;\n    return 0;\n}",
    "o": [
      "abc",
      "s1",
      "null",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following headers is necessary for multithreading in C++?",
    "o": [
      "<thread>",
      "<threading>",
      "<pthread>",
      "<multi>"
    ]
  },
  {
    "q": "What will this multithreading example output?",
    "c": "#include <iostream>\n#include <thread>\nvoid task() { std::cout << \"Running\\n\"; }\nint main() {\n    std::thread t(task);\n    t.join();\n    return 0;\n}",
    "o": [
      "Running",
      "Nothing",
      "Compilation Error",
      "Threading"
    ]
  },
  {
    "q": "Which smart pointer is best suited to break circular references?",
    "o": [
      "std::weak_ptr",
      "std::shared_ptr",
      "std::unique_ptr",
      "std::scoped_ptr"
    ]
  },
  {
    "q": "Which C++11 feature allows transferring ownership of resources without copying?",
    "o": [
      "Move semantics",
      "Copy constructors",
      "RAII",
      "Template specialization"
    ]
  },
  {
    "q": "Which of the following correctly defines a nested namespace?",
    "o": [
      "namespace outer::inner { int x; }",
      "namespace outer.inner { int x; }",
      "namespace outer:inner { int x; }",
      "namespace (outer::inner) { int x; }"
    ]
  },
  {
    "q": "What is the output of the following program?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> ptr(new int(100));\n    std::cout << *ptr;\n    return 0;\n}",
    "o": [
      "100",
      "0",
      "Compilation Error",
      "Runtime Error"
    ]
  },
  {
    "q": "What happens when a std::unique_ptr is moved?",
    "o": [
      "Ownership is transferred and the original pointer becomes null",
      "A copy of the resource is created",
      "Both pointers own the same resource",
      "It causes a compilation error"
    ]
  },
  {
    "q": "Which smart pointer does not support copy semantics?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What will be the output of this multithreading program?",
    "c": "#include <iostream>\n#include <thread>\nvoid fun() { std::cout << \"Hello from thread\\n\"; }\nint main() {\n    std::thread t(fun);\n    t.join();\n    return 0;\n}",
    "o": [
      "Hello from thread",
      "Nothing",
      "Error",
      "thread"
    ]
  },
  {
    "q": "Why should std::thread objects be joined or detached before destruction?",
    "o": [
      "To avoid std::terminate being called at runtime",
      "To create multiple threads",
      "To increase priority of thread execution",
      "To change thread’s return type"
    ]
  },
  {
    "q": "Which of the following can be used to prevent copying of a class?",
    "o": [
      "Delete the copy constructor and assignment operator",
      "Declare the class as final",
      "Use private inheritance",
      "Make all members static"
    ]
  },
  {
    "q": "What is the purpose of std::move in C++?",
    "o": [
      "To convert an lvalue to an rvalue reference",
      "To copy an object efficiently",
      "To move a thread to another core",
      "To delete a pointer safely"
    ]
  },
  {
    "q": "What is the output of this code using move semantics?",
    "c": "#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> a = {1, 2, 3};\n    std::vector<int> b = std::move(a);\n    std::cout << b.size();\n    return 0;\n}",
    "o": [
      "3",
      "0",
      "Compilation Error",
      "Segmentation fault"
    ]
  },
  {
    "q": "Which of the following is NOT a valid use of a namespace?",
    "o": [
      "To override built-in operators globally",
      "To group logically related identifiers",
      "To prevent name conflicts",
      "To extend a library without modifying original code"
    ]
  },
  {
    "q": "Which statement about smart pointers in C++ is TRUE?",
    "o": [
      "std::shared_ptr allows multiple pointers to share ownership of the same object",
      "std::unique_ptr allows shared ownership of the same object",
      "std::weak_ptr automatically deletes the object it points to",
      "std::auto_ptr is preferred over std::unique_ptr in modern C++"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\nnamespace Alpha {\n    int x = 7;\n}\nint main() {\n    int x = 3;\n    std::cout << Alpha::x;\n    return 0;\n}",
    "o": [
      "7",
      "3",
      "0",
      "Compilation Error"
    ]
  },
  {
    "q": "Which of the following best describes move semantics in C++?",
    "o": [
      "It allows resources to be transferred from one object to another without copying",
      "It allows object methods to move the program counter",
      "It improves recursion performance",
      "It is used to implement virtual inheritance"
    ]
  },
  {
    "q": "What is the effect of calling join() on a std::thread?",
    "o": [
      "It waits for the thread to finish execution",
      "It detaches the thread and continues execution",
      "It starts the thread",
      "It suspends the thread temporarily"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <thread>\nvoid hello() { std::cout << \"Thread here\\n\"; }\nint main() {\n    std::thread t(hello);\n    t.join();\n    return 0;\n}",
    "o": [
      "Thread here",
      "Compilation error",
      "Main here",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following correctly transfers ownership using std::unique_ptr?",
    "o": [
      "std::unique_ptr<int> p2 = std::move(p1);",
      "std::unique_ptr<int> p2 = p1;",
      "p2 = p1;",
      "p2.reset(p1.get());"
    ]
  },
  {
    "q": "What is the purpose of std::weak_ptr?",
    "o": [
      "To observe a shared_ptr without affecting its reference count",
      "To provide exclusive ownership of an object",
      "To replace raw pointers with ownership",
      "To auto-delete resources immediately"
    ]
  },
  {
    "q": "What is the output of this program involving move semantics?",
    "c": "#include <iostream>\n#include <string>\nint main() {\n    std::string a = \"C++\";\n    std::string b = std::move(a);\n    std::cout << b;\n    return 0;\n}",
    "o": [
      "C++",
      "a",
      "Compilation Error",
      "Move"
    ]
  },
  {
    "q": "Which keyword is used to define a namespace in C++?",
    "o": [
      "namespace",
      "module",
      "package",
      "scope"
    ]
  },
  {
    "q": "Which of the following is a reason to use std::unique_ptr?",
    "o": [
      "To ensure single ownership and automatic resource release",
      "To create a copy of the resource automatically",
      "To share resources among multiple owners",
      "To prevent dangling pointers"
    ]
  },
  {
    "q": "What is the correct way to use the scope resolution operator to access a global variable inside a function?",
    "o": [
      "::variable_name",
      "global::variable_name",
      "scope::variable_name",
      "variable_name::global"
    ]
  },
  {
    "q": "What is the output of this code involving shared_ptr?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> a = std::make_shared<int>(50);\n    std::shared_ptr<int> b = a;\n    std::cout << *b;\n    return 0;\n}",
    "o": [
      "50",
      "0",
      "Compilation Error",
      "Undefined Behavior"
    ]
  },
  {
    "q": "Which C++11 feature allows threads to be created easily?",
    "o": [
      "std::thread",
      "pthread_create",
      "ThreadClass",
      "launch_thread"
    ]
  },
  {
    "q": "What is true about std::unique_ptr?",
    "o": [
      "It deletes the owned object automatically when it goes out of scope",
      "It can be copied freely between objects",
      "It allows multiple owners of a resource",
      "It is not part of the STL"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\nnamespace Math {\n    int value = 42;\n}\nint main() {\n    int value = 10;\n    std::cout << Math::value;\n    return 0;\n}",
    "o": [
      "42",
      "10",
      "0",
      "Compilation Error"
    ]
  },
  {
    "q": "Which of the following is NOT a feature of move semantics?",
    "o": [
      "It copies all object members by default",
      "It transfers resources instead of copying them",
      "It avoids expensive deep copies",
      "It uses rvalue references"
    ]
  },
  {
    "q": "How do you prevent a std::thread object from throwing on destruction?",
    "o": [
      "Call join() or detach() before destruction",
      "Use terminate() manually",
      "Convert it to a future",
      "Declare it static"
    ]
  },
  {
    "q": "What is the correct syntax for creating a unique_ptr to an integer?",
    "o": [
      "std::unique_ptr<int> ptr = std::make_unique<int>(5);",
      "std::unique_ptr ptr = new int(5);",
      "std::make_shared<int>(5);",
      "int* ptr = unique_ptr(5);"
    ]
  },
  {
    "q": "Which of the following can lead to a deadlock in multithreaded C++ code?",
    "o": [
      "Two threads waiting on each other's locked resources",
      "Calling join twice on the same thread",
      "Using unique_ptr in a thread",
      "Not using std::mutex"
    ]
  },
  {
    "q": "What is the primary reason for using namespaces in C++?",
    "o": [
      "To avoid name collisions in large codebases",
      "To make compilation faster",
      "To define new data types",
      "To manage memory allocation"
    ]
  },
  {
    "q": "Which smart pointer type should be used when only one owner of a resource is required?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "auto_ptr"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> p1(new int(100));\n    std::cout << *p1;\n    return 0;\n}",
    "o": [
      "100",
      "0",
      "Compilation Error",
      "Segmentation Fault"
    ]
  },
  {
    "q": "Which of the following uses move semantics correctly?",
    "o": [
      "std::vector<int> v2 = std::move(v1);",
      "std::vector<int> v2 = v1;",
      "v2 = v1;",
      "move(v1, v2);"
    ]
  },
  {
    "q": "What does std::move do in C++?",
    "o": [
      "Converts an lvalue into an rvalue",
      "Copies an object deeply",
      "Transfers a pointer to the heap",
      "Allocates memory on the stack"
    ]
  },
  {
    "q": "What is the correct way to access a variable declared inside a namespace?",
    "o": [
      "namespace_name::variable_name",
      "variable_name.namespace_name",
      "scope.namespace_name.variable_name",
      "use namespace_name.variable"
    ]
  },
  {
    "q": "What is the output of this code snippet?",
    "c": "#include <iostream>\nnamespace A {\n    int value = 20;\n}\nnamespace B {\n    int value = 40;\n}\nint main() {\n    std::cout << A::value;\n    return 0;\n}",
    "o": [
      "20",
      "40",
      "Compilation Error",
      "Undefined"
    ]
  },
  {
    "q": "Which of the following is true about std::thread?",
    "o": [
      "It represents a single thread of execution in C++",
      "It creates multiple threads by default",
      "It replaces mutex and condition variables",
      "It is not available in C++11"
    ]
  },
  {
    "q": "Which of the following does NOT increase the reference count in shared_ptr?",
    "o": [
      "std::weak_ptr",
      "std::shared_ptr",
      "Assignment of shared_ptr",
      "Copy constructor of shared_ptr"
    ]
  },
  {
    "q": "What is the output of this multithreading code?",
    "c": "#include <iostream>\n#include <thread>\nvoid run() { std::cout << \"Run\\n\"; }\nint main() {\n    std::thread t(run);\n    t.join();\n    return 0;\n}",
    "o": [
      "Run",
      "Error",
      "Join",
      "Nothing"
    ]
  },
  {
    "q": "Why is move semantics preferred in some cases over copying?",
    "o": [
      "Because it avoids unnecessary deep copies and improves performance",
      "Because it enforces const correctness",
      "Because it increases memory usage",
      "Because it disables polymorphism"
    ]
  },
  {
    "q": "Which of the following will correctly move ownership from one unique_ptr to another?",
    "o": [
      "std::unique_ptr<int> b = std::move(a);",
      "std::unique_ptr<int> b = a;",
      "b = copy(a);",
      "std::move(b, a);"
    ]
  },
  {
    "q": "What is the primary difference between shared_ptr and unique_ptr?",
    "o": [
      "shared_ptr allows multiple owners; unique_ptr allows only one",
      "shared_ptr is faster than unique_ptr",
      "unique_ptr uses reference counting",
      "shared_ptr deletes the object immediately"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\nnamespace outer {\n    int x = 10;\n    namespace inner {\n        int x = 20;\n    }\n}\nint main() {\n    std::cout << outer::inner::x;\n    return 0;\n}",
    "o": [
      "20",
      "10",
      "Compilation Error",
      "0"
    ]
  },
  {
    "q": "Which keyword is used to launch a thread in C++11?",
    "o": [
      "std::thread",
      "launch_thread",
      "thread_launch",
      "begin_thread"
    ]
  },
  {
    "q": "Why should std::mutex be used in multithreaded programs?",
    "o": [
      "To prevent data races by protecting critical sections",
      "To create threads safely",
      "To allocate dynamic memory",
      "To store shared_ptr safely"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> p1 = std::make_shared<int>(99);\n    std::cout << *p1;\n    return 0;\n}",
    "o": [
      "99",
      "0",
      "Compilation Error",
      "Segmentation Fault"
    ]
  },
  {
    "q": "Which of the following is NOT a benefit of move semantics?",
    "o": [
      "Increased memory consumption",
      "Avoiding unnecessary deep copies",
      "Improved performance",
      "Resource transfer without duplication"
    ]
  },
  {
    "q": "Which of the following is true about std::weak_ptr?",
    "o": [
      "It does not increase the reference count of the object",
      "It manages the lifetime of the object",
      "It is used to create deep copies",
      "It is faster than unique_ptr"
    ]
  },
  {
    "q": "What is the effect of calling detach() on a std::thread object?",
    "o": [
      "The thread continues execution independently",
      "The thread terminates immediately",
      "The main thread waits for it to complete",
      "It deletes the thread object"
    ]
  },
  {
    "q": "How can you avoid long namespace names in your code?",
    "o": [
      "By using the 'using' directive",
      "By importing the header directly",
      "By calling the namespace constructor",
      "By creating a copy of the namespace"
    ]
  },
  {
    "q": "Which of the following correctly creates a shared_ptr to an integer with value 50?",
    "o": [
      "std::shared_ptr<int> ptr = std::make_shared<int>(50);",
      "std::shared_ptr<int> ptr(50);",
      "shared_ptr<int> ptr = new int(50);",
      "std::shared_ptr ptr = make_shared<int>(50);"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> p1 = std::make_unique<int>(42);\n    std::unique_ptr<int> p2 = std::move(p1);\n    std::cout << *p2;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "Undefined behavior",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following best describes move semantics?",
    "o": [
      "Transfers resources from one object to another without copying",
      "Creates a backup of an object before modifying it",
      "Allocates memory dynamically",
      "Prevents function overloading"
    ]
  },
  {
    "q": "What will happen if std::thread::join() is not called before the thread object is destroyed?",
    "o": [
      "std::terminate is called and the program crashes",
      "The thread continues running normally",
      "The thread is silently killed",
      "A warning is printed but program continues"
    ]
  },
  {
    "q": "Which of the following keywords is used to define a namespace in C++?",
    "o": [
      "namespace",
      "package",
      "module",
      "space"
    ]
  },
  {
    "q": "What is the output of this code snippet?",
    "c": "#include <iostream>\nnamespace A {\n    int val = 5;\n    namespace B {\n        int val = 10;\n    }\n}\nint main() {\n    std::cout << A::B::val;\n    return 0;\n}",
    "o": [
      "10",
      "5",
      "Compilation Error",
      "0"
    ]
  },
  {
    "q": "Which smart pointer would you use to prevent a circular reference?",
    "o": [
      "std::weak_ptr",
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What is the purpose of std::mutex in multithreading?",
    "o": [
      "To ensure mutual exclusion when accessing shared resources",
      "To create threads safely",
      "To terminate threads",
      "To improve performance of memory allocation"
    ]
  },
  {
    "q": "Which of the following correctly starts a thread executing a function named `worker`?",
    "o": [
      "std::thread t(worker);",
      "thread.start(worker);",
      "run_thread(worker);",
      "std::start_thread(worker);"
    ]
  },
  {
    "q": "Why is std::move used with unique_ptr?",
    "o": [
      "To transfer ownership from one unique_ptr to another",
      "To copy the pointer to another unique_ptr",
      "To destroy the object manually",
      "To increment the reference count"
    ]
  },
  {
    "q": "Which of the following correctly accesses a variable 'x' inside a nested namespace?",
    "o": [
      "outer::inner::x",
      "outer.inner.x",
      "outer->inner->x",
      "outer/inner/x"
    ]
  },
  {
    "q": "What is the output of this code snippet?",
    "c": "#include <iostream>\nnamespace first {\n    int x = 100;\n}\nnamespace second {\n    int x = 200;\n}\nint main() {\n    using namespace first;\n    std::cout << x;\n    return 0;\n}",
    "o": [
      "100",
      "200",
      "Compilation error",
      "0"
    ]
  },
  {
    "q": "Which smart pointer type allows only a single owner of a dynamically allocated resource?",
    "o": [
      "std::unique_ptr",
      "std::shared_ptr",
      "std::weak_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "Which function should be used to create a shared_ptr safely?",
    "o": [
      "std::make_shared",
      "new_shared_ptr",
      "create_shared_ptr",
      "shared_ptr::get()"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "#include <iostream>\n#include <utility>\nstd::string generate() {\n    std::string s = \"Hello\";\n    return std::move(s);\n}\nint main() {\n    std::string str = generate();\n    std::cout << str;\n    return 0;\n}",
    "o": [
      "Hello",
      "",
      "Undefined",
      "Compilation Error"
    ]
  },
  {
    "q": "Which of the following best describes the purpose of std::move?",
    "o": [
      "It enables move semantics by converting an lvalue to an rvalue",
      "It deletes an object from memory",
      "It copies an object deeply",
      "It converts an rvalue to lvalue"
    ]
  },
  {
    "q": "Which thread function waits for the thread to finish execution before continuing?",
    "o": [
      "join()",
      "wait()",
      "sync()",
      "complete()"
    ]
  },
  {
    "q": "What does the following program do?",
    "c": "#include <thread>\n#include <iostream>\nvoid run() { std::cout << \"Thread!\"; }\nint main() {\n    std::thread t(run);\n    t.join();\n    return 0;\n}",
    "o": [
      "Prints 'Thread!'",
      "Causes segmentation fault",
      "Compilation error",
      "Prints nothing"
    ]
  },
  {
    "q": "Which of the following is NOT a feature of std::shared_ptr?",
    "o": [
      "Transfers ownership automatically on copy",
      "Allows multiple shared owners",
      "Reference counted",
      "Exclusive ownership"
    ]
  },
  {
    "q": "What is the main benefit of using smart pointers over raw pointers?",
    "o": [
      "Automatic memory management",
      "Faster execution",
      "Larger memory allocation",
      "Better syntax"
    ]
  },
  {
    "q": "Which header file is required to use std::thread in C++?",
    "o": [
      "#include <thread>",
      "#include <pthread>",
      "#include <concurrency>",
      "#include <threads>"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> p1 = std::make_shared<int>(100);\n    std::shared_ptr<int> p2 = p1;\n    std::cout << *p2;\n    return 0;\n}",
    "o": [
      "100",
      "0",
      "Undefined behavior",
      "Compilation error"
    ]
  },
  {
    "q": "Why is std::weak_ptr used in C++?",
    "o": [
      "To break circular references between shared_ptr instances",
      "To make a temporary object",
      "To move ownership of an object",
      "To create multiple owners of a resource"
    ]
  },
  {
    "q": "What will be the output of the code?",
    "c": "#include <iostream>\n#include <thread>\nvoid task() {\n    std::cout << \"Running in thread\\n\";\n}\nint main() {\n    std::thread t(task);\n    t.join();\n    return 0;\n}",
    "o": [
      "Running in thread",
      "Compilation error",
      "No output",
      "Runtime crash"
    ]
  },
  {
    "q": "Which of the following best describes the scope resolution operator (::) in C++?",
    "o": [
      "It accesses a global variable or member in a namespace or class",
      "It compares two values",
      "It dereferences a pointer",
      "It initializes a static variable"
    ]
  },
  {
    "q": "Which of the following code snippets properly creates a unique_ptr to a double?",
    "o": [
      "std::unique_ptr<double> ptr = std::make_unique<double>(5.5);",
      "unique_ptr<double> ptr = new double(5.5);",
      "std::make_shared<double> ptr(5.5);",
      "double* ptr = std::unique_ptr(5.5);"
    ]
  },
  {
    "q": "In which situation is move semantics most beneficial?",
    "o": [
      "Returning a large object from a function",
      "Passing a primitive int to a function",
      "Copying small structs",
      "Reading from a constant object"
    ]
  },
  {
    "q": "What is a consequence of failing to join or detach a thread before its destructor is called?",
    "o": [
      "The program will terminate",
      "The thread will be silently deleted",
      "The thread will block the main thread",
      "The compiler will raise an error"
    ]
  },
  {
    "q": "Which of the following allows code grouping and name disambiguation in C++?",
    "o": [
      "Namespaces",
      "Macros",
      "Templates",
      "Classes"
    ]
  },
  {
    "q": "What does std::move actually do?",
    "o": [
      "Casts an object to an rvalue reference",
      "Moves an object from one location to another in memory",
      "Deletes the object from memory",
      "Copies the object using move constructor"
    ]
  },
  {
    "q": "Which smart pointer does not increase the reference count of the managed object?",
    "o": [
      "std::weak_ptr",
      "std::shared_ptr",
      "std::unique_ptr",
      "std::auto_ptr"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "#include <iostream>\nnamespace Alpha {\n    int val = 42;\n}\nint main() {\n    std::cout << Alpha::val;\n    return 0;\n}",
    "o": [
      "42",
      "0",
      "Compilation Error",
      "Undefined"
    ]
  },
  {
    "q": "Which C++11 feature allows transferring ownership of a resource instead of copying it?",
    "o": [
      "Move semantics",
      "Smart pointers",
      "Virtual functions",
      "Templates"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::unique_ptr<int> p1 = std::make_unique<int>(10);\n    std::unique_ptr<int> p2 = std::move(p1);\n    std::cout << *p2;\n    return 0;\n}",
    "o": [
      "10",
      "0",
      "Compilation Error",
      "Segmentation fault"
    ]
  },
  {
    "q": "Which of the following must be done with a std::thread object before it is destroyed?",
    "o": [
      "Either joined or detached",
      "Only joined",
      "Only detached",
      "Nothing is required"
    ]
  },
  {
    "q": "Which of the following is true about namespace aliases?",
    "o": [
      "They provide a shorter name for long namespace names",
      "They hide namespace members",
      "They delete a namespace",
      "They override class names"
    ]
  },
  {
    "q": "What will be the result of this program?",
    "c": "#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> p1 = std::make_shared<int>(5);\n    std::shared_ptr<int> p2 = p1;\n    std::cout << p1.use_count();\n    return 0;\n}",
    "o": [
      "2",
      "1",
      "0",
      "Compilation Error"
    ]
  },
  {
    "q": "Which C++ keyword or function helps implement move semantics explicitly?",
    "o": [
      "std::move",
      "std::swap",
      "std::copy",
      "std::forward"
    ]
  },
  {
    "q": "Which of the following is a benefit of using namespaces?",
    "o": [
      "Avoiding name collisions in large projects",
      "Speeding up compilation",
      "Reducing executable size",
      "Increasing memory allocation"
    ]
  },
  {
    "q": "Which of the following correctly creates a thread in C++?",
    "o": [
      "std::thread t([]{ std::cout << \"Hello\"; });",
      "thread t(function);",
      "std::thread::create(function);",
      "new thread(function);"
    ]
}
]