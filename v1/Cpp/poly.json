[
  {
    "q": "Which of the following is an example of compile-time polymorphism in C++?",
    "o": [
      "Function overloading",
      "Virtual functions",
      "Dynamic dispatch",
      "Abstract classes"
    ]
  },
  {
    "q": "What will be the output of the following C++ code snippet?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Print {\npublic:\n    void show(int i) {\n        cout << \"Integer: \" << i << endl;\n    }\n    void show(double d) {\n        cout << \"Double: \" << d << endl;\n    }\n};\n\nint main() {\n    Print obj;\n    obj.show(3.14);\n    return 0;\n}",
    "o": [
      "Double: 3.14",
      "Integer: 3.14",
      "Double: 3",
      "Compilation error"
    ]
  },
  {
    "q": "Which concept allows the same function name to be used for different types in C++?",
    "o": [
      "Function overloading",
      "Virtual functions",
      "Encapsulation",
      "Inheritance"
    ]
  },
  {
    "q": "What is the output of the following code involving virtual functions?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    virtual void show() {\n        cout << \"Base class\" << endl;\n    }\n};\n\nclass Derived : public Base {\npublic:\n    void show() override {\n        cout << \"Derived class\" << endl;\n    }\n};\n\nint main() {\n    Base* bptr = new Derived();\n    bptr->show();\n    delete bptr;\n    return 0;\n}",
    "o": [
      "Derived class",
      "Base class",
      "Compilation error",
      "Runtime error"
    ]
  },
  {
    "q": "Which of the following best describes vtable in C++?",
    "o": [
      "A table of function pointers used to implement runtime polymorphism",
      "A data structure used to allocate memory dynamically",
      "A type of inheritance",
      "A function returning a class object"
    ]
  },
  {
    "q": "What will be the result of trying to instantiate an abstract class in C++?",
    "o": [
      "Compilation error",
      "Runtime error",
      "Successful execution",
      "Undefined behavior"
    ]
  },
  {
    "q": "What is the purpose of the 'virtual' keyword in C++?",
    "o": [
      "To enable runtime polymorphism",
      "To allocate memory dynamically",
      "To declare constant variables",
      "To overload a function"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n    virtual void display() {\n        cout << \"Class A\" << endl;\n    }\n};\n\nclass B : public A {\npublic:\n    void display() {\n        cout << \"Class B\" << endl;\n    }\n};\n\nvoid show(A* obj) {\n    obj->display();\n}\n\nint main() {\n    B b;\n    show(&b);\n    return 0;\n}",
    "o": [
      "Class B",
      "Class A",
      "Compilation error",
      "Runtime error"
    ]
  },
  {
    "q": "Which of the following correctly defines a pure virtual function?",
    "o": [
      "virtual void func() = 0;",
      "virtual void func() {}",
      "void virtual func();",
      "pure virtual void func();"
    ]
  },
  {
    "q": "What is stored in the vptr of a class instance in C++?",
    "o": [
      "A pointer to the virtual table (vtable)",
      "A pointer to the base class",
      "The address of the class object",
      "The size of the object"
    ]
  },
  {
    "q": "Which of the following is required for operator overloading in C++?",
    "o": [
      "A function with the keyword 'operator' followed by the operator symbol",
      "A virtual function",
      "A constructor with operator name",
      "Function templates"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n    virtual void fun() {\n        cout << \"A::fun()\" << endl;\n    }\n};\n\nclass B: public A {\npublic:\n    void fun() {\n        cout << \"B::fun()\" << endl;\n    }\n};\n\nint main() {\n    A* ptr = new B();\n    ptr->fun();\n    delete ptr;\n    return 0;\n}",
    "o": [
      "B::fun()",
      "A::fun()",
      "Compilation error",
      "Segmentation fault"
    ]
  },
  {
    "q": "Which mechanism in C++ enables late binding?",
    "o": [
      "Virtual functions",
      "Function overloading",
      "Templates",
      "Static casting"
    ]
  },
  {
    "q": "What will happen if a class contains a pure virtual function but the function is not overridden in a derived class?",
    "o": [
      "The derived class also becomes abstract",
      "The program crashes",
      "The compiler auto-generates a default implementation",
      "The function call is ignored"
    ]
  },
  {
    "q": "What is the size impact of using virtual functions in a class?",
    "o": [
      "It adds a vptr to each object, increasing object size",
      "It reduces memory by avoiding inline expansion",
      "It makes objects smaller due to optimization",
      "There is no change in object size"
    ]
  },
  {
    "q": "Identify the correct statement about vtable in C++.",
    "o": [
      "Each class with virtual functions has its own vtable",
      "Each object has a unique vtable",
      "Only base classes have a vtable",
      "Vtables are created manually by the programmer"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    virtual void greet() {\n        cout << \"Hello from Base\" << endl;\n    }\n};\n\nclass Derived : public Base {};\n\nint main() {\n    Derived d;\n    Base* bptr = &d;\n    bptr->greet();\n    return 0;\n}",
    "o": [
      "Hello from Base",
      "Hello from Derived",
      "Compilation error",
      "Segmentation fault"
    ]
  },
  {
    "q": "Which statement about function overloading is true?",
    "o": [
      "Function overloading allows multiple functions with the same name but different parameter lists",
      "Function overloading resolves at runtime using vtables",
      "Function overloading requires inheritance",
      "Function overloading only works with constructors"
    ]
  },
  {
    "q": "What will be the result of calling a virtual function inside a constructor?",
    "o": [
      "The base class version of the function will be called",
      "The derived class version will be called",
      "It causes a runtime error",
      "It cannot be done in C++"
    ]
  },
  {
    "q": "Which of the following best defines an abstract class in C++?",
    "o": [
      "A class containing at least one pure virtual function",
      "A class that has no member functions",
      "A class that uses templates",
      "A class inherited privately"
    ]
  },
  {
    "q": "Which of the following best describes runtime polymorphism in C++?",
    "o": [
      "Function behavior is determined at runtime using virtual functions",
      "Functions are resolved at compile time based on parameters",
      "All function calls are inlined",
      "It only occurs with function overloading"
    ]
  },
  {
    "q": "What will be the output of this C++ code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    virtual void print() {\n        cout << \"Base\";\n    }\n};\n\nclass Derived : public Base {\npublic:\n    void print() {\n        cout << \"Derived\";\n    }\n};\n\nint main() {\n    Base* ptr;\n    Derived d;\n    ptr = &d;\n    ptr->print();\n    return 0;\n}",
    "o": [
      "Derived",
      "Base",
      "Compilation error",
      "Runtime error"
    ]
  },
  {
    "q": "Which of the following correctly overloads the '+' operator in a class?",
    "o": [
      "MyClass operator+(const MyClass& obj);",
      "virtual MyClass operator+(MyClass obj);",
      "operator+(MyClass obj);",
      "MyClass +operator(MyClass obj);"
    ]
  },
  {
    "q": "Which feature of C++ uses a virtual table internally?",
    "o": [
      "Runtime polymorphism",
      "Templates",
      "Function overloading",
      "Friend functions"
    ]
  },
  {
    "q": "What does a class become if it contains at least one pure virtual function?",
    "o": [
      "An abstract class",
      "A base class",
      "A derived class",
      "A template class"
    ]
  },
  {
    "q": "What is the role of vptr in runtime polymorphism?",
    "o": [
      "It points to the virtual table (vtable) of the class",
      "It stores object data members",
      "It calls overloaded functions",
      "It enables multiple inheritance"
    ]
  },
  {
    "q": "Which line defines a function as a pure virtual function?",
    "o": [
      "virtual void display() = 0;",
      "virtual void display() {}",
      "void display() = 0;",
      "pure virtual display();"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n    void show(int x) {\n        cout << \"Int: \" << x << endl;\n    }\n    void show(string s) {\n        cout << \"String: \" << s << endl;\n    }\n};\n\nint main() {\n    A obj;\n    obj.show(\"C++\");\n    return 0;\n}",
    "o": [
      "String: C++",
      "Int: C++",
      "Compilation error",
      "Runtime error"
    ]
  },
  {
    "q": "What is the major drawback of using virtual functions?",
    "o": [
      "They introduce slight runtime overhead due to dynamic dispatch",
      "They prevent function overloading",
      "They increase compile-time significantly",
      "They cannot be overridden"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n    A() { show(); }\n    virtual void show() { cout << \"A\"; }\n};\n\nclass B : public A {\npublic:\n    void show() override { cout << \"B\"; }\n};\n\nint main() {\n    B obj;\n    return 0;\n}",
    "o": [
      "A",
      "B",
      "AB",
      "BA"
    ]
  },
  {
    "q": "Which of the following is resolved during compile time in C++?",
    "o": [
      "Function overloading",
      "Virtual function dispatch",
      "Pure virtual function implementation",
      "Dynamic casting"
    ]
  },
  {
    "q": "What will be the output of the following C++ code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Sample {\npublic:\n    void display(int x) {\n        cout << \"Integer: \" << x;\n    }\n    void display(char c) {\n        cout << \"Character: \" << c;\n    }\n};\n\nint main() {\n    Sample s;\n    s.display('A');\n    return 0;\n}",
    "o": [
      "Character: A",
      "Integer: 65",
      "Compilation Error",
      "Runtime Error"
    ]
  },
  {
    "q": "Which of the following best describes a pure virtual function?",
    "o": [
      "A function with no implementation and defined as = 0",
      "A function implemented in base class but overridden",
      "A non-virtual function with empty body",
      "A static member function"
    ]
  },
  {
    "q": "In which of the following cases is the vptr modified?",
    "o": [
      "When an object of a derived class is created",
      "When an overloaded function is called",
      "When a non-virtual method is executed",
      "When a global variable is accessed"
    ]
  },
  {
    "q": "What will be the output of the following C++ program?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n    virtual void show() { cout << \"A\"; }\n};\n\nclass B : public A {\npublic:\n    void show() { cout << \"B\"; }\n};\n\nint main() {\n    A a;\n    B b;\n    A* ptr = &a;\n    ptr->show();\n    ptr = &b;\n    ptr->show();\n    return 0;\n}",
    "o": [
      "AB",
      "AA",
      "BB",
      "BA"
    ]
  },
  {
    "q": "Which of the following C++ features is an example of function overloading?",
    "o": [
      "Defining multiple functions with same name but different parameter types",
      "Using virtual functions in inheritance",
      "Creating pure virtual base classes",
      "Accessing protected members in base class"
    ]
  },
  {
    "q": "Which C++ keyword enables dynamic binding?",
    "o": [
      "virtual",
      "static",
      "inline",
      "const"
    ]
  },
  {
    "q": "What is the correct way to declare an abstract class in C++?",
    "o": [
      "By having at least one pure virtual function",
      "By marking the class with 'abstract'",
      "By using the keyword 'interface'",
      "By not defining any data members"
    ]
  },
  {
    "q": "Which of the following is true about operator overloading?",
    "o": [
      "It allows user-defined implementation of operators for class types",
      "It can be used to override virtual functions",
      "It disables the original behavior of operators",
      "It is done using pure virtual functions"
    ]
  },
  {
    "q": "What will be the output of the following code involving an abstract class?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Shape {\npublic:\n    virtual void draw() = 0;\n};\n\nclass Circle : public Shape {\npublic:\n    void draw() { cout << \"Circle\"; }\n};\n\nint main() {\n    Shape* s = new Circle();\n    s->draw();\n    delete s;\n    return 0;\n}",
    "o": [
      "Circle",
      "Shape",
      "Draw",
      "Compilation error"
    ]
  },
  {
    "q": "Which concept allows multiple functions with the same name but different parameter types?",
    "o": [
      "Function overloading",
      "Function overriding",
      "Virtual functions",
      "Templates"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    void show() {\n        cout << \"Base\";\n    }\n};\n\nclass Derived : public Base {\npublic:\n    void show() {\n        cout << \"Derived\";\n    }\n};\n\nint main() {\n    Base* b = new Derived();\n    b->show();\n    delete b;\n    return 0;\n}",
    "o": [
      "Base",
      "Derived",
      "BaseDerived",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following must a class have to be considered an abstract class?",
    "o": [
      "At least one pure virtual function",
      "A constructor",
      "A virtual destructor",
      "Private members only"
    ]
  },
  {
    "q": "What is the main purpose of the vtable in C++?",
    "o": [
      "To support runtime dispatch of virtual functions",
      "To allocate memory for class objects",
      "To store static function addresses",
      "To hold non-virtual function calls"
    ]
  },
  {
    "q": "Which of the following operator overloads is valid for a class?",
    "o": [
      "bool operator==(const MyClass& obj) const;",
      "static void operator+(int x);",
      "void operator=() const;",
      "operator this();"
    ]
  },
  {
    "q": "What happens if a pure virtual function is not overridden in the derived class?",
    "o": [
      "The derived class becomes abstract",
      "The program will crash",
      "The compiler automatically provides an implementation",
      "The base version will be called"
    ]
  },
  {
    "q": "What is printed when this code is executed?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n    virtual void f() { cout << \"A::f \"; }\n};\n\nclass B : public A {\npublic:\n    void f() override { cout << \"B::f \"; }\n};\n\nint main() {\n    A* p = new B();\n    p->f();\n    delete p;\n    return 0;\n}",
    "o": [
      "B::f",
      "A::f",
      "Compilation Error",
      "Runtime Error"
    ]
  },
  {
    "q": "How many vptrs are typically created per object in a class with virtual functions (single inheritance)?",
    "o": [
      "One",
      "Two",
      "Zero",
      "One per function"
    ]
  },
  {
    "q": "Which of the following scenarios involves function overriding?",
    "o": [
      "Derived class redefines a base class virtual function",
      "Two functions with same name and different parameters",
      "Using the same function in two unrelated classes",
      "A function inside a template class"
    ]
  },
  {
    "q": "Which of the following will create a compilation error?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Animal {\npublic:\n    virtual void speak() = 0;\n};\n\nclass Dog : public Animal {\n};\n\nint main() {\n    Dog d;\n    return 0;\n}",
    "o": [
      "Dog d; // Error: speak() not implemented",
      "Animal a; // Error: Cannot instantiate abstract class",
      "cout << d; // Error: operator<< not defined",
      "return 0; // Error: No main"
    ]
  },
  {
    "q": "Which of the following is NOT required to implement compile-time polymorphism?",
    "o": [
      "Virtual functions",
      "Function overloading",
      "Operator overloading",
      "Templates"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Print {\npublic:\n    void display(int a) {\n        cout << \"Integer: \" << a;\n    }\n    void display(double d) {\n        cout << \"Double: \" << d;\n    }\n};\n\nint main() {\n    Print p;\n    p.display(3.14);\n    return 0;\n}",
    "o": [
      "Double: 3.14",
      "Integer: 3.14",
      "Double: 3",
      "Compilation error"
    ]
  },
  {
    "q": "Which statement is TRUE about virtual functions in C++?",
    "o": [
      "They enable runtime polymorphism via dynamic binding",
      "They must be overloaded in base class",
      "They only work with friend functions",
      "They are evaluated during compile-time"
    ]
  },
  {
    "q": "Which of these best describes the purpose of a virtual destructor?",
    "o": [
      "To ensure derived class destructors are called when using base class pointers",
      "To make the class abstract",
      "To allow constructor overloading",
      "To support operator overloading"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n    virtual void fun() { cout << \"A::fun \"; }\n};\n\nclass B : public A {\npublic:\n    void fun() { cout << \"B::fun \"; }\n};\n\nint main() {\n    A a;\n    B b;\n    A* ptr = &b;\n    ptr->fun();\n    return 0;\n}",
    "o": [
      "B::fun",
      "A::fun",
      "A::fun B::fun",
      "Compilation error"
    ]
  },
  {
    "q": "What makes a function a 'pure virtual' function in C++?",
    "o": [
      "It is declared with = 0 and no implementation",
      "It is declared with the keyword 'pure'",
      "It is overloaded multiple times",
      "It is marked as final"
    ]
  },
  {
    "q": "Which of the following statements about vtables is true?",
    "o": [
      "Vtables map virtual functions to their actual addresses at runtime",
      "Vtables are used for function overloading",
      "Each object stores its own vtable",
      "Vtables are only used in templates"
    ]
  },
  {
    "q": "What is the main difference between overriding and overloading?",
    "o": [
      "Overriding happens in inheritance; overloading occurs in the same scope",
      "Overloading uses virtual functions; overriding does not",
      "Overriding works only with static methods",
      "Overloading requires pure virtual functions"
    ]
  },
  {
    "q": "Which code snippet demonstrates operator overloading correctly?",
    "o": [
      "Complex operator+(const Complex& c);",
      "virtual Complex operator+(Complex c);",
      "Complex operator=(Complex c);",
      "Complex operator::+(Complex c);"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Shape {\npublic:\n    virtual void draw() = 0;\n};\n\nclass Square : public Shape {\npublic:\n    void draw() override { cout << \"Square\"; }\n};\n\nint main() {\n    Shape* s = new Square();\n    s->draw();\n    delete s;\n    return 0;\n}",
    "o": [
      "Square",
      "Shape",
      "draw",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is an example of compile-time polymorphism in C++?",
    "o": [
      "Operator overloading",
      "Virtual functions",
      "Function overriding",
      "Dynamic dispatch"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Test {\npublic:\n    void show() {\n        cout << \"show() with no parameters\";\n    }\n    void show(int x) {\n        cout << \"show() with int: \" << x;\n    }\n};\n\nint main() {\n    Test t;\n    t.show();\n    return 0;\n}",
    "o": [
      "show() with no parameters",
      "show() with int: 0",
      "Compilation error",
      "Runtime error"
    ]
  },
  {
    "q": "How is the vtable typically implemented in C++?",
    "o": [
      "As a static table containing addresses of virtual functions",
      "As a dynamic array of function pointers",
      "As a list of class objects",
      "As a lookup map of strings to functions"
    ]
  },
  {
    "q": "Which of these makes a class abstract in C++?",
    "o": [
      "It contains at least one pure virtual function",
      "It has only private members",
      "It contains a virtual destructor",
      "It uses operator overloading"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n    virtual void print() { cout << \"A::print \"; }\n};\n\nclass B : public A {\npublic:\n    void print() override { cout << \"B::print \"; }\n};\n\nint main() {\n    A* a = new B();\n    a->print();\n    delete a;\n    return 0;\n}",
    "o": [
      "B::print",
      "A::print",
      "A::print B::print",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following operators cannot be overloaded in C++?",
    "o": [
      "?: (ternary operator)",
      "== (equality operator)",
      "[] (subscript operator)",
      "-> (member access operator)"
    ]
  },
  {
    "q": "Which keyword allows a derived class to provide a new implementation of a base class virtual function?",
    "o": [
      "override",
      "static",
      "template",
      "friend"
    ]
  },
  {
    "q": "In C++, the vptr is used for:",
    "o": [
      "Pointing to the virtual function table of a class instance",
      "Accessing protected members",
      "Handling function overloading",
      "Managing memory allocation"
    ]
  },
  {
    "q": "Choose the correct output of this program:",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Animal {\npublic:\n    virtual void sound() = 0;\n};\n\nclass Cat : public Animal {\npublic:\n    void sound() override { cout << \"Meow\"; }\n};\n\nint main() {\n    Animal* a = new Cat();\n    a->sound();\n    delete a;\n    return 0;\n}",
    "o": [
      "Meow",
      "sound",
      "Animal",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following best describes function overriding?",
    "o": [
      "Redefining a base class's virtual function in the derived class",
      "Writing multiple functions with the same name but different parameters",
      "Overloading operators in a class",
      "Using templates to define functions"
    ]
  },
  {
    "q": "Which concept allows functions with the same name but different signatures to coexist in C++?",
    "o": [
      "Function overloading",
      "Function overriding",
      "Virtual functions",
      "Pure virtual functions"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n    virtual void show() { cout << \"A\"; }\n};\n\nclass B : public A {\npublic:\n    void show() override { cout << \"B\"; }\n};\n\nint main() {\n    A a;\n    B b;\n    A* ptr = &b;\n    ptr->show();\n    return 0;\n}",
    "o": [
      "B",
      "A",
      "AB",
      "Compilation Error"
    ]
  },
  {
    "q": "Which of the following best describes runtime polymorphism?",
    "o": [
      "Function behavior is determined at runtime using virtual functions",
      "Multiple functions share the same name but have different parameters",
      "A class inherits multiple base classes",
      "Static function calls are resolved at compile time"
    ]
  },
  {
    "q": "What role does the 'vptr' play in runtime polymorphism?",
    "o": [
      "It points to the vtable of the current object for dynamic dispatch",
      "It manages memory allocation for base class objects",
      "It stores overloaded operator addresses",
      "It binds function calls at compile time"
    ]
  },
  {
    "q": "What will be printed by the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Parent {\npublic:\n    virtual void print() { cout << \"Parent\"; }\n};\n\nclass Child : public Parent {\npublic:\n    void print() { cout << \"Child\"; }\n};\n\nint main() {\n    Parent* p = new Child();\n    p->print();\n    delete p;\n    return 0;\n}",
    "o": [
      "Child",
      "Parent",
      "ParentChild",
      "Compilation Error"
    ]
  },
  {
    "q": "Which operator cannot be overloaded in C++?",
    "o": [
      "sizeof",
      "==",
      "+",
      "[]"
    ]
  },
  {
    "q": "What does declaring a function with '= 0' signify in C++?",
    "o": [
      "It is a pure virtual function",
      "It is an overloaded function",
      "It is a default argument function",
      "It disables virtual dispatch"
    ]
  },
  {
    "q": "Which statement about abstract classes is correct?",
    "o": [
      "You cannot create objects of abstract classes",
      "They can contain only virtual functions",
      "They cannot have constructors",
      "They must inherit from a base class"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    void show() { cout << \"Base\"; }\n};\n\nclass Derived : public Base {\npublic:\n    void show() { cout << \"Derived\"; }\n};\n\nint main() {\n    Base* b = new Derived();\n    b->show();\n    delete b;\n    return 0;\n}",
    "o": [
      "Base",
      "Derived",
      "BaseDerived",
      "Compilation error"
    ]
  },
  {
    "q": "Which keyword is essential to achieve runtime polymorphism?",
    "o": [
      "virtual",
      "static",
      "explicit",
      "template"
    ]
  },
  {
    "q": "Which of the following allows a derived class to override a base class method in C++?",
    "o": [
      "Declaring the base method as virtual",
      "Using the static keyword",
      "Making the method inline",
      "Overloading the method"
    ]
  },
  {
    "q": "What will be the output of this program?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass X {\npublic:\n    virtual void f() { cout << \"X::f\"; }\n};\n\nclass Y : public X {\npublic:\n    void f() { cout << \"Y::f\"; }\n};\n\nint main() {\n    X* x = new Y();\n    x->f();\n    delete x;\n    return 0;\n}",
    "o": [
      "Y::f",
      "X::f",
      "Compilation error",
      "Runtime error"
    ]
  },
  {
    "q": "Which term refers to resolving function calls at compile time?",
    "o": [
      "Static binding",
      "Dynamic binding",
      "Late binding",
      "Virtual dispatch"
    ]
  },
  {
    "q": "Which of these classes is abstract?",
    "o": [
      "A class with at least one pure virtual function",
      "A class with only virtual functions",
      "A class with a constructor",
      "A class with overloaded operators"
    ]
  },
  {
    "q": "Which feature enables function calls to be resolved at runtime?",
    "o": [
      "Virtual function mechanism",
      "Function templates",
      "Function overloading",
      "Inline expansion"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    virtual void show() { cout << \"Base\"; }\n};\n\nclass Derived : public Base {};\n\nint main() {\n    Base* b = new Derived();\n    b->show();\n    delete b;\n    return 0;\n}",
    "o": [
      "Base",
      "Derived",
      "BaseDerived",
      "Compilation error"
    ]
  },
  {
    "q": "What is true about the vtable in C++?",
    "o": [
      "It stores addresses of virtual functions for dynamic dispatch",
      "It exists only if operator overloading is used",
      "It is used for function overloading resolution",
      "It is stored in the stack memory"
    ]
  },
  {
    "q": "Which of the following is necessary to implement operator overloading?",
    "o": [
      "A function with a special operator keyword",
      "A virtual keyword in the operator function",
      "An abstract class",
      "A vtable pointer"
    ]
  },
  {
    "q": "Choose the valid overloaded function signatures:",
    "o": [
      "void print(); void print(int);",
      "void print(); void print();",
      "void print(int); void print(int);",
      "void print(int x); int print(int y);"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Abstract {\npublic:\n    virtual void foo() = 0;\n};\n\nclass Concrete : public Abstract {\npublic:\n    void foo() override { cout << \"Concrete::foo\"; }\n};\n\nint main() {\n    Abstract* obj = new Concrete();\n    obj->foo();\n    delete obj;\n    return 0;\n}",
    "o": [
      "Concrete::foo",
      "Abstract::foo",
      "foo",
      "Compilation error"
    ]
  },
  {
    "q": "What is required in a class to support runtime polymorphism?",
    "o": [
      "At least one virtual function",
      "Multiple constructors",
      "Overloaded functions",
      "Static member variables"
    ]
  },
  {
    "q": "What is the output of this code snippet?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n    void greet() { cout << \"Hello from A\"; }\n    void greet(string name) { cout << \"Hello, \" << name; }\n};\n\nint main() {\n    A obj;\n    obj.greet(\"Alice\");\n    return 0;\n}",
    "o": [
      "Hello, Alice",
      "Hello from A",
      "Hello Alice",
      "Compilation error"
    ]
  },
  {
    "q": "Which of these is an example of function overriding in C++?",
    "o": [
      "Derived class redefining a base class's virtual function",
      "Having multiple functions with the same name and different parameter types in one class",
      "Using a template to define multiple behaviors of a function",
      "Using the 'friend' keyword to access private members"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Shape {\npublic:\n    virtual void draw() { cout << \"Drawing Shape\"; }\n};\n\nclass Circle : public Shape {\npublic:\n    void draw() override { cout << \"Drawing Circle\"; }\n};\n\nint main() {\n    Shape* s = new Circle();\n    s->draw();\n    delete s;\n    return 0;\n}",
    "o": [
      "Drawing Circle",
      "Drawing Shape",
      "Circle",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following C++ features enables compile-time polymorphism?",
    "o": [
      "Function overloading",
      "Virtual functions",
      "Vtables",
      "Inheritance"
    ]
  },
  {
    "q": "Which one is a correct way to define a pure virtual function in C++?",
    "o": [
      "virtual void foo() = 0;",
      "virtual void foo();",
      "void foo() = virtual;",
      "pure virtual void foo();"
    ]
  },
  {
    "q": "What happens when an object of a class with a pure virtual function is instantiated?",
    "o": [
      "Compiler error: cannot instantiate abstract class",
      "Runtime error",
      "It calls the base class constructor",
      "It skips the pure virtual function"
    ]
  },
  {
    "q": "Which of the following correctly describes how virtual functions are dispatched at runtime?",
    "o": [
      "Through a vtable and vptr mechanism",
      "By static binding",
      "Via preprocessor macros",
      "By template specialization"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    virtual void speak() { cout << \"Base speaking\"; }\n};\n\nclass Derived : public Base {\npublic:\n    void speak() { cout << \"Derived speaking\"; }\n};\n\nint main() {\n    Base b;\n    b.speak();\n    return 0;\n}",
    "o": [
      "Base speaking",
      "Derived speaking",
      "BaseDerived",
      "Compilation error"
    ]
  },
  {
    "q": "Which of these statements is true about operator overloading?",
    "o": [
      "It is a form of compile-time polymorphism",
      "It allows changing the meaning of any operator in C++",
      "It is only allowed inside abstract classes",
      "It can only be done using virtual functions"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    virtual void display() { cout << \"Base class\"; }\n};\n\nclass Derived : public Base {\npublic:\n    void display() override { cout << \"Derived class\"; }\n};\n\nint main() {\n    Base* ptr = new Derived();\n    ptr->display();\n    delete ptr;\n    return 0;\n}",
    "o": [
      "Derived class",
      "Base class",
      "Base classDerived class",
      "Compilation error"
    ]
  },
  {
    "q": "Which one of the following statements is TRUE about virtual functions?",
    "o": [
      "They support runtime polymorphism by allowing overriding in derived classes",
      "They support compile-time polymorphism via function overloading",
      "They are resolved at compile time",
      "They can only be used with abstract classes"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n    A operator+(const A&) { cout << \"Operator + called\"; return A(); }\n};\n\nint main() {\n    A a1, a2;\n    A a3 = a1 + a2;\n    return 0;\n}",
    "o": [
      "Operator + called",
      "Compilation error",
      "Runtime error",
      "No output"
    ]
  },
  {
    "q": "How many vptrs does a class with one virtual function and no inheritance typically have?",
    "o": [
      "One",
      "Zero",
      "Depends on the number of virtual functions",
      "As many as the number of objects"
    ]
  },
  {
    "q": "Which of the following best describes an abstract class in C++?",
    "o": [
      "A class that contains at least one pure virtual function",
      "A class with no constructors",
      "A class that cannot inherit from another class",
      "A class that only has private members"
    ]
  },
  {
    "q": "What will be printed by this code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Animal {\npublic:\n    virtual void sound() = 0;\n};\n\nclass Dog : public Animal {\npublic:\n    void sound() { cout << \"Bark\"; }\n};\n\nint main() {\n    Animal* a = new Dog();\n    a->sound();\n    delete a;\n    return 0;\n}",
    "o": [
      "Bark",
      "Compilation error",
      "sound",
      "Animal"
    ]
  },
  {
    "q": "What is true about virtual destructors?",
    "o": [
      "They ensure proper destruction in case of base-class pointers pointing to derived objects",
      "They must be pure virtual functions",
      "They are only needed when using operator overloading",
      "They disable vtable creation"
    ]
  },
  {
    "q": "Which of the following is **not** a type of compile-time polymorphism in C++?",
    "o": [
      "Virtual functions",
      "Function overloading",
      "Operator overloading",
      "Template instantiation"
    ]
  },
  {
    "q": "Why can't you create an object of a class with a pure virtual function?",
    "o": [
      "Because it is an abstract class",
      "Because the compiler will treat it as a static class",
      "Because pure virtual functions cannot have implementations",
      "Because the object will not have a vtable"
    ]
  },
  {
    "q": "What is the role of the virtual table (vtable) in C++?",
    "o": [
      "It maps virtual function calls to the correct implementation at runtime",
      "It holds overloaded functions for compile-time dispatch",
      "It tracks memory usage of objects",
      "It is used for static analysis of templates"
    ]
  },
  {
    "q": "Which concept allows multiple functions to have the same name but different parameter lists in C++?",
    "o": [
      "Function overloading",
      "Virtual functions",
      "Function templates",
      "Pure virtual functions"
    ]
  },
  {
    "q": "What is the output of the following program?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Printer {\npublic:\n    void print(int i) { cout << \"Printing int: \" << i; }\n    void print(double d) { cout << \"Printing double: \" << d; }\n};\n\nint main() {\n    Printer p;\n    p.print(5.5);\n    return 0;\n}",
    "o": [
      "Printing double: 5.5",
      "Printing int: 5.5",
      "Printing float: 5.5",
      "Compilation error"
    ]
  },
  {
    "q": "Which feature is used in C++ to resolve method calls at runtime?",
    "o": [
      "Virtual functions with vtables",
      "Function overloading",
      "Default arguments",
      "Operator overloading"
    ]
  },
  {
    "q": "Which of the following is a property of a pure virtual function?",
    "o": [
      "It has no body and is assigned 0",
      "It is defined using `virtual` keyword only",
      "It must be defined in the constructor",
      "It must be static"
    ]
  },
  {
    "q": "What will be the output?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n    virtual void show() { cout << \"A\"; }\n};\n\nclass B : public A {\npublic:\n    void show() { cout << \"B\"; }\n};\n\nint main() {\n    A a;\n    B b;\n    A* ptr = &b;\n    ptr->show();\n    return 0;\n}",
    "o": [
      "B",
      "A",
      "AB",
      "Compilation error"
    ]
  },
  {
    "q": "What does the compiler generate for a class with virtual functions?",
    "o": [
      "A vtable and vptr for dynamic dispatch",
      "A new constructor",
      "A template instantiation",
      "An overloaded operator function"
    ]
  },
  {
    "q": "Why would you declare a function as virtual in the base class?",
    "o": [
      "To allow derived classes to override it for runtime polymorphism",
      "To enable inline expansion",
      "To disable overriding in derived classes",
      "To make the function abstract"
    ]
  },
  {
    "q": "Which statement is true about operator overloading in C++?",
    "o": [
      "It lets you define custom behavior for built-in operators",
      "It is used only with virtual functions",
      "It replaces all operator behavior globally",
      "It must be declared as pure virtual"
    ]
  },
  {
    "q": "What is the key difference between function overloading and function overriding?",
    "o": [
      "Overloading occurs in the same scope; overriding across inheritance",
      "Overriding uses default parameters",
      "Overloading can only happen in base classes",
      "Overriding does not involve inheritance"
    ]
  },
  {
    "q": "Which of these best defines runtime polymorphism?",
    "o": [
      "Function resolution happens at runtime using vtables",
      "Function calls are resolved during compilation",
      "Multiple constructors defined with different arguments",
      "Using `const` in function signatures"
    ]
  },
  {
    "q": "Which of the following is resolved using static (early) binding in C++?",
    "o": [
      "Function overloading",
      "Virtual functions",
      "Function overriding",
      "Pure virtual functions"
    ]
  },
  {
    "q": "What is the output of this program?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    virtual void foo() { cout << \"Base::foo\"; }\n};\n\nclass Derived : public Base {\npublic:\n    void foo() override { cout << \"Derived::foo\"; }\n};\n\nint main() {\n    Base* obj = new Derived();\n    obj->foo();\n    delete obj;\n    return 0;\n}",
    "o": [
      "Derived::foo",
      "Base::foo",
      "Compilation error",
      "Segmentation fault"
    ]
  },
  {
    "q": "What kind of polymorphism is implemented using virtual functions?",
    "o": [
      "Runtime polymorphism",
      "Compile-time polymorphism",
      "Template polymorphism",
      "Operator polymorphism"
    ]
  },
  {
    "q": "Which of these allows function resolution based on the type of object at runtime?",
    "o": [
      "Virtual function mechanism using vtables",
      "Function overloading resolution",
      "Inline expansion",
      "Constructor delegation"
    ]
  },
  {
    "q": "Which class in the below code is abstract?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Animal {\npublic:\n    virtual void speak() = 0;\n};\n\nclass Dog : public Animal {\npublic:\n    void speak() { cout << \"Woof\"; }\n};",
    "o": [
      "Animal",
      "Dog",
      "Both",
      "Neither"
    ]
  },
  {
    "q": "Which of the following is TRUE about vptr (virtual table pointer) in C++?",
    "o": [
      "Each object of a class with virtual functions contains a vptr",
      "vptr is shared among all instances of a class",
      "vptr is set manually by the programmer",
      "vptr is created only if the destructor is virtual"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Number {\npublic:\n    int value;\n    Number(int v) : value(v) {}\n    Number operator+(const Number& n) {\n        return Number(value + n.value);\n    }\n};\n\nint main() {\n    Number a(5), b(10);\n    Number c = a + b;\n    cout << c.value;\n    return 0;\n}",
    "o": [
      "15",
      "10",
      "5",
      "0"
    ]
  },
  {
    "q": "Which feature ensures correct destructor call in an inheritance hierarchy?",
    "o": [
      "Virtual destructor in base class",
      "Pure virtual destructor in base class",
      "Overloaded destructor",
      "Private destructor"
    ]
  },
  {
    "q": "Which of the following would make a class abstract in C++?",
    "o": [
      "Declaring at least one pure virtual function",
      "Using private constructors only",
      "Overloading the assignment operator",
      "Declaring a function with default parameters"
    ]
  },
  {
    "q": "Which operator can be overloaded in C++?",
    "o": [
      "+",
      "::",
      ".",
      "?:"
    ]
  },
  {
    "q": "What is the primary purpose of a vtable in C++?",
    "o": [
      "To support dynamic dispatch of virtual functions",
      "To overload operators at compile time",
      "To resolve overloaded functions",
      "To manage memory allocation of class objects"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Shape {\npublic:\n    virtual void draw() { cout << \"Shape\"; }\n};\n\nclass Circle : public Shape {\npublic:\n    void draw() override { cout << \"Circle\"; }\n};\n\nint main() {\n    Shape s;\n    Circle c;\n    Shape* ptr = &s;\n    ptr->draw();\n    ptr = &c;\n    ptr->draw();\n    return 0;\n}",
    "o": [
      "ShapeCircle",
      "CircleShape",
      "CircleCircle",
      "ShapeShape"
    ]
  },
  {
    "q": "Which of the following functions makes a class abstract?",
    "o": [
      "A pure virtual function",
      "A virtual destructor",
      "An inline member function",
      "A friend function"
    ]
  },
  {
    "q": "What is function overloading in C++?",
    "o": [
      "Defining multiple functions with the same name but different parameters",
      "Replacing a function in a derived class",
      "Declaring a function inside a class without definition",
      "Assigning multiple return types to the same function"
    ]
  },
  {
    "q": "What will the following program print?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    virtual void show() { cout << \"Base\"; }\n};\n\nclass Derived : public Base {\npublic:\n    void show(int) { cout << \"Derived\"; }\n};\n\nint main() {\n    Base* b = new Derived();\n    b->show();\n    delete b;\n    return 0;\n}",
    "o": [
      "Base",
      "Derived",
      "Compilation error",
      "No output"
    ]
  },
  {
    "q": "Which of the following is **not** an example of compile-time polymorphism?",
    "o": [
      "Virtual function overriding",
      "Function overloading",
      "Operator overloading",
      "Template instantiation"
    ]
  },
  {
    "q": "What does the following code do?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Demo {\npublic:\n    Demo operator*(const Demo&) { cout << \"* overloaded\"; return Demo(); }\n};\n\nint main() {\n    Demo a, b;\n    a * b;\n    return 0;\n}",
    "o": [
      "* overloaded",
      "Runtime error",
      "Nothing",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following correctly declares a pure virtual function?",
    "o": [
      "virtual void display() = 0;",
      "void display() = 0;",
      "virtual void display();",
      "pure virtual void display();"
    ]
  },
  {
    "q": "When is the vtable created for a class with virtual functions?",
    "o": [
      "At compile time",
      "At object creation time",
      "At runtime for each object",
      "It is not created in C++"
    ]
  },
  {
    "q": "Which is required to support runtime polymorphism in C++?",
    "o": [
      "Base class pointer or reference to a derived class object and virtual functions",
      "Operator overloading",
      "Multiple constructors",
      "Default arguments"
    ]
  },
  {
    "q": "Which of the following best demonstrates function overriding in C++?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n    virtual void greet() { cout << \"Hello from A\"; }\n};\n\nclass B : public A {\npublic:\n    void greet() override { cout << \"Hello from B\"; }\n};\n\nint main() {\n    A* obj = new B();\n    obj->greet();\n    delete obj;\n    return 0;\n}",
    "o": [
      "Hello from B",
      "Hello from A",
      "Compilation error",
      "Segmentation fault"
    ]
  },
  {
    "q": "Which keyword is necessary in the base class to enable runtime polymorphism?",
    "o": [
      "virtual",
      "inline",
      "friend",
      "static"
    ]
  },
  {
    "q": "What does the following code demonstrate?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Complex {\npublic:\n    int real;\n    Complex(int r) : real(r) {}\n    Complex operator+(const Complex& obj) {\n        return Complex(real + obj.real);\n    }\n};\n\nint main() {\n    Complex a(3), b(4);\n    Complex c = a + b;\n    cout << c.real;\n    return 0;\n}",
    "o": [
      "Operator overloading",
      "Function overriding",
      "Virtual function",
      "Runtime polymorphism"
    ]
  },
  {
    "q": "What is a key characteristic of a pure virtual function?",
    "o": [
      "It has no implementation in the base class and is set to 0",
      "It must be static",
      "It must be overloaded",
      "It can’t be inherited"
    ]
  },
  {
    "q": "Which of these operators cannot be overloaded in C++?",
    "o": [
      "sizeof",
      "+",
      "*",
      "=="
    ]
  },
  {
    "q": "What happens if a derived class does not override a pure virtual function?",
    "o": [
      "The derived class becomes abstract",
      "The program crashes",
      "The function call will fail",
      "The derived class is automatically instantiated"
    ]
  },
  {
    "q": "Which statement is TRUE about vptr in C++?",
    "o": [
      "Each object of a polymorphic class contains its own vptr",
      "vptr is shared between all instances",
      "vptr points to object data",
      "vptr is manually created by the programmer"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass X {\npublic:\n    virtual void show() { cout << \"X::show \"; }\n};\n\nclass Y : public X {\npublic:\n    void show() { cout << \"Y::show \"; }\n};\n\nint main() {\n    X x;\n    Y y;\n    X* ptr = &y;\n    ptr->show();\n    return 0;\n}",
    "o": [
      "Y::show",
      "X::show",
      "Compilation error",
      "Runtime error"
    ]
  },
  {
    "q": "Why are vtables used in C++?",
    "o": [
      "To enable runtime function resolution for virtual functions",
      "To optimize compile-time function overloading",
      "To store data member values",
      "To avoid memory leaks in inheritance"
    ]
  },
  {
    "q": "Which of the following enables compile-time polymorphism?",
    "o": [
      "Function templates and function overloading",
      "Virtual functions",
      "Pure virtual functions",
      "Inheritance and base class pointers"
    ]
  },
  {
    "q": "Which of the following is true about function overloading in C++?",
    "o": [
      "Functions must differ in the number or type of parameters",
      "Functions must differ in return type only",
      "Functions must have different names",
      "Functions must be virtual"
    ]
  },
  {
    "q": "What is the output of this program?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Parent {\npublic:\n    virtual void display() { cout << \"Parent\"; }\n};\n\nclass Child : public Parent {\npublic:\n    void display() { cout << \"Child\"; }\n};\n\nint main() {\n    Parent* ptr;\n    Child obj;\n    ptr = &obj;\n    ptr->display();\n    return 0;\n}",
    "o": [
      "Child",
      "Parent",
      "Compilation error",
      "Segmentation fault"
    ]
  },
  {
    "q": "Which C++ concept allows multiple definitions of the same function name with different parameters?",
    "o": [
      "Function overloading",
      "Function overriding",
      "Function hiding",
      "Virtual functions"
    ]
  },
  {
    "q": "Which of the following best describes an abstract class in C++?",
    "o": [
      "A class with at least one pure virtual function",
      "A class that cannot have a constructor",
      "A class that cannot be inherited",
      "A class that only contains static members"
    ]
  },
  {
    "q": "What is printed by the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n    virtual void show() { cout << \"A\"; }\n};\n\nclass B : public A {\npublic:\n    void show() { cout << \"B\"; }\n};\n\nint main() {\n    A a;\n    B b;\n    A* ptr = &a;\n    ptr->show();\n    ptr = &b;\n    ptr->show();\n    return 0;\n}",
    "o": [
      "AB",
      "AA",
      "BB",
      "BA"
    ]
  },
  {
    "q": "Which mechanism ensures dynamic dispatch of overridden methods at runtime?",
    "o": [
      "vtable and vptr",
      "Function templates",
      "Static binding",
      "Constructor overloading"
    ]
  },
  {
    "q": "What will be the output?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Demo {\npublic:\n    void show() { cout << \"Non-virtual show\"; }\n};\n\nint main() {\n    Demo obj;\n    obj.show();\n    return 0;\n}",
    "o": [
      "Non-virtual show",
      "Virtual show",
      "Compilation error",
      "Segmentation fault"
    ]
  },
  {
    "q": "Which of the following statements is TRUE about operator overloading?",
    "o": [
      "It allows redefining the way operators work for user-defined types",
      "Only arithmetic operators can be overloaded",
      "Overloading changes the operator's precedence",
      "Operators are overloaded using function templates"
    ]
  },
  {
    "q": "Which of these must be true for a class to support runtime polymorphism?",
    "o": [
      "It must have at least one virtual function",
      "It must use friend functions",
      "It must be inherited privately",
      "It must define a constructor"
    ]
  },
  {
    "q": "Which of the following best describes how C++ handles vtables?",
    "o": [
      "Each polymorphic class has one vtable shared by all objects",
      "Each object has its own unique vtable",
      "vtables are only created for abstract classes",
      "vtable creation is manual in C++"
    ]
  },
  {
    "q": "Which of the following best defines runtime polymorphism in C++?",
    "o": [
      "Ability to resolve method calls at runtime using virtual functions",
      "Resolving overloaded functions during compilation",
      "Defining functions with default arguments",
      "Using templates to generate multiple function versions"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    virtual void show() { cout << \"Base\"; }\n};\n\nclass Derived : public Base {\npublic:\n    void show() { cout << \"Derived\"; }\n};\n\nint main() {\n    Derived d;\n    Base& ref = d;\n    ref.show();\n    return 0;\n}",
    "o": [
      "Derived",
      "Base",
      "Compilation error",
      "Runtime error"
    ]
  },
  {
    "q": "What type of polymorphism does operator overloading provide?",
    "o": [
      "Compile-time polymorphism",
      "Runtime polymorphism",
      "Dynamic binding",
      "Late binding"
    ]
  },
  {
    "q": "Which of the following is true about a class that has at least one pure virtual function?",
    "o": [
      "It is an abstract class",
      "It cannot have a constructor",
      "It cannot have non-virtual functions",
      "It cannot be inherited"
    ]
  },
  {
    "q": "What is the purpose of the 'override' keyword in C++11 and later?",
    "o": [
      "It indicates the function is meant to override a virtual function from the base class",
      "It disables virtual behavior",
      "It makes a function static",
      "It forces function overloading"
    ]
  },
  {
    "q": "Which of the following code examples represents function overloading?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Print {\npublic:\n    void display(int x) { cout << x; }\n    void display(double y) { cout << y; }\n};\n\nint main() {\n    Print p;\n    p.display(5);\n    p.display(5.5);\n    return 0;\n}",
    "o": [
      "Function overloading",
      "Function overriding",
      "Virtual function call",
      "Runtime polymorphism"
    ]
  },
  {
    "q": "Which of the following members is not inherited by a derived class?",
    "o": [
      "Constructors",
      "Virtual functions",
      "Protected data members",
      "Public member functions"
    ]
  },
  {
    "q": "Which is true about a virtual function in C++?",
    "o": [
      "It enables dynamic dispatch when accessed through base class pointer or reference",
      "It must be overloaded",
      "It cannot be private",
      "It only works with friend functions"
    ]
  },
  {
    "q": "Which class contains the vptr for virtual function resolution?",
    "o": [
      "Each polymorphic object contains a hidden vptr",
      "The compiler creates a shared global vptr",
      "Only abstract base classes have vptrs",
      "Only virtual function pointers contain vptrs"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    virtual void fun() = 0;\n};\n\nclass Derived : public Base {\npublic:\n    void fun() { cout << \"Implemented\"; }\n};\n\nint main() {\n    Derived d;\n    d.fun();\n    return 0;\n}",
    "o": [
      "Implemented",
      "Base",
      "Compilation error",
      "No output"
    ]
  },
  {
    "q": "What is required for dynamic dispatch in C++?",
    "o": [
      "A virtual function in the base class",
      "Function overloading in derived class",
      "Static methods only",
      "Default arguments in functions"
    ]
  },
  {
    "q": "What does this code demonstrate?",
    "c": "#include <iostream>\nusing namespace std;\nclass Print {\npublic:\n    void display(int x) { cout << x << endl; }\n    void display(string y) { cout << y << endl; }\n};\nint main() {\n    Print obj;\n    obj.display(10);\n    obj.display(\"Text\");\n    return 0;\n}",
    "o": [
      "Function overloading",
      "Virtual function",
      "Function overriding",
      "Template specialization"
    ]
  },
  {
    "q": "Which of the following best describes vtables in C++?",
    "o": [
      "A lookup table used to resolve virtual functions at runtime",
      "A list of overloaded functions used at compile time",
      "A static map between class names and constructors",
      "A pointer to member functions stored in object"
    ]
  },
  {
    "q": "What happens if a class has a pure virtual function but provides no definition?",
    "o": [
      "It becomes an abstract class and cannot be instantiated",
      "It causes a runtime error",
      "It is treated as a non-virtual function",
      "It will not compile unless overridden"
    ]
  },
  {
    "q": "Which of the following operators can be overloaded?",
    "o": [
      "==",
      "::",
      ".",
      "sizeof"
    ]
  },
  {
    "q": "What will the following program output?",
    "c": "#include <iostream>\nusing namespace std;\nclass Base {\npublic:\n    virtual void greet() { cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void greet() override { cout << \"Derived\"; }\n};\nint main() {\n    Base* ptr = new Derived();\n    ptr->greet();\n    delete ptr;\n    return 0;\n}",
    "o": [
      "Derived",
      "Base",
      "No output",
      "Runtime error"
    ]
  },
  {
    "q": "Which scenario represents runtime polymorphism?",
    "o": [
      "Calling a virtual function through a base class pointer",
      "Overloading a constructor",
      "Using function templates",
      "Providing default parameters"
    ]
  },
  {
    "q": "Which of the following must be true for a class to be considered abstract in C++?",
    "o": [
      "It contains at least one pure virtual function",
      "It cannot have data members",
      "It has only private members",
      "It inherits another class"
    ]
  },
  {
    "q": "Which one of the following is not a feature of compile-time polymorphism?",
    "o": [
      "Virtual function overriding",
      "Function overloading",
      "Operator overloading",
      "Default argument matching"
    ]
  },
  {
    "q": "What does the 'vptr' in a C++ object point to?",
    "o": [
      "The virtual table of its class",
      "The base class function table",
      "The object’s member data",
      "The constructor of the class"
    ]
  },
  {
    "q": "Which of the following is an example of runtime polymorphism?",
    "o": [
      "Calling an overridden virtual function through a base class pointer",
      "Overloading a function within a class",
      "Using inline functions for optimization",
      "Using default parameters in functions"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    virtual void show() { cout << \"A\"; }\n};\nclass B : public A {\npublic:\n    void show() { cout << \"B\"; }\n};\nint main() {\n    A* obj = new B();\n    obj->show();\n    delete obj;\n    return 0;\n}",
    "o": [
      "B",
      "A",
      "Compilation error",
      "Runtime error"
    ]
  },
  {
    "q": "Which of the following cannot be overloaded in C++?",
    "o": [
      "The scope resolution operator (::)",
      "The equality operator (==)",
      "The addition operator (+)",
      "The stream insertion operator (<<)"
    ]
  },
  {
    "q": "What is the primary use of vptr in a C++ object?",
    "o": [
      "To point to the virtual table (vtable) of the class",
      "To resolve overloaded functions at compile time",
      "To store data member addresses",
      "To store constructor addresses"
    ]
  },
  {
    "q": "Which of the following defines an abstract class?",
    "o": [
      "A class with at least one pure virtual function",
      "A class with only private members",
      "A class that cannot be inherited",
      "A class with no constructors"
    ]
  },
  {
    "q": "What kind of polymorphism is used when a function has multiple definitions based on parameter types?",
    "o": [
      "Function overloading",
      "Function overriding",
      "Virtual dispatch",
      "Abstract interfacing"
    ]
  },
  {
    "q": "Which keyword is used to ensure that a function is overridden in derived classes?",
    "o": [
      "override",
      "virtual",
      "final",
      "static"
    ]
  },
  {
    "q": "What is printed by this program?",
    "c": "#include <iostream>\nusing namespace std;\nclass Shape {\npublic:\n    virtual void draw() = 0;\n};\nclass Circle : public Shape {\npublic:\n    void draw() { cout << \"Circle\"; }\n};\nint main() {\n    Shape* s = new Circle();\n    s->draw();\n    delete s;\n    return 0;\n}",
    "o": [
      "Circle",
      "Shape",
      "Nothing",
      "Compilation error"
    ]
  },
  {
    "q": "When is the vtable for a class typically generated?",
    "o": [
      "At compile time, if the class has virtual functions",
      "At runtime when the object is created",
      "Only when pure virtual functions are defined",
      "Manually by the programmer"
    ]
  },
  {
    "q": "Which of the following is a key characteristic of virtual functions?",
    "o": [
      "They support dynamic dispatch when called via base class pointers or references",
      "They always override base class methods",
      "They are resolved during compilation",
      "They cannot be inherited"
    ]
  },
  {
    "q": "Which feature allows C++ to invoke the appropriate function version based on the object type at runtime?",
    "o": [
      "Virtual functions",
      "Function overloading",
      "Static dispatch",
      "Default parameters"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    virtual void print() { cout << \"A::print\"; }\n};\nclass B : public A {\npublic:\n    void print() override { cout << \"B::print\"; }\n};\nint main() {\n    A* ptr = new B();\n    ptr->print();\n    delete ptr;\n    return 0;\n}",
    "o": [
      "B::print",
      "A::print",
      "Compilation error",
      "Segmentation fault"
    ]
  },
  {
    "q": "Which of these keywords is used to declare a pure virtual function in C++?",
    "o": [
      "= 0",
      "virtual only",
      "abstract",
      "const = 0"
    ]
  },
  {
    "q": "Which concept resolves overloaded functions during compilation?",
    "o": [
      "Compile-time polymorphism",
      "Runtime polymorphism",
      "Virtual function table",
      "Static linking"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\nclass Demo {\npublic:\n    void show(int x) { cout << \"int\"; }\n    void show(double x) { cout << \"double\"; }\n};\nint main() {\n    Demo d;\n    d.show(3.14);\n    return 0;\n}",
    "o": [
      "double",
      "int",
      "Compilation error",
      "Runtime error"
    ]
  },
  {
    "q": "What is the role of a virtual table (vtable) in C++?",
    "o": [
      "It stores pointers to virtual functions for a class",
      "It stores overloaded function versions",
      "It helps resolve template instantiations",
      "It maps class names to object addresses"
    ]
  },
  {
    "q": "What happens if you try to instantiate an abstract class in C++?",
    "o": [
      "Compiler error",
      "Runtime error",
      "Linker warning",
      "Undefined behavior"
    ]
  },
  {
    "q": "What operator is typically overloaded for custom comparison logic?",
    "o": [
      "==",
      "::",
      "->",
      "[]"
    ]
  },
  {
    "q": "Which of the following statements is true regarding vptr?",
    "o": [
      "Each polymorphic object contains its own vptr pointing to the vtable",
      "Only base classes contain vptrs",
      "vptr is shared across all instances of a class",
      "vptr only works with operator overloading"
    ]
  },
  {
    "q": "What is printed by this code?",
    "c": "#include <iostream>\nusing namespace std;\nclass Animal {\npublic:\n    virtual void speak() = 0;\n};\nclass Dog : public Animal {\npublic:\n    void speak() { cout << \"Woof\"; }\n};\nint main() {\n    Animal* a = new Dog();\n    a->speak();\n    delete a;\n    return 0;\n}",
    "o": [
      "Woof",
      "Animal",
      "Nothing",
      "Compilation error"
    ]
  },
  {
    "q": "Which kind of polymorphism is resolved during program compilation?",
    "o": [
      "Function overloading",
      "Virtual function call",
      "Function overriding",
      "Abstract method invocation"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\nusing namespace std;\nclass X {\npublic:\n    void display() { cout << \"X\"; }\n};\nclass Y : public X {\npublic:\n    void display() { cout << \"Y\"; }\n};\nint main() {\n    X* ptr = new Y();\n    ptr->display();\n    delete ptr;\n    return 0;\n}",
    "o": [
      "X",
      "Y",
      "XY",
      "Runtime error"
    ]
  },
  {
    "q": "Which of the following ensures that a derived class must implement a function?",
    "o": [
      "Declaring the function as pure virtual in the base class",
      "Marking it as private in the base class",
      "Using `static` in the function declaration",
      "Defining the function only in the derived class"
    ]
  },
  {
    "q": "Which operator is commonly overloaded for object assignment?",
    "o": [
      "=",
      "++",
      "&",
      "~"
    ]
  },
  {
    "q": "What does a class become if it contains at least one pure virtual function?",
    "o": [
      "Abstract class",
      "Virtual base class",
      "Static class",
      "Template class"
    ]
  },
  {
    "q": "What is the output of the following program?",
    "c": "#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    virtual void show() { cout << \"A\"; }\n};\nclass B : public A {\n};\nint main() {\n    A* obj = new B();\n    obj->show();\n    delete obj;\n    return 0;\n}",
    "o": [
      "A",
      "B",
      "Nothing",
      "Compilation Error"
    ]
  },
  {
    "q": "What is the key component inside every polymorphic object that enables dynamic dispatch?",
    "o": [
      "vptr",
      "vref",
      "vfunc",
      "vtblist"
    ]
  },
  {
    "q": "Which concept allows the same function name to have different meanings depending on context?",
    "o": [
      "Polymorphism",
      "Encapsulation",
      "Inheritance",
      "Abstraction"
    ]
  },
  {
    "q": "What does the keyword `virtual` indicate when used in a base class method?",
    "o": [
      "That the method can be overridden in a derived class",
      "That the method is overloaded",
      "That the method is static",
      "That the method is a template"
    ]
  },
  {
    "q": "What is printed by this code snippet?",
    "c": "#include <iostream>\nusing namespace std;\nclass Base {\npublic:\n    virtual void func(int x) { cout << \"Base\"; }\n    void func(double y) { cout << \"Overload\"; }\n};\nint main() {\n    Base b;\n    b.func(3.14);\n    return 0;\n}",
    "o": [
      "Overload",
      "Base",
      "BaseOverload",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following best describes operator overloading?",
    "o": [
      "Redefining the behavior of an operator for user-defined types",
      "Writing multiple versions of the same operator",
      "Linking multiple functions with the same name",
      "Replacing a standard operator with a function call"
    ]
  },
  {
    "q": "What is printed by this program?",
    "c": "#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    virtual void print() { cout << \"A\"; }\n};\nclass B : public A {\npublic:\n    void print() override { cout << \"B\"; }\n};\nint main() {\n    A a;\n    B b;\n    A* ptr = &b;\n    ptr->print();\n    return 0;\n}",
    "o": [
      "B",
      "A",
      "AB",
      "Compilation Error"
    ]
  },
  {
    "q": "Which mechanism allows C++ to resolve a virtual function call at runtime?",
    "o": [
      "vtable and vptr",
      "Templates",
      "Function overloading",
      "Inline functions"
    ]
  },
  {
    "q": "What happens when a class with a pure virtual function is instantiated?",
    "o": [
      "Compiler error",
      "Segmentation fault at runtime",
      "Undefined behavior",
      "Linker warning"
    ]
  },
  {
    "q": "Which of these can be overloaded in C++?",
    "o": [
      "The function call operator ()",
      "The scope resolution operator ::",
      "The member access operator .",
      "The ternary operator ?:"
    ]
  },
  {
    "q": "How many vptrs does an object of a class with a single inheritance and one virtual function typically have?",
    "o": [
      "One",
      "Two",
      "Zero",
      "Depends on the compiler"
    ]
  },
  {
    "q": "Which of the following is required to achieve polymorphic behavior with virtual functions?",
    "o": [
      "Calling the function through a base class pointer or reference",
      "Using the `new` operator",
      "Defining the base class as abstract",
      "Using static member functions"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\nusing namespace std;\nclass Base {\npublic:\n    virtual void f(int x) { cout << \"Base::f\"; }\n};\nclass Derived : public Base {\npublic:\n    void f(double x) { cout << \"Derived::f\"; }\n};\nint main() {\n    Derived d;\n    d.f(10);\n    return 0;\n}",
    "o": [
      "Derived::f",
      "Base::f",
      "Compilation error",
      "Base::fDerived::f"
    ]
  },
  {
    "q": "What distinguishes a virtual destructor from a regular one in a polymorphic class?",
    "o": [
      "It ensures proper destruction of derived class objects through base class pointers",
      "It prevents the use of default constructors",
      "It disables object slicing",
      "It disallows the use of operator overloading"
    ]
  },
  {
    "q": "What is a correct consequence of not marking a base class function `virtual` when it is overridden?",
    "o": [
      "The base class version will be called even when the object is of derived type",
      "The program will crash during execution",
      "The derived version will always be used",
      "Compilation will fail"
    ]
  },
  {
    "q": "Which form of polymorphism is implemented via virtual functions?",
    "o": [
      "Runtime polymorphism",
      "Compile-time polymorphism",
      "Operator overloading",
      "Function templates"
    ]
  },
  {
    "q": "What will this program print?",
    "c": "#include <iostream>\nusing namespace std;\nclass Base {\npublic:\n    virtual void print() { cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void print() { cout << \"Derived\"; }\n};\nint main() {\n    Base* bptr = new Derived();\n    bptr->print();\n    delete bptr;\n    return 0;\n}",
    "o": [
      "Derived",
      "Base",
      "DerivedBase",
      "Compilation Error"
    ]
  },
  {
    "q": "Which of the following operators cannot be overloaded in C++?",
    "o": [
      "::",
      "+",
      "[]",
      "->"
    ]
  },
  {
    "q": "Which of the following is the correct way to declare a pure virtual function?",
    "o": [
      "virtual void func() = 0;",
      "virtual void func() {} = 0;",
      "void virtual func() = 0;",
      "pure virtual void func();"
    ]
  },
  {
    "q": "What is the role of vptr in polymorphism?",
    "o": [
      "It points to the vtable for the class of the object",
      "It stores the base class address",
      "It handles operator overload resolution",
      "It holds function parameters at runtime"
    ]
  },
  {
    "q": "What is printed by this code?",
    "c": "#include <iostream>\nusing namespace std;\nclass Base {\npublic:\n    virtual void show() { cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void show(int x) { cout << \"Derived\"; }\n};\nint main() {\n    Derived d;\n    d.show(5);\n    return 0;\n}",
    "o": [
      "Derived",
      "Base",
      "BaseDerived",
      "Compilation error"
    ]
  },
  {
    "q": "Which concept enables polymorphism through function overloading?",
    "o": [
      "Compile-time polymorphism",
      "Dynamic dispatch",
      "Abstract classes",
      "Virtual tables"
    ]
  },
  {
    "q": "If a class has at least one pure virtual function, which of the following is true?",
    "o": [
      "The class becomes abstract",
      "The class must inherit from another class",
      "The class cannot have any member functions",
      "Objects of this class can be created"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    virtual void func() { cout << \"A\"; }\n};\nclass B : public A {\npublic:\n    void func() override { cout << \"B\"; }\n};\nclass C : public B {\npublic:\n    void func() override { cout << \"C\"; }\n};\nint main() {\n    A* obj = new C();\n    obj->func();\n    delete obj;\n    return 0;\n}",
    "o": [
      "C",
      "B",
      "A",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following best describes the vtable?",
    "o": [
      "An array of function pointers to the class's virtual functions",
      "A list of overloaded functions for a class",
      "A runtime stack used for recursion",
      "A mapping of class data members"
    ]
  },
  {
    "q": "Which of the following best demonstrates function overloading in C++?",
    "o": [
      "Defining multiple functions with the same name but different parameter types",
      "Redefining a virtual function in a derived class",
      "Using a base class pointer to call a derived class function",
      "Using templates to define generic functions"
    ]
  },
  {
    "q": "What will the following program output?",
    "c": "#include <iostream>\nusing namespace std;\nclass Base {\npublic:\n    virtual void show() { cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void show() override { cout << \"Derived\"; }\n};\nint main() {\n    Base obj;\n    obj.show();\n    return 0;\n}",
    "o": [
      "Base",
      "Derived",
      "BaseDerived",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following statements about pure virtual functions is true?",
    "o": [
      "They make a class abstract and must be overridden in derived classes",
      "They are automatically inherited and cannot be overridden",
      "They are implemented in the base class",
      "They disable runtime polymorphism"
    ]
  },
  {
    "q": "What does the vtable store?",
    "o": [
      "Addresses of virtual functions for a class",
      "Values of class data members",
      "Static function pointers",
      "Stack frame information"
    ]
  },
  {
    "q": "Which of these is an example of compile-time polymorphism?",
    "o": [
      "Operator overloading",
      "Virtual function overriding",
      "Calling a pure virtual function",
      "Using a vptr to resolve a method"
    ]
  },
  {
    "q": "Which of the following operators can be overloaded?",
    "o": [
      "+",
      "::",
      "?:",
      "."
    ]
  },
  {
    "q": "What will this code print?",
    "c": "#include <iostream>\nusing namespace std;\nclass Shape {\npublic:\n    virtual void draw() = 0;\n};\nclass Circle : public Shape {\npublic:\n    void draw() override { cout << \"Circle\"; }\n};\nint main() {\n    Shape* s = new Circle();\n    s->draw();\n    delete s;\n    return 0;\n}",
    "o": [
      "Circle",
      "Shape",
      "CircleShape",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is a characteristic of runtime polymorphism?",
    "o": [
      "Function resolution occurs during program execution",
      "All functions must be inline",
      "Functions must be static",
      "Functions are resolved at compile time"
    ]
  },
  {
    "q": "What happens if a derived class does not override a pure virtual function?",
    "o": [
      "The derived class becomes abstract",
      "The function is called from the base class",
      "Compilation succeeds normally",
      "Runtime error occurs"
    ]
  },
  {
    "q": "Which mechanism ensures that the correct overridden method is called at runtime?",
    "o": [
      "Virtual function table (vtable)",
      "Overloaded constructor",
      "Function template",
      "Namespace resolution"
    ]
  },
  {
    "q": "Which of the following describes runtime polymorphism in C++?",
    "o": [
      "Function call resolution is done at runtime using virtual functions",
      "Overloading functions based on argument types",
      "Templates instantiated during compilation",
      "Inlining of functions for better performance"
    ]
  },
  {
    "q": "What will be the output of this program?",
    "c": "#include <iostream>\nusing namespace std;\nclass Animal {\npublic:\n    virtual void sound() { cout << \"Animal\"; }\n};\nclass Dog : public Animal {\npublic:\n    void sound() { cout << \"Bark\"; }\n};\nint main() {\n    Animal a;\n    Dog d;\n    Animal* ptr = &d;\n    ptr->sound();\n    return 0;\n}",
    "o": [
      "Bark",
      "Animal",
      "BarkAnimal",
      "Compilation Error"
    ]
  },
  {
    "q": "Which of the following is a requirement for function overloading?",
    "o": [
      "Functions must have different parameter types or numbers",
      "Functions must have different return types",
      "Functions must be declared as virtual",
      "Functions must be declared outside any class"
    ]
  },
  {
    "q": "What is the purpose of `vptr` in C++?",
    "o": [
      "To point to the vtable of the object’s class",
      "To store object memory location",
      "To define the size of virtual functions",
      "To manage memory allocation of base class"
    ]
  },
  {
    "q": "Which of the following is true about abstract classes in C++?",
    "o": [
      "They cannot be instantiated directly",
      "They must have only static members",
      "They cannot have any constructors",
      "They cannot be inherited"
    ]
  },
  {
    "q": "What will be the result of compiling and running this code?",
    "c": "#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    virtual void show() = 0;\n};\nclass B : public A {\n};\nint main() {\n    B b;\n    return 0;\n}",
    "o": [
      "Compilation error due to unimplemented pure virtual function",
      "Program runs with no output",
      "Runtime error",
      "Code prints 'B'"
    ]
  },
  {
    "q": "What does operator overloading enable in C++?",
    "o": [
      "Custom behavior for operators on user-defined types",
      "Changing precedence of operators",
      "Creating new operators",
      "Overriding standard input/output behavior"
    ]
  },
  {
    "q": "Which of these best describes the use of a virtual function?",
    "o": [
      "Allows a derived class to override a base class method and call it via a base pointer",
      "Allows overloading operators for primitive types",
      "Allows multiple inheritance from abstract classes",
      "Forces all derived classes to implement it"
    ]
  },
  {
    "q": "What is printed by this code?",
    "c": "#include <iostream>\nusing namespace std;\nclass Parent {\npublic:\n    virtual void display() { cout << \"Parent\"; }\n};\nclass Child : public Parent {\npublic:\n    void display() override { cout << \"Child\"; }\n};\nint main() {\n    Parent* p = new Child();\n    p->display();\n    delete p;\n    return 0;\n}",
    "o": [
      "Child",
      "Parent",
      "ParentChild",
      "Compilation error"
    ]
  },
  {
    "q": "How is dynamic dispatch achieved in C++?",
    "o": [
      "Through virtual functions and vtables",
      "Using function templates",
      "By overloading operators",
      "Through function pointers only"
    ]
  },
  {
    "q": "What is the correct output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\nclass Base {\npublic:\n    void greet() { cout << \"Hello from Base\"; }\n    virtual void show() { cout << \"Show Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void greet() { cout << \"Hello from Derived\"; }\n    void show() override { cout << \"Show Derived\"; }\n};\nint main() {\n    Base* ptr = new Derived();\n    ptr->greet();\n    ptr->show();\n    delete ptr;\n    return 0;\n}",
    "o": [
      "Hello from BaseShow Derived",
      "Hello from DerivedShow Derived",
      "Hello from BaseShow Base",
      "Hello from DerivedShow Base"
    ]
  },
  {
    "q": "Which of the following best describes function overloading in C++?",
    "o": [
      "Defining multiple functions with the same name but different parameter types or counts",
      "Redefining a base class function in a derived class",
      "Creating virtual functions with different return types",
      "Using the same function across multiple classes"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    virtual void print() { cout << \"A\"; }\n};\nclass B : public A {\npublic:\n    void print() override { cout << \"B\"; }\n};\nint main() {\n    A* obj = new B();\n    obj->print();\n    return 0;\n}",
    "o": [
      "B",
      "A",
      "AB",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following statements about vtables is correct?",
    "o": [
      "A vtable stores pointers to virtual functions of a class",
      "A vtable is used to allocate memory for objects",
      "A vtable is automatically destroyed after function calls",
      "A vtable contains non-virtual member addresses"
    ]
  },
  {
    "q": "What is the key characteristic of a pure virtual function?",
    "o": [
      "It is declared with = 0 and must be overridden by derived classes",
      "It has a default implementation in the base class",
      "It can only be called from the base class",
      "It is always static"
    ]
  },
  {
    "q": "What happens if a class contains at least one pure virtual function?",
    "o": [
      "It becomes an abstract class",
      "It cannot be inherited",
      "It must define all its members as virtual",
      "It cannot use operator overloading"
    ]
  },
  {
    "q": "Which of the following best describes operator overloading?",
    "o": [
      "Allowing operators to work with user-defined data types",
      "Using virtual functions for operator behavior",
      "Changing operator precedence rules",
      "Using templates to create operator logic"
    ]
  },
  {
    "q": "Which of the following cannot be done with function overloading?",
    "o": [
      "Overloading based on return type only",
      "Overloading based on number of arguments",
      "Overloading based on argument types",
      "Overloading functions with default parameters"
    ]
  },
  {
    "q": "What will this program output?",
    "c": "#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    virtual void foo() { cout << \"A::foo\"; }\n};\nclass B : public A {\npublic:\n    void foo() override { cout << \"B::foo\"; }\n};\nvoid callFoo(A* obj) {\n    obj->foo();\n}\nint main() {\n    B b;\n    callFoo(&b);\n    return 0;\n}",
    "o": [
      "B::foo",
      "A::foo",
      "A::fooB::foo",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is false about virtual functions?",
    "o": [
      "They are resolved at compile time",
      "They enable runtime polymorphism",
      "They are used with base class pointers",
      "They are typically stored in a vtable"
    ]
  },
  {
    "q": "Which concept allows a derived class function to override a base class function using a base class pointer?",
    "o": [
      "Runtime polymorphism",
      "Function overloading",
      "Operator overloading",
      "Template specialization"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "#include <iostream>\nusing namespace std;\nclass X {\npublic:\n    void print(int x) { cout << x; }\n    void print(double d) { cout << d; }\n};\nint main() {\n    X obj;\n    obj.print(3);\n    return 0;\n}",
    "o": [
      "3",
      "3.0",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is a feature of a pure virtual function?",
    "o": [
      "It forces derived classes to provide an implementation",
      "It allows multiple inheritance to work without ambiguity",
      "It cannot be inherited",
      "It executes at compile time"
    ]
  },
  {
    "q": "What is a vptr?",
    "o": [
      "A hidden pointer in an object pointing to the vtable",
      "A pointer used only for static methods",
      "A table that holds object addresses",
      "A pointer returned by operator overloading"
    ]
  },
  {
    "q": "Which of these operators cannot be overloaded in C++?",
    "o": [
      "?:",
      "+",
      "==",
      "[]"
    ]
  },
  {
    "q": "What happens if a virtual function is not overridden in the derived class?",
    "o": [
      "The base class version is invoked at runtime",
      "Compilation error occurs",
      "The object fails to instantiate",
      "The program crashes"
    ]
  },
  {
    "q": "Which of the following best describes function overriding?",
    "o": [
      "Redefining a virtual function in a derived class",
      "Writing multiple functions with the same name and different parameters",
      "Using function templates",
      "Defining static member functions"
    ]
  },
  {
    "q": "What will the following program print?",
    "c": "#include <iostream>\nusing namespace std;\nclass Base {\npublic:\n    virtual void fun() { cout << \"Base::fun\"; }\n};\nclass Derived : public Base {\n};\nint main() {\n    Base* b = new Derived();\n    b->fun();\n    delete b;\n    return 0;\n}",
    "o": [
      "Base::fun",
      "Derived::fun",
      "fun",
      "Compilation error"
    ]
  },
  {
    "q": "Why is virtual function dispatch slower than normal function calls?",
    "o": [
      "Because it requires an extra level of indirection via vtable",
      "Because it always throws an exception internally",
      "Because virtual functions are stored in heap memory",
      "Because compiler does not optimize them"
    ]
  },
  {
    "q": "Which class type cannot be instantiated directly?",
    "o": [
      "Abstract class",
      "Concrete class",
      "Base class with constructor",
      "Template class"
    ]
  },
  {
    "q": "Which mechanism in C++ allows a function to behave differently based on the object type it's called through?",
    "o": [
      "Virtual functions",
      "Function overloading",
      "Inline functions",
      "Macros"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    void operator++() { cout << \"Incremented\"; }\n};\nint main() {\n    A obj;\n    ++obj;\n    return 0;\n}",
    "o": [
      "Incremented",
      "Compilation error",
      "++",
      "Runtime error"
    ]
  },
  {
    "q": "Which of these is a valid reason to use operator overloading?",
    "o": [
      "To provide intuitive operations for user-defined types",
      "To reduce memory consumption",
      "To increase compile-time performance",
      "To allow multiple return types from a function"
    ]
  },
  {
    "q": "Which of the following statements is true about vtables?",
    "o": [
      "Each class with virtual functions has its own vtable",
      "Only derived classes have vtables",
      "Vtables are stored on the stack",
      "Vtables are user-defined"
    ]
  },
  {
    "q": "Why must a pure virtual function be defined with `= 0` syntax?",
    "o": [
      "To indicate it has no implementation in the base class",
      "To avoid name conflicts",
      "To improve compile-time efficiency",
      "To automatically inline the function"
    ]
  },
  {
    "q": "What is the result of calling a non-virtual function using a base class pointer to a derived object?",
    "o": [
      "The base class version of the function is called",
      "The derived class version is always called",
      "It leads to runtime error",
      "It calls both base and derived versions"
    ]
  },
  {
    "q": "What is printed by this code?",
    "c": "#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    virtual void fun() = 0;\n};\nclass B : public A {\npublic:\n    void fun() { cout << \"B::fun\"; }\n};\nint main() {\n    B b;\n    b.fun();\n    return 0;\n}",
    "o": [
      "B::fun",
      "A::fun",
      "fun",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is required to support runtime polymorphism?",
    "o": [
      "A base class with virtual functions",
      "Function overloading",
      "An abstract base class only",
      "Friend functions"
    ]
  },
  {
    "q": "Which of the following best describes compile-time polymorphism?",
    "o": [
      "Function and operator overloading resolved at compile time",
      "Virtual functions resolved at runtime",
      "Overriding methods in derived classes",
      "Dynamic memory allocation"
    ]
  },
  {
    "q": "In which scenario will vptr be re-initialized?",
    "o": [
      "When an object of a derived class is created",
      "When a non-virtual function is called",
      "When an inline function is executed",
      "When a constructor throws an exception"
    ]
  },
  {
    "q": "Which of the following code snippets demonstrates function overloading?",
    "c": "class Demo {\npublic:\n    void print(int x) {}\n    void print(double y) {}\n};",
    "o": [
      "This is function overloading as both functions have the same name with different parameter types",
      "This is operator overloading as both functions are similar",
      "This demonstrates runtime polymorphism",
      "This is not valid C++ syntax"
    ]
  },
  {
    "q": "What will be the output of the following program?",
    "c": "#include <iostream>\nusing namespace std;\nclass Base {\npublic:\n    virtual void display() { cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void display() { cout << \"Derived\"; }\n};\nint main() {\n    Base* ptr = new Derived();\n    ptr->display();\n    return 0;\n}",
    "o": [
      "Derived",
      "Base",
      "Compilation error",
      "Undefined behavior"
    ]
  },
  {
    "q": "Which of the following is true about operator overloading in C++?",
    "o": [
      "It allows user-defined types to behave like built-in types",
      "It changes the syntax of operators",
      "It alters the memory model of objects",
      "It disables virtual function usage"
    ]
  },
  {
    "q": "Which condition must be met for runtime polymorphism to work?",
    "o": [
      "The base class function must be declared as virtual",
      "The base class must be abstract",
      "The derived class must be templated",
      "The base class must overload the operator"
    ]
  },
  {
    "q": "Which of the following is true about pure virtual functions?",
    "o": [
      "They do not have a body and must be overridden in derived classes",
      "They can only be private",
      "They cannot be part of an interface",
      "They are defined using the `virtual` keyword only"
    ]
  },
  {
    "q": "What is the primary role of a vtable in C++?",
    "o": [
      "To support dynamic dispatch of virtual functions",
      "To manage template instantiations",
      "To link overloaded operators",
      "To handle static memory allocation"
    ]
  },
  {
    "q": "Which statement correctly describes the behavior of this code?",
    "c": "#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    virtual void fun() = 0;\n};\nclass B : public A {};\nint main() {\n    B b;\n    return 0;\n}",
    "o": [
      "Compilation error: B does not implement the pure virtual function",
      "Program runs fine and does nothing",
      "The base class function is executed",
      "Linker error occurs due to multiple definitions"
    ]
  },
  {
    "q": "Which of the following best defines dynamic binding?",
    "o": [
      "Decision of function call is made at runtime",
      "Functions are compiled inline for efficiency",
      "Object constructors are linked statically",
      "Operators are overloaded for user-defined types"
    ]
  },
  {
    "q": "Which type of polymorphism is achieved by function templates?",
    "o": [
      "Compile-time polymorphism",
      "Runtime polymorphism",
      "Hybrid polymorphism",
      "Late binding polymorphism"
    ]
  },
  {
    "q": "What happens if a class inherits from a class with a pure virtual function but doesn’t override it?",
    "o": [
      "The derived class also becomes abstract",
      "The derived class becomes invalid",
      "The program runs normally",
      "The compiler ignores the base class function"
    ]
  },
  {
    "q": "Which of the following best defines function overloading?",
    "o": [
      "Multiple functions with the same name but different parameter lists",
      "One function redefined in the derived class",
      "A virtual function with multiple return types",
      "A function defined as static in a class"
    ]
  },
  {
    "q": "What is the result of compiling this code?",
    "c": "#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    virtual void show() = 0;\n};\nclass B : public A {\npublic:\n    void show() {}\n};\nint main() {\n    B b;\n    b.show();\n    return 0;\n}",
    "o": [
      "Successful compilation and no output",
      "Compilation error due to pure virtual function",
      "Runtime error",
      "Undefined behavior"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "#include <iostream>\nusing namespace std;\nclass Base {\npublic:\n    void show() { cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void show() { cout << \"Derived\"; }\n};\nint main() {\n    Base* b = new Derived();\n    b->show();\n    return 0;\n}",
    "o": [
      "Base",
      "Derived",
      "Compilation error",
      "Runtime error"
    ]
  },
  {
    "q": "Which type of polymorphism is resolved at compile time?",
    "o": [
      "Function overloading",
      "Virtual function overriding",
      "Abstract class instantiation",
      "Dynamic dispatch"
    ]
  },
  {
    "q": "Which part of a C++ object points to its vtable?",
    "o": [
      "vptr",
      "vtable",
      "this pointer",
      "heap pointer"
    ]
  },
  {
    "q": "Which of these will **not** cause polymorphic behavior?",
    "o": [
      "Calling a non-virtual function via a base class pointer",
      "Calling a virtual function using a base class pointer",
      "Overriding a base class virtual method",
      "Using abstract base class references"
    ]
  },
  {
    "q": "What happens if a class contains at least one pure virtual function?",
    "o": [
      "It becomes an abstract class",
      "It must be a derived class",
      "It cannot be inherited",
      "It must have a default constructor"
    ]
  },
  {
    "q": "Which of the following operators can be overloaded?",
    "o": [
      "+",
      "?:",
      "::",
      "sizeof"
    ]
  },
  {
    "q": "Which keyword is essential for runtime polymorphism to work properly?",
    "o": [
      "virtual",
      "override",
      "explicit",
      "static"
    ]
  },
  {
    "q": "Which of the following correctly describes a vtable?",
    "o": [
      "A table of function pointers for virtual functions",
      "A stack of overridden constructors",
      "A reference to static class members",
      "A heap memory tracker for templates"
    ]
  },
  {
    "q": "Which operator cannot be overloaded in C++?",
    "o": [
      "sizeof",
      "+",
      "==",
      "[]"
    ]
  },
  {
    "q": "What does the following code demonstrate?",
    "c": "class A {\npublic:\n    void show() {}\n    void show(int x) {}\n};",
    "o": [
      "Function overloading",
      "Function overriding",
      "Runtime polymorphism",
      "Virtual function behavior"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    virtual void print() { cout << \"A\"; }\n};\nclass B : public A {\npublic:\n    void print() override { cout << \"B\"; }\n};\nint main() {\n    A* a = new B();\n    a->print();\n    return 0;\n}",
    "o": [
      "B",
      "A",
      "Compilation error",
      "Segmentation fault"
    ]
  },
  {
    "q": "What is a requirement for a class to be considered abstract in C++?",
    "o": [
      "It must have at least one pure virtual function",
      "It must inherit from another class",
      "It must define all virtual functions",
      "It must be declared using the abstract keyword"
    ]
  },
  {
    "q": "What ensures late binding of function calls in C++?",
    "o": [
      "Virtual functions",
      "Inline functions",
      "Static functions",
      "Function overloading"
    ]
  },
  {
    "q": "Which of the following best defines an abstract class?",
    "o": [
      "A class with at least one pure virtual function",
      "A class that only has private members",
      "A class that cannot be inherited",
      "A class with multiple constructors"
    ]
  },
  {
    "q": "Which of the following statements about vtables is TRUE?",
    "o": [
      "They are used to support dynamic dispatch in classes with virtual functions",
      "They are generated only if the class is abstract",
      "They store function templates for all class methods",
      "They are only used for overloaded operators"
    ]
  },
  {
    "q": "What is printed by the following code?",
    "c": "#include <iostream>\nusing namespace std;\nclass Base {\npublic:\n    virtual void f() { cout << \"Base\"; }\n};\nclass Derived : public Base {};\nint main() {\n    Derived d;\n    d.f();\n    return 0;\n}",
    "o": [
      "Base",
      "Derived",
      "No output",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following allows an object to behave differently based on its actual type at runtime?",
    "o": [
      "Virtual function mechanism",
      "Operator overloading",
      "Function overloading",
      "Template specialization"
    ]
  },
  {
    "q": "What happens if you try to instantiate an abstract class directly?",
    "o": [
      "Compilation error",
      "Undefined behavior",
      "Linker error",
      "Program runs but skips constructor"
    ]
  },
  {
    "q": "Which of the following is NOT a form of compile-time polymorphism in C++?",
    "o": [
      "Virtual functions",
      "Function overloading",
      "Operator overloading",
      "Templates"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    virtual void show() { cout << \"A\"; }\n};\nclass B : public A {\npublic:\n    void show() { cout << \"B\"; }\n};\nint main() {\n    A a, *p;\n    B b;\n    p = &b;\n    a.show();\n    p->show();\n    return 0;\n}",
    "o": [
      "AB",
      "BA",
      "AA",
      "BB"
    ]
  },
  {
    "q": "Which of the following best describes a pure virtual function?",
    "o": [
      "A virtual function with no implementation in the base class",
      "A virtual function that cannot be overridden",
      "A static function declared as virtual",
      "A function with multiple overloads"
    ]
  },
  {
    "q": "Which operator can be overloaded to work with custom object comparisons?",
    "o": [
      "==",
      "?:",
      "sizeof",
      "new[]"
    ]
  },
  {
    "q": "What ensures dynamic dispatch of a virtual function call in C++?",
    "o": [
      "The vtable and vptr mechanism",
      "The inline keyword",
      "The static keyword",
      "The use of templates"
    ]
  },
  {
    "q": "Which of the following statements about function overloading is true?",
    "o": [
      "It enables multiple functions with the same name but different signatures",
      "It replaces virtual functions",
      "It always requires inheritance",
      "It is resolved during runtime"
    ]
  },
  {
    "q": "What is the role of the vptr in polymorphism?",
    "o": [
      "It points to the virtual function table of a class",
      "It holds the address of base class functions",
      "It stores overridden non-virtual functions",
      "It prevents object slicing"
    ]
  },
  {
    "q": "What happens when a virtual function is not overridden in the derived class?",
    "o": [
      "The base class version is called",
      "Compilation error occurs",
      "Undefined behavior results",
      "Program does not compile unless marked abstract"
    ]
  },
  {
    "q": "What is the primary reason for using abstract classes in C++?",
    "o": [
      "To define an interface that must be implemented by derived classes",
      "To prevent object instantiation",
      "To overload operators more efficiently",
      "To allow only static function calls"
    ]
  },
  {
    "q": "What will this code do?",
    "c": "class Shape {\npublic:\n    virtual void draw() = 0;\n};\nclass Circle : public Shape {\n    void draw() override {}\n};\nint main() {\n    Shape* s = new Circle();\n    s->draw();\n    return 0;\n}",
    "o": [
      "It compiles and runs successfully",
      "It results in a linker error",
      "It causes a runtime error",
      "It throws a segmentation fault"
    ]
  },
  {
    "q": "Which of the following is an example of runtime polymorphism?",
    "o": [
      "Overriding a virtual function in a derived class",
      "Overloading the `+` operator",
      "Using a default argument in a function",
      "Function templates"
    ]
  },
  {
    "q": "What does the following code demonstrate?",
    "c": "class Math {\npublic:\n    int add(int a, int b) { return a + b; }\n    double add(double a, double b) { return a + b; }\n};",
    "o": [
      "Function overloading",
      "Function overriding",
      "Operator overloading",
      "Virtual function call"
    ]
  },
  {
    "q": "Which of these keywords is essential to enable runtime polymorphism in C++?",
    "o": [
      "virtual",
      "inline",
      "typedef",
      "template"
    ]
  },
  {
    "q": "What will happen when an abstract class object is created directly?",
    "o": [
      "Compilation error",
      "Link-time error",
      "Program compiles but throws runtime exception",
      "Undefined behavior"
    ]
  },
  {
    "q": "What is the purpose of a vtable?",
    "o": [
      "To map virtual functions to their actual addresses at runtime",
      "To track memory allocations of objects",
      "To resolve overloaded functions at compile time",
      "To store operator overloads"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    virtual void display() { cout << \"A\"; }\n};\nclass B : public A {\npublic:\n    void display() override { cout << \"B\"; }\n};\nint main() {\n    A* obj = new B();\n    obj->display();\n    return 0;\n}",
    "o": [
      "B",
      "A",
      "Compilation error",
      "Segmentation fault"
    ]
  },
  {
    "q": "What does operator overloading allow in C++?",
    "o": [
      "Redefining the behavior of operators for user-defined types",
      "Changing built-in operator behavior globally",
      "Creating new operators",
      "Overriding a function in base class"
    ]
  },
  {
    "q": "What happens if a class overrides a virtual function incorrectly (e.g., wrong signature)?",
    "o": [
      "The base class version gets called",
      "Compiler throws an error",
      "Linker error occurs",
      "Virtual table is not generated"
    ]
  },
  {
    "q": "What will this code do?",
    "c": "class A {\npublic:\n    virtual void foo() = 0;\n};\nclass B : public A {\npublic:\n    void foo() {} // Implementation\n};\nint main() {\n    A* ptr = new B();\n    ptr->foo();\n    return 0;\n}",
    "o": [
      "It compiles and runs successfully",
      "It fails at compile time",
      "It throws an exception",
      "It results in segmentation fault"
    ]
  },
  {
    "q": "Which of these allows invoking the appropriate function based on the actual object type at runtime?",
    "o": [
      "Virtual function dispatch",
      "Function overloading",
      "Namespace resolution",
      "Template instantiation"
    ]
  },
  {
    "q": "Which of the following resolves at compile time?",
    "o": [
      "Function overloading",
      "Virtual function overriding",
      "Virtual table lookup",
      "Pure virtual function call"
    ]
  },
  {
    "q": "What will be the output of the following program?",
    "c": "#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    void show() { cout << \"A\"; }\n};\nclass B : public A {\npublic:\n    void show() { cout << \"B\"; }\n};\nint main() {\n    A* ptr = new B();\n    ptr->show();\n    return 0;\n}",
    "o": [
      "A",
      "B",
      "AB",
      "Compilation Error"
    ]
  },
  {
    "q": "Which of the following is true about virtual functions in C++?",
    "o": [
      "They support runtime polymorphism",
      "They can only be defined in abstract classes",
      "They are always pure virtual by default",
      "They cannot be inherited"
    ]
  },
  {
    "q": "Which statement about operator overloading is correct?",
    "o": [
      "You can overload the '<<' operator for custom output of objects",
      "You cannot overload arithmetic operators",
      "Operator overloading changes the precedence of operators",
      "The sizeof operator can be overloaded"
    ]
  },
  {
    "q": "What is true about a class that contains at least one pure virtual function?",
    "o": [
      "It is considered an abstract class",
      "It must be marked with the keyword `abstract`",
      "It cannot have any data members",
      "It must not be inherited"
    ]
  },
  {
    "q": "What does the vtable mechanism ensure?",
    "o": [
      "Correct virtual function call based on the actual object type",
      "Faster execution of overloaded functions",
      "Inline expansion of functions",
      "Compile-time memory allocation"
    ]
  },
  {
    "q": "Which of the following features enables different behavior based on the object type during runtime?",
    "o": [
      "Dynamic dispatch",
      "Function templates",
      "Function overloading",
      "Constructor overloading"
    ]
  },
  {
    "q": "How is a pure virtual function declared in C++?",
    "o": [
      "virtual void func() = 0;",
      "pure virtual void func();",
      "virtual void func(); = null",
      "abstract void func();"
    ]
  },
  {
    "q": "What is printed by this code?",
    "c": "#include <iostream>\nusing namespace std;\nclass Base {\npublic:\n    virtual void speak() { cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void speak() override { cout << \"Derived\"; }\n};\nint main() {\n    Base b;\n    Derived d;\n    Base* ptr = &d;\n    ptr->speak();\n    return 0;\n}",
    "o": [
      "Derived",
      "Base",
      "BaseDerived",
      "Compilation Error"
    ]
  },
  {
    "q": "Which of the following is FALSE about function overriding?",
    "o": [
      "It is resolved at compile time",
      "It requires a base and a derived class",
      "It uses virtual functions",
      "It allows a derived class to replace a base class method"
    ]
  },
  {
    "q": "Which of the following best describes compile-time polymorphism in C++?",
    "o": [
      "It is achieved through function overloading and operator overloading.",
      "It is achieved using virtual functions.",
      "It requires abstract base classes.",
      "It is implemented using vtables."
    ]
  },
  {
    "q": "What will be the output of the following C++ code?",
    "c": "#include <iostream>\nusing namespace std;\n\nvoid print(int a) {\n    cout << \"Integer: \" << a << endl;\n}\n\nvoid print(double b) {\n    cout << \"Double: \" << b << endl;\n}\n\nint main() {\n    print(5);\n    return 0;\n}",
    "o": [
      "Integer: 5",
      "Double: 5",
      "Error: Ambiguous function call",
      "5"
    ]
  },
  {
    "q": "Which of the following demonstrates operator overloading in C++?",
    "c": "class Complex {\npublic:\n    int real, imag;\n    Complex(int r, int i) : real(r), imag(i) {}\n    Complex operator + (const Complex& obj) {\n        return Complex(real + obj.real, imag + obj.imag);\n    }\n};",
    "o": [
      "The '+' operator is overloaded for Complex numbers.",
      "It is an example of function overriding.",
      "This code shows runtime polymorphism.",
      "The '*' operator is overloaded."
    ]
  },
  {
    "q": "Which keyword is used to achieve runtime polymorphism in C++?",
    "o": [
      "virtual",
      "override",
      "inline",
      "static"
    ]
  },
  {
    "q": "What is the output of the following code demonstrating runtime polymorphism?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    virtual void show() { cout << \"Base class\" << endl; }\n};\n\nclass Derived : public Base {\npublic:\n    void show() override { cout << \"Derived class\" << endl; }\n};\n\nint main() {\n    Base* b = new Derived();\n    b->show();\n    return 0;\n}",
    "o": [
      "Derived class",
      "Base class",
      "Error: virtual function cannot be overridden",
      "No output"
    ]
  },
  {
    "q": "Which of the following statements about vtable and vptr is true?",
    "o": [
      "vtable is a mechanism used to implement virtual functions in C++.",
      "vptr is created manually by the programmer.",
      "Each object of a class has a separate vtable.",
      "vtable is used for function overloading."
    ]
  },
  {
    "q": "Which of the following makes a class abstract in C++?",
    "o": [
      "Having at least one pure virtual function.",
      "Inheriting from a base class.",
      "Using virtual destructors.",
      "Overloading operators."
    ]
  },
  {
    "q": "What does the following C++ code demonstrate?",
    "c": "class Shape {\npublic:\n    virtual void draw() = 0;\n};\n\nclass Circle : public Shape {\npublic:\n    void draw() override {\n        cout << \"Drawing Circle\" << endl;\n    }\n};",
    "o": [
      "Use of a pure virtual function and an abstract class.",
      "Compile-time polymorphism using function overloading.",
      "Operator overloading example.",
      "Static binding example."
    ]
  },
  {
    "q": "Which of the following is NOT true about virtual functions in C++?",
    "o": [
      "They can be static functions.",
      "They allow runtime polymorphism.",
      "They are declared using the 'virtual' keyword.",
      "They can be overridden in derived classes."
    ]
  },
  {
    "q": "What is the term for calling the correct overridden function at runtime using a base class pointer?",
    "o": [
      "Dynamic binding",
      "Static binding",
      "Function hiding",
      "Template instantiation"
    ]
  },
  {
    "q": "What is function overloading in C++?",
    "o": [
      "Defining multiple functions with the same name but different parameters.",
      "Redefining a function in a derived class.",
      "Using a function inside another function.",
      "Calling multiple functions from one function."
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nvoid display(int a) {\n    cout << \"Integer: \" << a << endl;\n}\n\nvoid display(char c) {\n    cout << \"Character: \" << c << endl;\n}\n\nint main() {\n    display('A');\n    return 0;\n}",
    "o": [
      "Character: A",
      "Integer: 65",
      "Error: ambiguous call to display",
      "Display: A"
    ]
  },
  {
    "q": "Which of the following best describes operator overloading?",
    "o": [
      "Changing the behavior of an operator for user-defined types.",
      "Calling operators within a class only.",
      "Replacing all operators globally.",
      "Assigning new precedence to operators."
    ]
  },
  {
    "q": "What will be the output of the following code using virtual functions?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Animal {\npublic:\n    virtual void speak() { cout << \"Animal sound\" << endl; }\n};\n\nclass Dog : public Animal {\npublic:\n    void speak() override { cout << \"Bark\" << endl; }\n};\n\nint main() {\n    Animal* a = new Dog();\n    a->speak();\n    return 0;\n}",
    "o": [
      "Bark",
      "Animal sound",
      "Dog sound",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is true about vptr in C++?",
    "o": [
      "It is a hidden pointer maintained by the compiler to support virtual function calls.",
      "It is a pointer manually created by the user.",
      "It is used only in static functions.",
      "It is part of the standard library."
    ]
  },
  {
    "q": "What does the following code represent?",
    "c": "class Interface {\npublic:\n    virtual void execute() = 0;\n};",
    "o": [
      "A pure virtual function making Interface an abstract class.",
      "A default implementation of execute().",
      "A virtual destructor.",
      "A static member function."
    ]
  },
  {
    "q": "When is the decision made to bind a virtual function call to the appropriate function implementation?",
    "o": [
      "At runtime, using dynamic binding.",
      "At compile-time, using static binding.",
      "During linking.",
      "When the object is created."
    ]
  },
  {
    "q": "Which statement is true regarding abstract classes in C++?",
    "o": [
      "They cannot be instantiated directly.",
      "They must have at least two virtual functions.",
      "They can only be used as interfaces.",
      "They cannot be inherited."
    ]
  },
  {
    "q": "What is a vtable in C++?",
    "o": [
      "A lookup table used to resolve virtual function calls at runtime.",
      "A static memory table for overloaded functions.",
      "A compiler-defined class constructor table.",
      "A special object for pointer arithmetic."
    ]
  },
  {
    "q": "Which of the following code snippets shows function overloading?",
    "c": "class Math {\npublic:\n    int add(int a, int b) { return a + b; }\n    double add(double a, double b) { return a + b; }\n};",
    "o": [
      "Two functions with the same name but different parameters.",
      "A function overridden in a derived class.",
      "Use of templates instead of overloading.",
      "An error due to duplicate function names."
    ]
  },
  {
    "q": "Which of the following is an example of compile-time polymorphism in C++?",
    "o": [
      "Function overloading",
      "Virtual function",
      "Abstract class",
      "Dynamic_cast"
    ]
  },
  {
    "q": "What is the output of this operator overloading example?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Point {\npublic:\n    int x;\n    Point(int val) : x(val) {}\n    Point operator++() {\n        ++x;\n        return *this;\n    }\n};\n\nint main() {\n    Point p(3);\n    ++p;\n    cout << p.x;\n    return 0;\n}",
    "o": [
      "4",
      "3",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "What is required for runtime polymorphism to work correctly in C++?",
    "o": [
      "A base class pointer or reference calling a virtual function",
      "Overloaded operators in the base class",
      "Multiple constructors in a class",
      "An inline static function"
    ]
  },
  {
    "q": "Which of these causes a class to be abstract in C++?",
    "o": [
      "Declaring at least one pure virtual function",
      "Having a virtual destructor",
      "Using friend functions",
      "Declaring the class with 'abstract' keyword"
    ]
  },
  {
    "q": "What will this code print using function overloading?",
    "c": "#include <iostream>\nusing namespace std;\n\nvoid show(string msg) {\n    cout << \"Message: \" << msg << endl;\n}\n\nvoid show(int count) {\n    cout << \"Count: \" << count << endl;\n}\n\nint main() {\n    show(10);\n    return 0;\n}",
    "o": [
      "Count: 10",
      "Message: 10",
      "10",
      "Error"
    ]
  },
  {
    "q": "Which concept uses a virtual table (vtable) in C++?",
    "o": [
      "Runtime polymorphism",
      "Compile-time polymorphism",
      "Friend functions",
      "Static binding"
    ]
  },
  {
    "q": "How does C++ internally implement virtual function calls?",
    "o": [
      "Through vtable and vptr mechanism",
      "Using preprocessor macros",
      "Through multiple inheritance only",
      "By overloading all functions"
    ]
  },
  {
    "q": "What does the following code demonstrate?",
    "c": "class A {\npublic:\n    virtual void greet() = 0;\n};\n\nclass B : public A {\npublic:\n    void greet() override {\n        cout << \"Hello from B\" << endl;\n    }\n};",
    "o": [
      "Pure virtual function implemented in derived class",
      "Function overloading",
      "Static binding of method",
      "Operator overloading"
    ]
  },
  {
    "q": "Which of the following is a feature of function overloading?",
    "o": [
      "Same function name, different parameter lists",
      "Same function name, same parameter list",
      "Same function body reused in all overloads",
      "Must always return void"
    ]
  },
  {
    "q": "What happens if a class has a pure virtual function but no definition for it?",
    "o": [
      "It becomes an abstract class and cannot be instantiated.",
      "It causes a compilation warning.",
      "It creates a runtime error.",
      "The compiler generates a default implementation."
    ]
  },
  {
    "q": "Which of the following is an example of operator overloading in C++?",
    "c": "class Complex {\npublic:\n    int real, imag;\n    Complex(int r, int i): real(r), imag(i) {}\n    Complex operator+(const Complex& c) {\n        return Complex(real + c.real, imag + c.imag);\n    }\n};",
    "o": [
      "Overloading the '+' operator to add two Complex objects.",
      "Using the '+' operator for primitive types.",
      "Overloading function parameters.",
      "Modifying a constructor."
    ]
  },
  {
    "q": "Which keyword is used to support runtime polymorphism in C++?",
    "o": [
      "virtual",
      "static",
      "const",
      "inline"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    virtual void show() { cout << \"Base class\" << endl; }\n};\n\nclass Derived : public Base {\npublic:\n    void show() override { cout << \"Derived class\" << endl; }\n};\n\nint main() {\n    Base* ptr = new Derived();\n    ptr->show();\n    return 0;\n}",
    "o": [
      "Derived class",
      "Base class",
      "Compilation error",
      "Runtime error"
    ]
  },
  {
    "q": "Which statement about vtables is TRUE?",
    "o": [
      "A vtable stores addresses of virtual functions of a class.",
      "A vtable is part of the user-defined class layout.",
      "A vtable is defined explicitly by the programmer.",
      "A vtable is required for function overloading."
    ]
  },
  {
    "q": "Why can't you instantiate a class with a pure virtual function?",
    "o": [
      "Because it's an abstract class and doesn't provide complete implementation.",
      "Because it has private constructors.",
      "Because it has too many functions.",
      "Because it uses friend functions."
    ]
  },
  {
    "q": "How does C++ determine which overloaded function to call?",
    "o": [
      "Based on the number and type of arguments at compile time.",
      "Using the vtable at runtime.",
      "Using dynamic casting.",
      "By checking inheritance hierarchy."
    ]
  },
  {
    "q": "What happens if a derived class does not override a pure virtual function?",
    "o": [
      "The derived class also becomes abstract.",
      "The base class becomes non-abstract.",
      "The program crashes at runtime.",
      "The derived class will automatically generate the function."
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n    void display() { cout << \"A\"; }\n};\n\nclass B : public A {\npublic:\n    void display(int x) { cout << \"B\"; }\n};\n\nint main() {\n    B obj;\n    obj.display();\n    return 0;\n}",
    "o": [
      "A",
      "B",
      "Compilation error",
      "AB"
    ]
  },
  {
    "q": "What is a vptr in the context of runtime polymorphism?",
    "o": [
      "A hidden pointer to the vtable maintained per object by the compiler.",
      "A static pointer that never changes.",
      "A pointer to an abstract function.",
      "A user-defined pointer to class functions."
    ]
  },
  {
    "q": "Which one of the following enables polymorphic behavior at runtime?",
    "o": [
      "Base class pointer or reference pointing to derived class object",
      "Function templates",
      "Static member functions",
      "Inline functions"
    ]
  },
  {
    "q": "Which concept allows using the same function name with different parameter types in C++?",
    "o": [
      "Function overloading",
      "Virtual functions",
      "Templates",
      "Inheritance"
    ]
  },
  {
    "q": "What does the following code demonstrate?",
    "c": "class Demo {\npublic:\n    void show() { cout << \"Show without param\" << endl; }\n    void show(int x) { cout << \"Show with int\" << endl; }\n};",
    "o": [
      "Function overloading",
      "Virtual function",
      "Constructor overloading",
      "Operator overloading"
    ]
  },
  {
    "q": "Which of the following supports dynamic dispatch in C++?",
    "o": [
      "Virtual function",
      "Inline function",
      "Function overloading",
      "Static method"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n    virtual void print() { cout << \"A\"; }\n};\n\nclass B : public A {\npublic:\n    void print() override { cout << \"B\"; }\n};\n\nint main() {\n    A* a = new B();\n    a->print();\n    return 0;\n}",
    "o": [
      "B",
      "A",
      "AB",
      "Compilation Error"
    ]
  },
  {
    "q": "Which one of the following statements about pure virtual functions is correct?",
    "o": [
      "They must be overridden in derived classes to create concrete objects.",
      "They can be defined in the same class.",
      "They are evaluated at compile time.",
      "They don’t participate in runtime polymorphism."
    ]
  },
  {
    "q": "Which of the following best describes a vtable?",
    "o": [
      "A table of function pointers for virtual functions.",
      "A container for overloaded functions.",
      "A type of abstract class.",
      "A stack structure for runtime memory."
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    virtual void func() = 0;\n};\n\nclass Derived : public Base {\npublic:\n    void func() { cout << \"Derived Function\"; }\n};\n\nint main() {\n    Derived d;\n    d.func();\n    return 0;\n}",
    "o": [
      "Derived Function",
      "Base Function",
      "Compilation Error",
      "Runtime Error"
    ]
  },
  {
    "q": "Which condition must be met for function overriding to occur in C++?",
    "o": [
      "The function must be virtual in the base class and redefined in the derived class.",
      "The function names must be different.",
      "Functions must have different return types.",
      "The function must be static."
    ]
  },
  {
    "q": "What does operator overloading allow in C++?",
    "o": [
      "Custom behavior for operators with user-defined types.",
      "Runtime selection of operators.",
      "Creating new operators.",
      "Overloading keywords like `if` or `while`."
    ]
  },
  {
    "q": "Why does C++ use both vptr and vtable for virtual function calls?",
    "o": [
      "vptr points to vtable, which stores addresses of virtual functions enabling dynamic dispatch.",
      "They are used for compile-time dispatch.",
      "They are required for static functions.",
      "vtable handles function overloading only."
    ]
  },
  {
    "q": "Which of the following allows multiple functions with the same name but different signatures?",
    "o": [
      "Function overloading",
      "Function overriding",
      "Virtual functions",
      "Templates"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "class Print {\npublic:\n    void display() { cout << \"Display 1\"; }\n    void display(string s) { cout << \"Display 2\"; }\n};\n\nint main() {\n    Print obj;\n    obj.display(\"Hello\");\n    return 0;\n}",
    "o": [
      "Display 2",
      "Display 1",
      "Compilation Error",
      "Hello"
    ]
  },
  {
    "q": "What mechanism allows calling derived class functions using base class pointers?",
    "o": [
      "Virtual functions and runtime polymorphism",
      "Function overloading",
      "Templates",
      "Inline functions"
    ]
  },
  {
    "q": "Which of the following statements about vtables is correct?",
    "o": [
      "Each class with virtual functions has its own vtable.",
      "Only base classes have vtables.",
      "vtables are managed manually by the programmer.",
      "vtable is shared across all classes."
    ]
  },
  {
    "q": "Identify the concept in the code below.",
    "c": "class Number {\npublic:\n    Number operator*(const Number& other) {\n        return Number();\n    }\n};",
    "o": [
      "Operator overloading",
      "Function overriding",
      "Pure virtual function",
      "Abstract class"
    ]
  },
  {
    "q": "Which of the following best describes a pure virtual function?",
    "o": [
      "A function declared with '= 0' and no implementation in base class.",
      "A function defined in both base and derived classes.",
      "An overloaded function.",
      "A function with default parameters."
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "#include<iostream>\nusing namespace std;\n\nclass Animal {\npublic:\n    virtual void sound() { cout << \"Animal Sound\"; }\n};\n\nclass Dog : public Animal {\npublic:\n    void sound() override { cout << \"Bark\"; }\n};\n\nint main() {\n    Animal* a = new Dog();\n    a->sound();\n    return 0;\n}",
    "o": [
      "Bark",
      "Animal Sound",
      "Dog Sound",
      "Compilation Error"
    ]
  },
  {
    "q": "What happens if you do not override a pure virtual function in a derived class?",
    "o": [
      "The derived class also becomes abstract.",
      "The function becomes virtual.",
      "It leads to infinite recursion.",
      "The compiler converts it into inline function."
    ]
  },
  {
    "q": "Which of the following is true about function overriding?",
    "o": [
      "It requires inheritance and virtual functions.",
      "It requires operator overloading.",
      "It occurs only with constructors.",
      "It happens at compile time."
    ]
  },
  {
    "q": "In C++, which pointer is internally added to objects with virtual functions to support dynamic dispatch?",
    "o": [
      "vptr",
      "this",
      "vtable",
      "objptr"
    ]
  },
  {
    "q": "Which of the following features is not part of compile-time polymorphism?",
    "o": [
      "Virtual functions",
      "Function overloading",
      "Operator overloading",
      "Default arguments"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    void show() { cout << \"A::show()\\n\"; }\n};\nclass B : public A {\npublic:\n    void show(int x) { cout << \"B::show(int)\\n\"; }\n};\nint main() {\n    B b;\n    b.show(5);\n    return 0;\n}",
    "o": [
      "B::show(int)",
      "A::show()",
      "Compilation Error",
      "B::show()"
    ]
  },
  {
    "q": "Which statement about virtual functions is true?",
    "o": [
      "They support runtime polymorphism through base class pointers.",
      "They can only be used with friend functions.",
      "They are evaluated at compile-time.",
      "They must always be overridden in derived classes."
    ]
  },
  {
    "q": "What does a vtable contain?",
    "o": [
      "Function pointers to virtual functions of a class",
      "Variable names used in a class",
      "Memory addresses of class objects",
      "Data types used in operator overloading"
    ]
  },
  {
    "q": "What is required to make a class abstract in C++?",
    "o": [
      "At least one pure virtual function",
      "All functions should be private",
      "All functions must be virtual",
      "Overloaded operators must be used"
    ]
  },
  {
    "q": "What is the output of the code below?",
    "c": "class Shape {\npublic:\n    virtual void draw() = 0;\n};\nclass Circle : public Shape {\npublic:\n    void draw() override { cout << \"Drawing Circle\"; }\n};\nint main() {\n    Circle c;\n    c.draw();\n    return 0;\n}",
    "o": [
      "Drawing Circle",
      "Drawing Shape",
      "Compilation Error",
      "Runtime Error"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "class A {\npublic:\n    virtual void fun() { cout << \"A\"; }\n};\nclass B : public A {\npublic:\n    void fun() override { cout << \"B\"; }\n};\nvoid call(A* obj) { obj->fun(); }\nint main() {\n    B b;\n    call(&b);\n    return 0;\n}",
    "o": [
      "B",
      "A",
      "AB",
      "Compilation Error"
    ]
  },
  {
    "q": "Which of the following allows the '+' operator to be redefined for user-defined classes?",
    "o": [
      "Operator overloading",
      "Function overloading",
      "Virtual functions",
      "Inheritance"
    ]
  },
  {
    "q": "What will happen if a class inherits from a class with a pure virtual function but does not override it?",
    "o": [
      "It becomes an abstract class.",
      "It throws a runtime error.",
      "It overrides the function implicitly.",
      "It calls the base class function automatically."
    ]
  },
  {
    "q": "Which of the following correctly creates a virtual function in C++?",
    "o": [
      "virtual void speak();",
      "void virtual speak();",
      "virtual function speak();",
      "virtual speak();"
    ]
  },
  {
    "q": "Which C++ feature enables the use of the same function name with different parameter types?",
    "o": [
      "Function overloading",
      "Function overriding",
      "Virtual function",
      "Inline function"
    ]
  },
  {
    "q": "What will the output be?",
    "c": "#include <iostream>\nusing namespace std;\nclass A {\npublic:\n    virtual void display() { cout << \"A\"; }\n};\nclass B : public A {\npublic:\n    void display() override { cout << \"B\"; }\n};\nint main() {\n    A* obj = new B();\n    obj->display();\n    return 0;\n}",
    "o": [
      "B",
      "A",
      "Compilation error",
      "Runtime error"
    ]
  },
  {
    "q": "Which of the following is created automatically by the compiler for classes with virtual functions?",
    "o": [
      "vptr",
      "vfunc",
      "vdata",
      "vtableptr"
    ]
  },
  {
    "q": "What kind of polymorphism is used in operator overloading?",
    "o": [
      "Compile-time polymorphism",
      "Runtime polymorphism",
      "Typecasting polymorphism",
      "Dynamic inheritance"
    ]
  },
  {
    "q": "What is the purpose of a pure virtual function?",
    "o": [
      "To enforce derived classes to implement the function",
      "To allow default implementation in base class",
      "To enable constructor overloading",
      "To provide multiple inheritance"
    ]
  },
  {
    "q": "Identify the type of polymorphism in the given code.",
    "c": "class Print {\npublic:\n    void show(int a) { cout << a; }\n    void show(double b) { cout << b; }\n};",
    "o": [
      "Function overloading (compile-time polymorphism)",
      "Function overriding (runtime polymorphism)",
      "Abstract class behavior",
      "Virtual function resolution"
    ]
  },
  {
    "q": "Which statement best describes the relationship between vtable and virtual functions?",
    "o": [
      "The vtable stores addresses of virtual functions for dynamic dispatch.",
      "The vtable stores function names for runtime checking.",
      "The vtable holds data members of a class.",
      "The vtable is only used in function overloading."
    ]
  },
  {
    "q": "What does the following code demonstrate?",
    "c": "class A {\npublic:\n    virtual void speak() = 0;\n};\nclass B : public A {\npublic:\n    void speak() override { cout << \"B speaks\"; }\n};",
    "o": [
      "Abstract class with pure virtual function",
      "Function overloading",
      "Compile-time polymorphism",
      "Operator overloading"
    ]
  },
  {
    "q": "Which operator can NOT be overloaded in C++?",
    "o": [
      "?:",
      "+",
      "[]",
      "->"
    ]
  },
  {
    "q": "What kind of function is resolved at runtime rather than at compile time?",
    "o": [
      "Virtual function",
      "Inline function",
      "Static function",
      "Friend function"
    ]
  },
  {
    "q": "What is the key difference between function overloading and function overriding in C++?",
    "o": [
      "Function overloading happens at compile time, overriding at runtime.",
      "Function overloading needs virtual keyword, overriding does not.",
      "Function overloading cannot have same function names.",
      "Function overriding only works with constructors."
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "class Base {\npublic:\n    virtual void display() { cout << \"Base\\n\"; }\n};\nclass Derived : public Base {\npublic:\n    void display() override { cout << \"Derived\\n\"; }\n};\nint main() {\n    Base* bptr = new Derived();\n    bptr->display();\n    return 0;\n}",
    "o": [
      "Derived",
      "Base",
      "Derived Base",
      "Compilation Error"
    ]
  },
  {
    "q": "Which of the following statements about pure virtual functions is TRUE?",
    "o": [
      "They must be overridden in derived classes to instantiate objects.",
      "They provide default behavior in base classes.",
      "They prevent polymorphism from occurring.",
      "They are resolved at compile time."
    ]
  },
  {
    "q": "What does the 'vptr' point to in a C++ class with virtual functions?",
    "o": [
      "The vtable of the class",
      "The base class object",
      "The memory address of data members",
      "The object's constructor"
    ]
  },
  {
    "q": "Which type of polymorphism is demonstrated by the following code?",
    "c": "class Calculator {\npublic:\n    int add(int a, int b) { return a + b; }\n    double add(double a, double b) { return a + b; }\n};",
    "o": [
      "Compile-time polymorphism",
      "Runtime polymorphism",
      "Abstract class behavior",
      "Virtual inheritance"
    ]
  },
  {
    "q": "Which function type supports late binding in C++?",
    "o": [
      "Virtual functions",
      "Static functions",
      "Inline functions",
      "Overloaded functions"
    ]
  },
  {
    "q": "What is required in the base class for runtime polymorphism to work?",
    "o": [
      "A virtual function",
      "A static member",
      "A friend function",
      "An overloaded constructor"
    ]
  },
  {
    "q": "Which of the following best describes a vtable in C++?",
    "o": [
      "A table of function pointers for virtual function calls",
      "A list of class member names",
      "A storage structure for overloaded functions",
      "A pointer to base class members"
    ]
  },
  {
    "q": "Which of the following operators can be overloaded?",
    "o": [
      "+",
      "::",
      ".",
      "sizeof"
    ]
  },
  {
    "q": "Why can't we create an object of an abstract class?",
    "o": [
      "Because it contains at least one pure virtual function",
      "Because it doesn't have a constructor",
      "Because it must inherit from another class first",
      "Because it cannot contain data members"
    ]
  },
  {
    "q": "Which of the following resolves overloaded functions in C++?",
    "o": [
      "The compiler at compile time",
      "The runtime environment",
      "The operating system",
      "The linker during linking"
    ]
  },
  {
    "q": "What does the following code demonstrate?",
    "c": "class A {\npublic:\n    void show() { cout << \"A\"; }\n};\nclass B : public A {\npublic:\n    void show(int x) { cout << x; }\n};\nint main() {\n    B b;\n    b.show();\n    return 0;\n}",
    "o": [
      "Function hiding (not overloading)",
      "Function overloading",
      "Virtual function behavior",
      "Abstract class usage"
    ]
  },
  {
    "q": "Which keyword is essential for runtime polymorphism in C++?",
    "o": [
      "virtual",
      "const",
      "friend",
      "mutable"
    ]
  },
  {
    "q": "In the context of vtables, what does each entry in a vtable typically contain?",
    "o": [
      "A pointer to a virtual function implementation",
      "A pointer to data members",
      "A memory address of the class instance",
      "The name of the virtual function"
    ]
  },
  {
    "q": "Which of the following describes operator overloading?",
    "o": [
      "Redefining the behavior of an operator for user-defined types",
      "Changing operator behavior globally",
      "Making all operators virtual",
      "Allowing multiple classes to share the same operator instance"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "class Shape {\npublic:\n    virtual void draw() = 0;\n};\nclass Circle : public Shape {\npublic:\n    void draw() { cout << \"Circle\"; }\n};\nint main() {\n    Shape* s = new Circle();\n    s->draw();\n    return 0;\n}",
    "o": [
      "Circle",
      "Shape",
      "draw",
      "Compilation error"
    ]
  },
  {
    "q": "What happens if a class inherits from a class with a pure virtual function but doesn't override it?",
    "o": [
      "It becomes abstract and cannot be instantiated",
      "It overrides the function automatically",
      "It throws a compile-time error",
      "It runs without issues"
    ]
  },
  {
    "q": "What is the main benefit of using virtual functions in base classes?",
    "o": [
      "To achieve runtime polymorphism",
      "To reduce memory usage",
      "To prevent function overloading",
      "To increase compile-time speed"
    ]
  },
  {
    "q": "Which of the following operator overloads is most commonly used for custom string concatenation in C++?",
    "o": [
      "operator+",
      "operator-",
      "operator*",
      "operator="
    ]
  },
  {
    "q": "Which of the following best defines an abstract class in C++?",
    "o": [
      "A class with at least one pure virtual function",
      "A class with all virtual functions",
      "A class that cannot have a constructor",
      "A class that has no member functions"
    ]
  },
  {
    "q": "Which feature enables the same function name to be used for different types or numbers of parameters in C++?",
    "o": [
      "Function overloading",
      "Function overriding",
      "Virtual functions",
      "Templates"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "class A {\npublic:\n    void print() { cout << \"Class A\"; }\n};\nclass B : public A {\npublic:\n    void print(int x) { cout << x; }\n};\nint main() {\n    B obj;\n    obj.print(10);\n    return 0;\n}",
    "o": [
      "10",
      "Class A",
      "Class A10",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is **NOT** true about virtual functions?",
    "o": [
      "They are resolved at compile time",
      "They support runtime polymorphism",
      "They can be overridden in derived classes",
      "They require a base class pointer or reference"
    ]
  },
  {
    "q": "What role does the vptr play in runtime polymorphism?",
    "o": [
      "It points to the vtable of the object’s actual class",
      "It stores the return address of virtual functions",
      "It is used for compile-time polymorphism",
      "It holds the addresses of data members"
    ]
  },
  {
    "q": "What is the correct way to declare a pure virtual function in C++?",
    "o": [
      "virtual void draw() = 0;",
      "void draw() = 0;",
      "virtual draw() = 0;",
      "virtual void draw();"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "class A {\npublic:\n    virtual void fun() { cout << \"A::fun\"; }\n};\nclass B : public A {\npublic:\n    void fun() override { cout << \"B::fun\"; }\n};\nint main() {\n    A* ptr = new B();\n    ptr->fun();\n    return 0;\n}",
    "o": [
      "B::fun",
      "A::fun",
      "fun",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following functions would typically use operator overloading?",
    "o": [
      "Adding two complex numbers",
      "Allocating dynamic memory",
      "Calling a virtual function",
      "Defining a pure virtual class"
    ]
  },
  {
    "q": "Which of the following best describes function overriding?",
    "o": [
      "Defining a base class function as virtual and redefining it in derived class",
      "Using the same name with different parameters",
      "Writing functions inside another function",
      "Having multiple definitions of a function in one scope"
    ]
  },
  {
    "q": "Which condition is mandatory to achieve runtime polymorphism?",
    "o": [
      "Using base class pointer or reference to call a virtual function",
      "Overloading a function in the same class",
      "Having a non-static member function",
      "Calling constructors through pointers"
    ]
  },
  {
    "q": "What happens if a pure virtual function is not overridden in a derived class?",
    "o": [
      "The derived class becomes abstract",
      "The base class fails to compile",
      "It leads to a runtime error",
      "The function gets automatically implemented"
    ]
  },
  {
    "q": "Which C++ concept allows using the same operator for different data types?",
    "o": [
      "Operator overloading",
      "Virtual functions",
      "Inheritance",
      "Templates"
    ]
  },
  {
    "q": "What is the output of the following C++ code?",
    "c": "class Base {\npublic:\n    virtual void show() { cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void show() override { cout << \"Derived\"; }\n};\nint main() {\n    Base* b = new Derived();\n    b->show();\n    return 0;\n}",
    "o": [
      "Derived",
      "Base",
      "BaseDerived",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is a correct example of function overloading?",
    "c": "int sum(int a, int b) { return a + b; }\ndouble sum(double a, double b) { return a + b; }",
    "o": [
      "Two functions with same name but different parameter types",
      "One function defined in base and another in derived",
      "Two functions in different classes",
      "Overriding base function with virtual keyword"
    ]
  },
  {
    "q": "What is stored in the vtable?",
    "o": [
      "Addresses of virtual functions",
      "Return types of class methods",
      "Static data members",
      "Constructor memory locations"
    ]
  },
  {
    "q": "Which of the following makes a class abstract in C++?",
    "o": [
      "Having at least one pure virtual function",
      "Defining only private members",
      "Inheriting from another class",
      "Using a virtual destructor"
    ]
  },
  {
    "q": "What is the output of this program?",
    "c": "class Shape {\npublic:\n    virtual void draw() = 0;\n};\nclass Circle : public Shape {\npublic:\n    void draw() override { cout << \"Circle\"; }\n};\nint main() {\n    Shape* s = new Circle();\n    s->draw();\n    return 0;\n}",
    "o": [
      "Circle",
      "Shape",
      "draw",
      "Compilation error"
    ]
  },
  {
    "q": "Which scenario would cause compile-time polymorphism?",
    "o": [
      "Calling overloaded functions",
      "Calling virtual functions",
      "Using base class pointer to refer to derived class object",
      "Overriding a method in subclass"
    ]
  },
  {
    "q": "What is the main reason for using virtual functions?",
    "o": [
      "To achieve runtime polymorphism",
      "To implement function overloading",
      "To hide data members",
      "To create friend functions"
    ]
  },
  {
    "q": "Which of the following correctly overloads the '+' operator for a class?",
    "c": "class Point {\npublic:\n    int x, y;\n    Point operator+(const Point& p) {\n        return {x + p.x, y + p.y};\n    }\n};",
    "o": [
      "Correct syntax for operator overloading",
      "Incorrect due to missing return type",
      "Invalid operator for class use",
      "Overloaded in base instead of derived"
    ]
  },
  {
    "q": "What is the relationship between vptr and vtable in C++?",
    "o": [
      "vptr is a pointer that points to vtable",
      "vtable points to vptr",
      "vptr holds data member addresses",
      "vptr and vtable are unrelated"
    ]
  },
  {
    "q": "What type of polymorphism is achieved by function overloading in C++?",
    "o": [
      "Compile-time polymorphism",
      "Runtime polymorphism",
      "Dynamic binding",
      "Virtual inheritance"
    ]
  },
  {
    "q": "Which of the following correctly declares a pure virtual function?",
    "o": [
      "virtual void show() = 0;",
      "void show() = 0;",
      "virtual show() = 0;",
      "pure virtual void show();"
    ]
  },
  {
    "q": "What is the output of this C++ code?",
    "c": "class A {\npublic:\n    void show() { cout << \"A\"; }\n    void show(int) { cout << \"A int\"; }\n};\nint main() {\n    A obj;\n    obj.show();\n    obj.show(5);\n    return 0;\n}",
    "o": [
      "AA int",
      "A",
      "A int",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is NOT true about virtual functions in C++?",
    "o": [
      "Virtual functions cannot be static",
      "Virtual functions support runtime polymorphism",
      "A class with a virtual function must have a virtual destructor",
      "Virtual functions are resolved using vtable"
    ]
  },
  {
    "q": "Which mechanism in C++ uses a table to resolve virtual function calls at runtime?",
    "o": [
      "vtable",
      "stack frame",
      "function pointer array",
      "heap manager"
    ]
  },
  {
    "q": "What is the output of this C++ code?",
    "c": "class A {\npublic:\n    virtual void print() { cout << \"A\"; }\n};\nclass B : public A {\npublic:\n    void print() { cout << \"B\"; }\n};\nint main() {\n    A* obj = new B();\n    obj->print();\n    return 0;\n}",
    "o": [
      "B",
      "A",
      "Compilation error",
      "AB"
    ]
  },
  {
    "q": "Which of the following statements is true about abstract classes?",
    "o": [
      "They cannot be instantiated",
      "They must contain only virtual functions",
      "They can’t be used as base classes",
      "They must inherit from another abstract class"
    ]
  },
  {
    "q": "What happens if a class inherits a pure virtual function but does not override it?",
    "o": [
      "The derived class becomes abstract",
      "The program throws a runtime error",
      "The function becomes non-virtual",
      "The function is removed from memory"
    ]
  },
  {
    "q": "Which of the following allows different implementations of a function with the same name in different classes, resolved at runtime?",
    "o": [
      "Virtual functions",
      "Function overloading",
      "Function templates",
      "Default arguments"
    ]
  },
  {
    "q": "What is the main purpose of a vptr (virtual pointer) in C++?",
    "o": [
      "To point to the vtable of the object’s class",
      "To store the base class address",
      "To manage memory allocation",
      "To overload operators dynamically"
    ]
  },
  {
    "q": "What is the output of this code snippet involving operator overloading?",
    "c": "class Point {\npublic:\n    int x, y;\n    Point(int a, int b): x(a), y(b) {}\n    Point operator + (const Point& p) {\n        return Point(x + p.x, y + p.y);\n    }\n    void display() { cout << x << \" \" << y; }\n};\n\nint main() {\n    Point p1(1, 2), p2(3, 4);\n    Point p3 = p1 + p2;\n    p3.display();\n    return 0;\n}",
    "o": [
      "4 6",
      "1 2",
      "3 4",
      "5 6"
    ]
  },
  {
    "q": "Which of the following is an example of compile-time polymorphism?",
    "o": [
      "Function overloading",
      "Virtual function",
      "Pure virtual function",
      "Function overriding"
    ]
  },
  {
    "q": "Which keyword is necessary to achieve runtime polymorphism in C++?",
    "o": [
      "virtual",
      "override",
      "abstract",
      "mutable"
    ]
  },
  {
    "q": "What is the output of this C++ code snippet?",
    "c": "class Base {\npublic:\n    virtual void show() { cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void show() { cout << \"Derived\"; }\n};\n\nint main() {\n    Base* b = new Derived();\n    b->show();\n    return 0;\n}",
    "o": [
      "Derived",
      "Base",
      "Compilation Error",
      "Runtime Error"
    ]
  },
  {
    "q": "Which of the following statements about vtables is true?",
    "o": [
      "Each class with virtual functions has its own vtable",
      "Only derived classes have a vtable",
      "Vtables are created only at compile-time",
      "A vtable contains data members of the class"
    ]
  },
  {
    "q": "Which of these is true about pure virtual functions?",
    "o": [
      "They force derived classes to implement the function",
      "They cannot be declared in abstract classes",
      "They are automatically inline",
      "They must return void"
    ]
  },
  {
    "q": "What happens if a derived class doesn’t override a pure virtual function?",
    "o": [
      "It becomes an abstract class itself",
      "It throws a compile-time error only when instantiated",
      "It uses a default implementation",
      "It compiles but gives a runtime error"
    ]
  },
  {
    "q": "Which of these code snippets correctly shows function overloading?",
    "c": "class A {\npublic:\n    void show() { cout << \"Show1\"; }\n    void show(int x) { cout << \"Show2\"; }\n};\n\nint main() {\n    A obj;\n    obj.show(10);\n    return 0;\n}",
    "o": [
      "Show2",
      "Show1",
      "Compilation Error",
      "Runtime Error"
    ]
  },
  {
    "q": "Which of the following is required for a class to be considered abstract in C++?",
    "o": [
      "At least one pure virtual function",
      "At least one private data member",
      "At least one static function",
      "Must inherit from another class"
    ]
  },
  {
    "q": "What is the correct term for the pointer used to point to the virtual table in an object?",
    "o": [
      "vptr",
      "this pointer",
      "base pointer",
      "class pointer"
    ]
  },
  {
    "q": "Which concept allows multiple functions with the same name but different parameters in C++?",
    "o": [
      "Function Overloading",
      "Function Overriding",
      "Virtual Function",
      "Abstract Function"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "class A {\npublic:\n    void show() { cout << \"A::show\"; }\n    void show(int) { cout << \"A::show(int)\"; }\n};\n\nint main() {\n    A obj;\n    obj.show();\n    return 0;\n}",
    "o": [
      "A::show",
      "A::show(int)",
      "Compilation Error",
      "Runtime Error"
    ]
  },
  {
    "q": "Which of the following best describes a virtual function?",
    "o": [
      "A function that is resolved at runtime using dynamic dispatch",
      "A function that can only be called from derived classes",
      "A function with no implementation in the base class",
      "A function that must be overloaded"
    ]
  },
  {
    "q": "Which of the following code snippets creates an abstract class in C++?",
    "c": "class Shape {\npublic:\n    virtual void draw() = 0;\n};",
    "o": [
      "An abstract class",
      "A concrete class",
      "A class with overloaded function",
      "A static class"
    ]
  },
  {
    "q": "What is the role of a vtable in C++?",
    "o": [
      "To support dynamic dispatch of virtual functions",
      "To store class variables",
      "To handle operator overloading",
      "To store function overloads"
    ]
  },
  {
    "q": "Which statement is true about operator overloading in C++?",
    "o": [
      "It is an example of compile-time polymorphism",
      "It can only be done for built-in types",
      "It is always done using virtual functions",
      "It must be implemented outside the class"
    ]
  },
  {
    "q": "Which of the following causes dynamic dispatch to occur?",
    "o": [
      "Calling a virtual function through a base class pointer",
      "Calling a non-virtual function",
      "Overloading a function",
      "Using a friend function"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "class A {\npublic:\n    virtual void display() { cout << \"A\"; }\n};\nclass B: public A {\npublic:\n    void display() override { cout << \"B\"; }\n};\n\nint main() {\n    A* ptr = new B();\n    ptr->display();\n    return 0;\n}",
    "o": [
      "B",
      "A",
      "Compilation Error",
      "Segmentation Fault"
    ]
  },
  {
    "q": "What will happen if a pure virtual function is not overridden in a derived class and an object is instantiated?",
    "o": [
      "Compilation error",
      "Program runs but gives incorrect output",
      "Virtual function of base class will be called",
      "Program crashes at runtime"
    ]
  },
  {
    "q": "Which of the following is NOT true about virtual functions?",
    "o": [
      "They are resolved at compile-time",
      "They are used to achieve runtime polymorphism",
      "They must be members of a class",
      "They can be overridden in derived classes"
    ]
  },
  {
    "q": "Which of the following best illustrates operator overloading in C++?",
    "c": "class Complex {\npublic:\n    int real, imag;\n    Complex operator+(const Complex& obj) {\n        Complex temp;\n        temp.real = real + obj.real;\n        temp.imag = imag + obj.imag;\n        return temp;\n    }\n};",
    "o": [
      "Compile-time polymorphism",
      "Runtime polymorphism",
      "Virtual inheritance",
      "Dynamic memory"
    ]
  },
  {
    "q": "What is the primary reason to use a pure virtual function?",
    "o": [
      "To create an abstract class",
      "To enable function overloading",
      "To perform operator overloading",
      "To restrict constructor usage"
    ]
  },
  {
    "q": "Which of the following is resolved at runtime?",
    "o": [
      "Virtual function call",
      "Function overloading",
      "Operator overloading",
      "Template instantiation"
    ]
  },
  {
    "q": "What does a virtual table (vtable) contain?",
    "o": [
      "Addresses of virtual functions",
      "Class data members",
      "Static member values",
      "Constructor addresses"
    ]
  },
  {
    "q": "What will be the output?",
    "c": "class Base {\npublic:\n    virtual void show() { cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void show() override { cout << \"Derived\"; }\n};\n\nint main() {\n    Base* ptr = new Derived();\n    ptr->show();\n    return 0;\n}",
    "o": [
      "Derived",
      "Base",
      "Compilation Error",
      "No Output"
    ]
  },
  {
    "q": "Which of the following statements is true about function overloading?",
    "o": [
      "It occurs when multiple functions have the same name but different parameters.",
      "It requires virtual keyword.",
      "It resolves at runtime.",
      "It requires base and derived class relation."
    ]
  },
  {
    "q": "Which mechanism in C++ uses vptr (virtual pointer) internally?",
    "o": [
      "Runtime polymorphism",
      "Compile-time polymorphism",
      "Namespace resolution",
      "Static data members"
    ]
  },
  {
    "q": "Which of the following will cause a class to be abstract?",
    "c": "class A {\npublic:\n    virtual void display() = 0;\n};",
    "o": [
      "Having at least one pure virtual function",
      "Defining any virtual function",
      "Using a friend function",
      "Overloading operators"
    ]
  },
  {
    "q": "Which of the following code snippets shows function overloading?",
    "c": "class Print {\npublic:\n    void show(int x) { cout << x; }\n    void show(double x) { cout << x; }\n};",
    "o": [
      "Function overloading",
      "Function overriding",
      "Virtual function",
      "Template usage"
    ]
  },
  {
    "q": "In C++, what must be true for a function to be overridden?",
    "o": [
      "It must be virtual in the base class",
      "It must be static",
      "It must be overloaded",
      "It must be inline"
    ]
  },
  {
    "q": "Which concept allows the '+' operator to work differently for strings and integers in C++?",
    "o": [
      "Operator overloading",
      "Function overloading",
      "Inheritance",
      "Virtual function"
    ]
  },
  {
    "q": "What is the key requirement for achieving runtime polymorphism?",
    "o": [
      "Base class must have a virtual function",
      "Functions must be overloaded",
      "Use of inline functions",
      "Static data members"
    ]
  },
  {
    "q": "Which of the following defines a class as abstract in C++?",
    "c": "class Shape {\npublic:\n    virtual void draw() = 0;\n};",
    "o": [
      "Presence of a pure virtual function",
      "Presence of a virtual destructor",
      "Private data members",
      "Overloaded constructors"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "class A {\npublic:\n    virtual void show() { cout << \"A\"; }\n};\nclass B: public A {\npublic:\n    void show() override { cout << \"B\"; }\n};\nint main() {\n    A* obj = new B();\n    obj->show();\n    return 0;\n}",
    "o": [
      "B",
      "A",
      "AB",
      "Error"
    ]
  },
  {
    "q": "What does the vptr (virtual pointer) point to in a class object?",
    "o": [
      "The virtual table (vtable)",
      "The object’s base address",
      "The static memory of class",
      "A reference to the class name"
    ]
  },
  {
    "q": "Which of the following correctly demonstrates function overloading?",
    "c": "void print(int x) { cout << x; }\nvoid print(double x) { cout << x; }",
    "o": [
      "Two functions with same name and different parameter types",
      "A virtual function in derived class",
      "Same function with same parameters",
      "A base and derived function with same signature"
    ]
  },
  {
    "q": "Which concept allows the same function name to be used with different parameter types in C++?",
    "o": [
      "Function overloading",
      "Virtual functions",
      "Inheritance",
      "Templates"
    ]
  },
  {
    "q": "Which table holds addresses of overridden virtual functions at runtime?",
    "o": [
      "Vtable",
      "Function stack",
      "Memory map",
      "Symbol table"
    ]
  },
  {
    "q": "What happens if a class has a pure virtual function but doesn't override it in the derived class?",
    "o": [
      "Derived class becomes abstract",
      "Compiler will automatically override it",
      "Program runs with base class version",
      "Derived class becomes static"
    ]
  },
  {
    "q": "Which feature of C++ ensures that the correct version of a function is called for an object, regardless of the pointer type?",
    "o": [
      "Virtual functions and runtime polymorphism",
      "Function overloading",
      "Templates",
      "Static binding"
    ]
  },
  {
    "q": "Which of the following is an example of compile-time polymorphism?",
    "o": [
      "Function overloading",
      "Virtual function",
      "Dynamic casting",
      "Runtime binding"
    ]
  },
  {
    "q": "What is required in a base class to allow function overriding in derived classes?",
    "o": [
      "Virtual keyword",
      "Const keyword",
      "Static function",
      "Inline function"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "class Base {\npublic:\n    void display() { cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void display() { cout << \"Derived\"; }\n};\nint main() {\n    Base* ptr = new Derived();\n    ptr->display();\n}",
    "o": [
      "Base",
      "Derived",
      "Error",
      "BaseDerived"
    ]
  },
  {
    "q": "How does C++ achieve runtime polymorphism internally?",
    "o": [
      "Using vptr and vtable",
      "Using templates",
      "Using function pointers only",
      "Using macros"
    ]
  },
  {
    "q": "Which of the following is true about a class that has at least one pure virtual function?",
    "o": [
      "It cannot be instantiated",
      "It must be static",
      "It can only be inherited privately",
      "It can have only one child"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "class A {\npublic:\n    virtual void show() = 0;\n};\nclass B : public A {\npublic:\n    void show() { cout << \"B\"; }\n};\nint main() {\n    B obj;\n    obj.show();\n}",
    "o": [
      "B",
      "A",
      "Error: abstract class instantiation",
      "No output"
    ]
  },
  {
    "q": "Which of the following statements is true regarding operator overloading?",
    "o": [
      "It allows user-defined behavior for operators",
      "It must always return a bool",
      "It is mandatory in C++",
      "It works only for arithmetic operators"
    ]
  },
  {
    "q": "What will happen if a virtual function is not overridden in the derived class?",
    "o": [
      "Base class version is called",
      "Compile-time error occurs",
      "Undefined behavior",
      "Derived class object can't be created"
    ]
  },
  {
    "q": "Which of the following best describes the role of the virtual table (vtable)?",
    "o": [
      "It stores addresses of virtual functions for a class",
      "It stores values of static variables",
      "It holds memory layout of all objects",
      "It links template instantiations"
    ]
  },
  {
    "q": "Which of the following code snippets shows correct function overloading?",
    "c": "void compute(int a);\nvoid compute(int a, int b);\nvoid compute(double a);",
    "o": [
      "All functions named compute with different signatures",
      "Virtual compute functions",
      "All functions use same parameter list",
      "All functions declared static"
    ]
  },
  {
    "q": "Which of the following best describes virtual functions in C++?",
    "o": [
      "They enable runtime polymorphism",
      "They are resolved at compile time",
      "They can only be static",
      "They cannot be overridden"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "class A {\npublic:\n    virtual void print() { cout << \"A\"; }\n};\nclass B : public A {\npublic:\n    void print() override { cout << \"B\"; }\n};\nint main() {\n    A a;\n    B b;\n    A* ptr = &b;\n    ptr->print();\n}",
    "o": [
      "B",
      "A",
      "AB",
      "Error"
    ]
  },
  {
    "q": "What happens when you overload an operator in C++?",
    "o": [
      "You define custom behavior for that operator with user-defined types",
      "You increase performance at runtime",
      "You create multiple copies of the same operator",
      "The operator loses its default behavior"
    ]
  },
  {
    "q": "Which of the following is an invalid function overload?",
    "c": "int func(int a);\ndouble func(int a);",
    "o": [
      "Overloading only by return type is not allowed",
      "Overloading by changing number of parameters",
      "Overloading by changing parameter types",
      "Overloading with const and non-const variants"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "class Base {\npublic:\n    virtual void show() { cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void show() { cout << \"Derived\"; }\n};\nint main() {\n    Derived d;\n    Base& ref = d;\n    ref.show();\n}",
    "o": [
      "Derived",
      "Base",
      "Error",
      "Nothing"
    ]
  },
  {
    "q": "In the context of vtables, what is a 'vptr'?",
    "o": [
      "A hidden pointer in each object pointing to its class's vtable",
      "A pointer to the base class only",
      "A pointer to static memory region",
      "A pointer to the object's constructor"
    ]
  },
  {
    "q": "Which statement about abstract classes in C++ is true?",
    "o": [
      "They cannot be instantiated",
      "They must have at least one static function",
      "They always have a virtual destructor",
      "They can’t be inherited"
    ]
  },
  {
    "q": "What is the main purpose of making a function ‘pure virtual’?",
    "o": [
      "To force derived classes to override it",
      "To make the function static",
      "To prevent any overriding",
      "To improve memory usage"
    ]
  },
  {
    "q": "Which of the following will NOT compile in C++?",
    "c": "class A {\npublic:\n    virtual void func() = 0;\n};\nint main() {\n    A a;\n}",
    "o": [
      "You cannot instantiate an abstract class",
      "You cannot define virtual functions inside a class",
      "A class cannot be public",
      "The main function must return void"
    ]
  },
  {
    "q": "What allows different classes to respond differently to the same function call at runtime?",
    "o": [
      "Virtual functions",
      "Function overloading",
      "Templates",
      "Friend functions"
    ]
  },
  {
    "q": "Which of the following concepts allows a single function name to work with different parameter types at compile time?",
    "o": [
      "Function overloading",
      "Virtual functions",
      "Inheritance",
      "Templates"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "class A {\npublic:\n    void display(int x) { cout << x; }\n    void display(double y) { cout << y; }\n};\nint main() {\n    A obj;\n    obj.display(3);\n}",
    "o": [
      "3",
      "3.0",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following is used by the C++ compiler to resolve function calls at runtime when virtual functions are used?",
    "o": [
      "Vtable",
      "Constructor",
      "Inline expansion",
      "Function pointer array"
    ]
  },
  {
    "q": "What is the purpose of a virtual destructor in a base class?",
    "o": [
      "To ensure derived class destructors are called properly",
      "To allow destructor overloading",
      "To prevent object slicing",
      "To disable object creation"
    ]
  },
  {
    "q": "Identify the valid use of operator overloading in C++.",
    "o": [
      "Complex operator+(const Complex& c)",
      "void operator+();",
      "int operator()(int a);",
      "operator int();"
    ]
  },
  {
    "q": "Which of these keywords make a class abstract in C++?",
    "o": [
      "Pure virtual function",
      "Virtual constructor",
      "Static function",
      "Overloaded destructor"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "class Base {\npublic:\n    virtual void show() { cout << \"Base\"; }\n};\nclass Derived : public Base {};\nint main() {\n    Derived d;\n    d.show();\n}",
    "o": [
      "Base",
      "Derived",
      "Error",
      "Nothing"
    ]
  },
  {
    "q": "What is the effect of defining a function as virtual in the base class?",
    "o": [
      "Allows derived class to override it and supports runtime dispatch",
      "Makes the function static",
      "Stops it from being inherited",
      "Converts it into an inline function"
    ]
  },
  {
    "q": "Which of the following is true about vtables in C++?",
    "o": [
      "Each class with virtual functions has its own vtable",
      "Only static functions are stored in vtables",
      "Vtables are created manually by the programmer",
      "Vtables can be accessed directly by user code"
    ]
  },
  {
    "q": "In which of the following scenarios is polymorphism used?",
    "o": [
      "A base pointer calling an overridden method of a derived class",
      "Multiple variables having the same value",
      "Static data members shared by all objects",
      "Operator precedence rules"
    ]
  },
  {
    "q": "Which of the following allows multiple functions with the same name but different parameter types or counts in C++?",
    "o": [
      "Function overloading",
      "Function overriding",
      "Function hiding",
      "Template specialization"
    ]
  },
  {
    "q": "What will the following C++ code output?",
    "c": "class A {\npublic:\n    void show() { cout << \"A\"; }\n    void show(int) { cout << \"A with int\"; }\n};\nint main() {\n    A obj;\n    obj.show(5);\n    return 0;\n}",
    "o": [
      "A with int",
      "A",
      "Compilation error",
      "5"
    ]
  },
  {
    "q": "Which of these ensures a derived class must override a function in C++?",
    "o": [
      "Declaring it as a pure virtual function",
      "Making it protected",
      "Overloading it",
      "Declaring it as static"
    ]
  },
  {
    "q": "What is the role of the `vptr` in C++?",
    "o": [
      "It is a hidden pointer used to access the vtable for dynamic dispatch",
      "It holds the address of base class data",
      "It stores function overload information",
      "It is an explicit pointer we define"
    ]
  },
  {
    "q": "Which of the following operators cannot be overloaded in C++?",
    "o": [
      "sizeof",
      "+",
      "==",
      "[]"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "class Base {\npublic:\n    virtual void print() { cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void print() override { cout << \"Derived\"; }\n};\nint main() {\n    Base* b = new Derived();\n    b->print();\n    return 0;\n}",
    "o": [
      "Derived",
      "Base",
      "Compilation error",
      "Runtime error"
    ]
  },
  {
    "q": "What is the correct way to declare a pure virtual function?",
    "o": [
      "virtual void show() = 0;",
      "void show() = virtual;",
      "pure virtual void show();",
      "virtual void show(); = 0"
    ]
  },
  {
    "q": "Which statement about vtables is true?",
    "o": [
      "They map virtual function calls to the correct function implementation at runtime",
      "They are manually defined by the programmer",
      "They are used only with static functions",
      "They are a type of constructor table"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "class A {\npublic:\n    A operator+(const A& obj) { cout << \"+ operator\"; return *this; }\n};\nint main() {\n    A a1, a2;\n    A a3 = a1 + a2;\n    return 0;\n}",
    "o": [
      "+ operator",
      "Compilation error",
      "No output",
      "a1 + a2"
    ]
  },
  {
    "q": "Which of the following best defines an abstract class in C++?",
    "o": [
      "A class that contains at least one pure virtual function",
      "A class that has only private members",
      "A class with only static methods",
      "A class with overloaded constructors"
    ]
  },
  {
    "q": "Which type of polymorphism resolves function calls during compilation in C++?",
    "o": [
      "Compile-time polymorphism",
      "Runtime polymorphism",
      "Dynamic polymorphism",
      "Late binding"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "class Shape {\npublic:\n    virtual void draw() { cout << \"Drawing Shape\"; }\n};\nclass Circle : public Shape {\npublic:\n    void draw() override { cout << \"Drawing Circle\"; }\n};\nint main() {\n    Shape* s = new Circle();\n    s->draw();\n    return 0;\n}",
    "o": [
      "Drawing Circle",
      "Drawing Shape",
      "Circle",
      "Compilation Error"
    ]
  },
  {
    "q": "What is the output of the code below using function overloading?",
    "c": "void greet() { cout << \"Hello\"; }\nvoid greet(string name) { cout << \"Hello, \" << name; }\n\nint main() {\n    greet(\"Alice\");\n    return 0;\n}",
    "o": [
      "Hello, Alice",
      "Hello",
      "Compilation Error",
      "Hello Alice"
    ]
  },
  {
    "q": "Which concept enables multiple definitions of an operator for user-defined types?",
    "o": [
      "Operator overloading",
      "Inheritance",
      "Function overriding",
      "Encapsulation"
    ]
  },
  {
    "q": "What is true about the vtable in C++?",
    "o": [
      "It is created by the compiler for classes with virtual functions",
      "It is manually defined by the programmer",
      "It only exists in static classes",
      "It is used for compile-time dispatch"
    ]
  },
  {
    "q": "Which of the following classes is abstract?",
    "c": "class Animal {\npublic:\n    virtual void speak() = 0;\n};",
    "o": [
      "Animal",
      "ConcreteAnimal",
      "Main",
      "None of the above"
    ]
  },
  {
    "q": "What does the keyword `virtual` ensure when used in base class functions?",
    "o": [
      "Function call is resolved at runtime",
      "Function is executed inline",
      "Function is private",
      "Function cannot be overridden"
    ]
  },
  {
    "q": "Which of the following is a correct example of operator overloading in C++?",
    "c": "class Point {\npublic:\n    int x, y;\n    Point operator+(const Point& p) {\n        return {x + p.x, y + p.y};\n    }\n};",
    "o": [
      "operator+ overloaded to add two Point objects",
      "operator[] overloaded to add coordinates",
      "operator() used to return sum",
      "operator* overloaded for subtraction"
    ]
  },
  {
    "q": "Which of the following features enable runtime polymorphism?",
    "o": [
      "Virtual functions",
      "Function overloading",
      "Default arguments",
      "Function templates"
    ]
  },
  {
    "q": "What happens if a derived class does not override a pure virtual function?",
    "o": [
      "The derived class becomes abstract",
      "The base class becomes abstract",
      "The code compiles and runs fine",
      "The function is ignored"
    ]
  },
  {
    "q": "Which of the following best describes function overloading in C++?",
    "o": [
      "Multiple functions with the same name but different parameters",
      "Overriding a function from a base class",
      "Defining one function inside another",
      "Using functions from another class"
    ]
  },
  {
    "q": "What is the output of this code involving operator overloading?",
    "c": "class Complex {\npublic:\n    int real, imag;\n    Complex(int r, int i) : real(r), imag(i) {}\n    Complex operator-(const Complex& c) {\n        return Complex(real - c.real, imag - c.imag);\n    }\n};\n\nint main() {\n    Complex c1(4, 5), c2(1, 2);\n    Complex c3 = c1 - c2;\n    cout << c3.real << \" \" << c3.imag;\n}",
    "o": [
      "3 3",
      "5 7",
      "1 2",
      "-3 -3"
    ]
  },
  {
    "q": "What is required for runtime polymorphism to work in C++?",
    "o": [
      "A base class pointer or reference and virtual function",
      "Overloaded functions",
      "Friend function",
      "Static function"
    ]
  },
  {
    "q": "What is true about a pure virtual function?",
    "o": [
      "It forces derived classes to implement the function",
      "It has a default implementation in the base class",
      "It cannot be declared in abstract classes",
      "It is only used in templates"
    ]
  },
  {
    "q": "Identify the correct use of function overloading from below:",
    "c": "void print(int i) { cout << i; }\nvoid print(double d) { cout << d; }\nvoid print(string s) { cout << s; }",
    "o": [
      "Multiple print functions with different parameter types",
      "One function print that works for all types",
      "Using templates for print",
      "Using macros to define print"
    ]
  },
  {
    "q": "What is the role of the virtual table (vtable) in C++?",
    "o": [
      "It helps resolve virtual function calls at runtime",
      "It stores overloaded functions",
      "It compiles the program faster",
      "It stores template functions"
    ]
  },
  {
    "q": "Which C++ keyword makes a function virtual for runtime binding?",
    "o": [
      "virtual",
      "override",
      "inline",
      "friend"
    ]
  },
  {
    "q": "What will be the output?",
    "c": "class Base {\npublic:\n    virtual void show() { cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void show() override { cout << \"Derived\"; }\n};\n\nint main() {\n    Base* b = new Derived();\n    b->show();\n}",
    "o": [
      "Derived",
      "Base",
      "Compilation error",
      "Segmentation fault"
    ]
  },
  {
    "q": "Which of these is NOT true about operator overloading?",
    "o": [
      "We can overload the sizeof operator",
      "We can overload + operator",
      "We can overload == operator",
      "We can overload << operator"
    ]
  },
  {
    "q": "Which of the following indicates a class is abstract?",
    "o": [
      "It contains at least one pure virtual function",
      "It has no constructor",
      "It inherits another class",
      "It contains private members"
    ]
  },
  {
    "q": "Which of the following allows multiple functions with the same name but different signatures?",
    "o": [
      "Function overloading",
      "Function overriding",
      "Virtual functions",
      "Inline functions"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "class Shape {\npublic:\n    virtual void draw() {\n        cout << \"Drawing Shape\";\n    }\n};\nclass Circle : public Shape {\npublic:\n    void draw() override {\n        cout << \"Drawing Circle\";\n    }\n};\nint main() {\n    Shape* s = new Circle();\n    s->draw();\n}",
    "o": [
      "Drawing Circle",
      "Drawing Shape",
      "Drawing CircleShape",
      "Runtime Error"
    ]
  },
  {
    "q": "Which operator can be overloaded in C++?",
    "o": [
      "+",
      "?:",
      "sizeof",
      ".*"
    ]
  },
  {
    "q": "Which of these best describes a virtual table (vtable)?",
    "o": [
      "A table used to resolve virtual function calls at runtime",
      "A class-level static member for memory management",
      "A structure holding overloaded operators",
      "A preprocessor macro structure"
    ]
  },
  {
    "q": "Which of the following correctly defines a pure virtual function?",
    "o": [
      "virtual void speak() = 0;",
      "void speak() = 0;",
      "virtual void speak() {}",
      "pure virtual void speak();"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "class A {\npublic:\n    void show() { cout << \"A\"; }\n};\nclass B : public A {\npublic:\n    void show() { cout << \"B\"; }\n};\nint main() {\n    A* ptr = new B();\n    ptr->show();\n}",
    "o": [
      "A",
      "B",
      "AB",
      "Runtime Error"
    ]
  },
  {
    "q": "What happens if a class has at least one pure virtual function?",
    "o": [
      "It becomes an abstract class",
      "It cannot be inherited",
      "It must be static",
      "It must have a default constructor"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "class A {\npublic:\n    virtual void print() { cout << \"A\"; }\n};\nclass B : public A {\n};\nint main() {\n    B b;\n    b.print();\n}",
    "o": [
      "A",
      "B",
      "AB",
      "Compilation Error"
    ]
  },
  {
    "q": "Which of the following operators cannot be overloaded in C++?",
    "o": [
      "?:",
      "==",
      "+",
      "<<"
    ]
  },
  {
    "q": "Which pointer in each object points to the virtual table of its class?",
    "o": [
      "vptr",
      "this",
      "base",
      "vpointer"
    ]
  },
  {
    "q": "What is the main difference between function overloading and function overriding in C++?",
    "o": [
      "Overloading happens at compile-time, overriding happens at runtime",
      "Overriding happens at compile-time, overloading at runtime",
      "Both happen at compile-time",
      "Both happen at runtime"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "class Printer {\npublic:\n    void print(int i) { cout << \"Integer: \" << i << endl; }\n    void print(double d) { cout << \"Double: \" << d << endl; }\n};\nint main() {\n    Printer p;\n    p.print(5.5);\n}",
    "o": [
      "Double: 5.5",
      "Integer: 5",
      "Compile Error",
      "Runtime Error"
    ]
  },
  {
    "q": "Which of the following statements about virtual functions is TRUE?",
    "o": [
      "They support runtime polymorphism",
      "They cannot be overridden",
      "They are resolved at compile time",
      "They are faster than non-virtual functions"
    ]
  },
  {
    "q": "What is required to make a class abstract in C++?",
    "o": [
      "At least one pure virtual function",
      "A private constructor",
      "Multiple inheritance",
      "A friend function"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "class A {\npublic:\n    virtual void foo() { cout << \"A\"; }\n};\nclass B : public A {\npublic:\n    void foo() { cout << \"B\"; }\n};\nint main() {\n    A* obj = new B();\n    obj->foo();\n}",
    "o": [
      "B",
      "A",
      "AB",
      "Compile Error"
    ]
  },
  {
    "q": "Which one of these is NOT true about vtables?",
    "o": [
      "They are created at compile-time for each class with virtual functions",
      "They are used to support runtime polymorphism",
      "They contain function pointers",
      "Each object has its own copy of the vtable"
    ]
  },
  {
    "q": "Which of the following is a valid operator overloading declaration?",
    "o": [
      "Complex operator+(const Complex& c);",
      "operator+ Complex(const Complex& c);",
      "Complex operator+(Complex c)",
      "operator Complex+(const Complex& c);"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "class A {\npublic:\n    virtual void show() = 0;\n};\nclass B : public A {\npublic:\n    void show() { cout << \"B\"; }\n};\nint main() {\n    B b;\n    b.show();\n}",
    "o": [
      "B",
      "A",
      "Compile Error",
      "Runtime Error"
    ]
  },
  {
    "q": "If a base class pointer points to a derived class object, and the function is not virtual, which function will be called?",
    "o": [
      "Base class function",
      "Derived class function",
      "It depends on runtime conditions",
      "Compiler randomly chooses"
    ]
  },
  {
    "q": "Which concept allows redefining the '+' operator to work with user-defined types?",
    "o": [
      "Operator overloading",
      "Function overriding",
      "Template specialization",
      "Friend function"
    ]
  },
  {
    "q": "Which of the following enables multiple functions with the same name but different parameters?",
    "o": [
      "Function overloading",
      "Function overriding",
      "Virtual functions",
      "Templates"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "class Demo {\npublic:\n    void show() { cout << \"Base\"; }\n    void show(int) { cout << \"Overloaded\"; }\n};\nint main() {\n    Demo d;\n    d.show(10);\n}",
    "o": [
      "Overloaded",
      "Base",
      "BaseOverloaded",
      "Compile Error"
    ]
  },
  {
    "q": "How is the correct function resolved in case of operator overloading?",
    "o": [
      "At compile time",
      "At runtime",
      "Via virtual table",
      "Using a function pointer"
    ]
  },
  {
    "q": "Which feature allows dynamic dispatch of methods in C++?",
    "o": [
      "Virtual functions",
      "Function overloading",
      "Templates",
      "Static functions"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "class Parent {\npublic:\n    virtual void speak() { cout << \"Parent\"; }\n};\nclass Child : public Parent {\npublic:\n    void speak() override { cout << \"Child\"; }\n};\nint main() {\n    Parent* p = new Child();\n    p->speak();\n}",
    "o": [
      "Child",
      "Parent",
      "Compile error",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following best describes a vptr?",
    "o": [
      "A hidden pointer to the vtable maintained by each polymorphic object",
      "A table of all class member variables",
      "Pointer to base class object",
      "A pointer to class constructor"
    ]
  },
  {
    "q": "Which of the following statements is TRUE about abstract classes in C++?",
    "o": [
      "They cannot be instantiated directly",
      "They cannot have constructors",
      "They cannot have non-virtual functions",
      "They must inherit from another class"
    ]
  },
  {
    "q": "What is the role of the virtual table (vtable) in C++?",
    "o": [
      "It maps virtual functions to their corresponding addresses",
      "It stores all data members of a class",
      "It holds constructors and destructors",
      "It is used only with static functions"
    ]
  },
  {
    "q": "Which of the following code snippets defines a pure virtual function?",
    "o": [
      "virtual void display() = 0;",
      "virtual void display();",
      "void display() = 0;",
      "static void display() = 0;"
    ]
  },
  {
    "q": "What happens if a class contains at least one pure virtual function?",
    "o": [
      "It becomes an abstract class",
      "It cannot inherit from another class",
      "It cannot have virtual functions",
      "It must be instantiated immediately"
    ]
  },
  {
    "q": "Which concept allows the same operator to have different meanings based on context in C++?",
    "o": [
      "Operator overloading",
      "Virtual functions",
      "Inheritance",
      "Templates"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "class Test {\npublic:\n    void show() { cout << \"No args\"; }\n    void show(int x) { cout << \"Int arg: \" << x; }\n};\nint main() {\n    Test t;\n    t.show(5);\n}",
    "o": [
      "Int arg: 5",
      "No args",
      "Compile error",
      "Nothing"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "class Base {\npublic:\n    virtual void greet() { cout << \"Hello from Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void greet() override { cout << \"Hello from Derived\"; }\n};\nint main() {\n    Base* b = new Derived();\n    b->greet();\n}",
    "o": [
      "Hello from Derived",
      "Hello from Base",
      "Compile error",
      "Runtime error"
    ]
  },
  {
    "q": "Which of the following allows function call resolution at runtime?",
    "o": [
      "Virtual function",
      "Function overloading",
      "Inline function",
      "Static function"
    ]
  },
  {
    "q": "How many vptrs does a simple C++ class with a single virtual function have?",
    "o": [
      "1",
      "0",
      "2",
      "Depends on the compiler"
    ]
  },
  {
    "q": "Which class type cannot be instantiated directly?",
    "o": [
      "Abstract class",
      "Concrete class",
      "Derived class",
      "Static class"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "class Shape {\npublic:\n    virtual void draw() = 0;\n};\nclass Circle : public Shape {\npublic:\n    void draw() override { cout << \"Drawing Circle\"; }\n};\nint main() {\n    Circle c;\n    c.draw();\n}",
    "o": [
      "Drawing Circle",
      "Drawing Shape",
      "Compile error",
      "Runtime error"
    ]
  },
  {
    "q": "What is the correct term for a class that has at least one pure virtual function?",
    "o": [
      "Abstract class",
      "Interface",
      "Virtual class",
      "Template class"
    ]
  },
  {
    "q": "What will happen if a derived class does not override a pure virtual function?",
    "o": [
      "It also becomes abstract",
      "It will run with base version",
      "Compile-time polymorphism will be used",
      "It will crash at runtime"
    ]
  },
  {
    "q": "Which of the following is NOT a form of polymorphism in C++?",
    "o": [
      "Constructor overloading",
      "Function overloading",
      "Virtual function overriding",
      "Inheritance chaining"
    ]
  },
  {
    "q": "Which feature in C++ enables multiple functions to have the same name with different parameter types?",
    "o": [
      "Function overloading",
      "Function overriding",
      "Virtual functions",
      "Templates"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "class Demo {\npublic:\n    int operator+(int val) { return val + 10; }\n};\nint main() {\n    Demo d;\n    cout << (d + 5);\n}",
    "o": [
      "15",
      "10",
      "Compile error",
      "Runtime error"
    ]
  },
  {
    "q": "Which keyword in C++ is used to support runtime polymorphism?",
    "o": [
      "virtual",
      "override",
      "friend",
      "static"
    ]
  },
  {
    "q": "What is the purpose of vtables in C++?",
    "o": [
      "To support dynamic dispatch of virtual functions",
      "To manage memory allocation",
      "To store overloaded functions",
      "To enable template instantiation"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "class Base {\npublic:\n    virtual void fun() { cout << \"Base\"; }\n};\nclass Derived : public Base {};\nint main() {\n    Derived d;\n    d.fun();\n}",
    "o": [
      "Base",
      "Derived",
      "Compile error",
      "fun"
    ]
  },
  {
    "q": "Which of the following is true about pure virtual functions?",
    "o": [
      "They must be overridden in derived classes to create concrete objects",
      "They provide default implementation in base class",
      "They can be called directly using class name",
      "They cannot be declared in abstract classes"
    ]
  },
  {
    "q": "What is the correct syntax to declare a pure virtual function?",
    "o": [
      "virtual void display() = 0;",
      "virtual void display(); = 0",
      "pure virtual void display();",
      "void display() pure;"
    ]
  },
  {
    "q": "Which scenario best demonstrates runtime polymorphism?",
    "o": [
      "Calling a derived class's overridden method through a base class pointer",
      "Using overloaded constructors in a class",
      "Declaring functions with different return types",
      "Using inline functions in multiple classes"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "class Animal {\npublic:\n    virtual void sound() { cout << \"Some sound\"; }\n};\nclass Dog : public Animal {\npublic:\n    void sound() override { cout << \"Bark\"; }\n};\nint main() {\n    Animal* a = new Dog();\n    a->sound();\n}",
    "o": [
      "Bark",
      "Some sound",
      "Dog",
      "Animal"
    ]
  },
  {
    "q": "When is the vptr (virtual pointer) typically initialized in C++?",
    "o": [
      "During object construction",
      "At compile time",
      "During object destruction",
      "When the virtual function is called"
    ]
  },
  {
    "q": "Which of the following best describes operator overloading in C++?",
    "o": [
      "Defining a new meaning for an existing operator",
      "Changing the number of parameters in a function",
      "Using the same operator in different scopes",
      "Overriding virtual functions"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "class A {\npublic:\n    void show(int x) { cout << \"int\"; }\n    void show(double y) { cout << \"double\"; }\n};\nint main() {\n    A obj;\n    obj.show(3.14);\n}",
    "o": [
      "double",
      "int",
      "Compile-time error",
      "Runtime error"
    ]
  },
  {
    "q": "Which of the following is true about runtime polymorphism?",
    "o": [
      "It occurs when a base class pointer refers to a derived class object with virtual functions",
      "It is resolved at compile time",
      "It is only possible with function overloading",
      "It doesn't use inheritance"
    ]
  },
  {
    "q": "How many vptrs are created for a class that has virtual functions?",
    "o": [
      "One per object",
      "One per class",
      "One per function",
      "None"
    ]
  },
  {
    "q": "Which of the following makes a class abstract in C++?",
    "o": [
      "Having at least one pure virtual function",
      "Declaring the class with keyword 'abstract'",
      "Using virtual destructor",
      "Overloading the assignment operator"
    ]
  },
  {
    "q": "What will be printed by this code?",
    "c": "class Base {\npublic:\n    virtual void fun() { cout << \"Base::fun\"; }\n};\nclass Derived : public Base {\npublic:\n    void fun() { cout << \"Derived::fun\"; }\n};\nint main() {\n    Base *b = new Derived;\n    b->fun();\n}",
    "o": [
      "Derived::fun",
      "Base::fun",
      "Compile-time error",
      "Segmentation fault"
    ]
  },
  {
    "q": "Which of the following is an example of compile-time polymorphism?",
    "o": [
      "Function overloading",
      "Virtual function",
      "Pure virtual function",
      "Dynamic cast"
    ]
  },
  {
    "q": "What does a virtual table (vtable) contain?",
    "o": [
      "Pointers to virtual functions of a class",
      "Values of data members",
      "Memory addresses of objects",
      "File descriptors"
    ]
  },
  {
    "q": "What is the significance of the ‘override’ keyword in C++?",
    "o": [
      "It ensures a base class virtual function is being overridden",
      "It marks a function as virtual",
      "It makes a function pure virtual",
      "It disables polymorphism"
    ]
  },
  {
    "q": "What is the result of trying to instantiate an abstract class?",
    "o": [
      "Compilation error",
      "Runtime error",
      "It creates a base object",
      "It skips the constructor"
    ]
  },
  {
    "q": "Which of the following is necessary to achieve runtime polymorphism?",
    "o": [
      "A base class with at least one virtual function",
      "Overloading a function name in the same class",
      "Using a template function",
      "Multiple constructors in a class"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "class A {\npublic:\n    void print() { cout << \"A\"; }\n};\nclass B : public A {\npublic:\n    void print() { cout << \"B\"; }\n};\nint main() {\n    A* ptr = new B();\n    ptr->print();\n}",
    "o": [
      "A",
      "B",
      "AB",
      "Compile-time error"
    ]
  },
  {
    "q": "How can we make a function pure virtual in C++?",
    "o": [
      "By assigning 0 to a virtual function declaration",
      "By using the 'abstract' keyword",
      "By declaring a function without a body",
      "By using override specifier"
    ]
  },
  {
    "q": "What will be the output?",
    "c": "class Base {\npublic:\n    virtual void show() { cout << \"Base\"; }\n};\nclass Derived : public Base {};\nint main() {\n    Base* b = new Derived();\n    b->show();\n}",
    "o": [
      "Base",
      "Derived",
      "Compile-time error",
      "Segmentation fault"
    ]
  },
  {
    "q": "Which concept allows multiple functions with the same name but different signatures?",
    "o": [
      "Function Overloading",
      "Function Overriding",
      "Virtual Functions",
      "Dynamic Binding"
    ]
  },
  {
    "q": "What is the role of the vptr in C++?",
    "o": [
      "It points to the virtual table of the class",
      "It points to the memory address of base class",
      "It points to class constructor",
      "It holds the object size"
    ]
  },
  {
    "q": "What happens when a class contains only pure virtual functions?",
    "o": [
      "It becomes an abstract class",
      "It can't inherit from any class",
      "It is compiled as a struct",
      "It becomes a friend class"
    ]
  },
  {
    "q": "Choose the correct statement about operator overloading.",
    "o": [
      "It allows redefining operators for user-defined types",
      "It modifies how built-in operators work on primitive types",
      "It removes type safety",
      "It disables encapsulation"
    ]
  },
  {
    "q": "What happens if a derived class does not override a pure virtual function?",
    "o": [
      "The derived class also becomes abstract",
      "The base class is deleted",
      "The program throws a runtime exception",
      "It calls the base class function"
    ]
  },
  {
    "q": "Which of the following best describes virtual functions?",
    "o": [
      "They enable runtime polymorphism",
      "They are resolved at compile time",
      "They are faster than inline functions",
      "They are used only for operator overloading"
    ]
  },
  {
    "q": "Which of the following is an example of compile-time polymorphism in C++?",
    "o": [
      "Function overloading",
      "Virtual functions",
      "Inheritance",
      "Abstract class"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "class A {\npublic:\n    virtual void show() { cout << \"A\"; }\n};\nclass B : public A {\npublic:\n    void show() override { cout << \"B\"; }\n};\nint main() {\n    A* a = new B();\n    a->show();\n}",
    "o": [
      "B",
      "A",
      "AB",
      "Compilation Error"
    ]
  },
  {
    "q": "Which keyword is used to create a runtime polymorphic function?",
    "o": [
      "virtual",
      "static",
      "inline",
      "friend"
    ]
  },
  {
    "q": "Which of the following best describes the function of a virtual table (vtable)?",
    "o": [
      "It stores addresses of virtual functions",
      "It holds class data members",
      "It maintains constructor lists",
      "It links overloaded functions"
    ]
  },
  {
    "q": "What is the result of defining a pure virtual function in a class?",
    "o": [
      "The class becomes abstract",
      "It throws a compile-time error",
      "It overrides the base class constructor",
      "The function executes at compile time"
    ]
  },
  {
    "q": "What will be printed by this code?",
    "c": "class Shape {\npublic:\n    virtual void draw() = 0;\n};\nclass Circle : public Shape {\npublic:\n    void draw() { cout << \"Circle\"; }\n};\nint main() {\n    Shape* s = new Circle();\n    s->draw();\n}",
    "o": [
      "Circle",
      "Shape",
      "draw",
      "Compilation Error"
    ]
  },
  {
    "q": "What is required for operator overloading in C++?",
    "o": [
      "Overloaded operator must be defined as a function",
      "The operator must be a built-in type",
      "Only arithmetic operators can be overloaded",
      "Operator overloading is not allowed"
    ]
  },
  {
    "q": "Which of the following will make a class abstract in C++?",
    "o": [
      "At least one pure virtual function",
      "No constructor defined",
      "Function overloading",
      "Private data members"
    ]
  },
  {
    "q": "What is the use of 'override' keyword in C++?",
    "o": [
      "It explicitly specifies that a virtual function is overridden",
      "It allows function overloading",
      "It defines a friend function",
      "It makes the class final"
    ]
  },
  {
    "q": "How does C++ resolve function calls in case of virtual functions?",
    "o": [
      "Using the vtable at runtime",
      "Using function signature at compile time",
      "By default constructor",
      "Using inline substitution"
    ]
  },
  {
    "q": "Which of the following represents function overloading in C++?",
    "c": "int add(int a, int b) { return a + b; }\ndouble add(double a, double b) { return a + b; }",
    "o": [
      "Two functions with the same name but different parameter types",
      "Two functions with the same return type",
      "Two functions inside different classes",
      "Two functions using inheritance"
    ]
  },
  {
    "q": "Which feature is required for runtime polymorphism to work correctly?",
    "o": [
      "Base class pointer to derived class object",
      "Function overloading",
      "Operator overloading",
      "Constructor overloading"
    ]
  },
  {
    "q": "What happens if a class has a pure virtual function?",
    "o": [
      "It cannot be instantiated directly",
      "It causes a segmentation fault",
      "All members must be static",
      "It must not be inherited"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "class A {\npublic:\n    virtual void show() { cout << \"A\"; }\n};\nclass B : public A {\npublic:\n    void show() { cout << \"B\"; }\n};\nint main() {\n    B b;\n    A &ref = b;\n    ref.show();\n}",
    "o": [
      "B",
      "A",
      "AB",
      "Compilation Error"
    ]
  },
  {
    "q": "Which of the following is NOT true about virtual functions?",
    "o": [
      "They must be member functions",
      "They enable dynamic dispatch",
      "They can be static",
      "They can be overridden in derived classes"
    ]
  },
  {
    "q": "Which of the following is associated with dynamic dispatch?",
    "o": [
      "vtable and vptr",
      "function templates",
      "inline functions",
      "friend functions"
    ]
  },
  {
    "q": "What is operator overloading in C++?",
    "o": [
      "Redefining the behavior of an operator for user-defined types",
      "Overloading function parameters",
      "Using multiple inheritance",
      "Calling base class operators"
    ]
  },
  {
    "q": "Which of the following must be implemented by all derived classes of an abstract class?",
    "o": [
      "All pure virtual functions",
      "Constructors",
      "Friend functions",
      "Private members"
    ]
  },
  {
    "q": "What is the purpose of a virtual destructor?",
    "o": [
      "To ensure proper cleanup of derived class resources",
      "To call base class constructors",
      "To overload the delete operator",
      "To make a class abstract"
    ]
  },
  {
    "q": "What does the compiler generate for a class with virtual functions?",
    "o": [
      "A vtable and a vptr",
      "An inline lookup table",
      "Multiple function templates",
      "An overloaded constructor"
    ]
  },
  {
    "q": "Which concept allows multiple functions with the same name to exist in C++?",
    "o": [
      "Function overloading",
      "Virtual functions",
      "Abstract classes",
      "Inheritance"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "class A {\npublic:\n    virtual void print() { cout << \"A\"; }\n};\nclass B : public A {\npublic:\n    void print() override { cout << \"B\"; }\n};\nint main() {\n    A *a = new B();\n    a->print();\n    delete a;\n}",
    "o": [
      "B",
      "A",
      "AB",
      "Runtime Error"
    ]
  },
  {
    "q": "Which of these is required for operator overloading?",
    "o": [
      "A user-defined data type",
      "A constructor",
      "A template",
      "A friend function"
    ]
  },
  {
    "q": "What will happen if a class has at least one pure virtual function?",
    "o": [
      "It becomes an abstract class",
      "It cannot have constructors",
      "It must have only static functions",
      "It cannot have any member variables"
    ]
  },
  {
    "q": "What is a vptr?",
    "o": [
      "A hidden pointer maintained by the compiler to point to the vtable",
      "A pointer to a virtual function",
      "A reference to the base class",
      "A user-defined pointer in main"
    ]
  },
  {
    "q": "Which statement best describes virtual functions in C++?",
    "o": [
      "They enable runtime polymorphism using base class pointers",
      "They are executed at compile time",
      "They are used for multiple inheritance",
      "They can be friend functions"
    ]
  },
  {
    "q": "Identify the correct overloaded operator function:",
    "c": "class Complex {\npublic:\n    Complex operator+(const Complex& obj);\n};",
    "o": [
      "Complex operator+(const Complex& obj);",
      "Complex +operator(const Complex& obj);",
      "Complex operator+(Complex obj) const;",
      "Complex add(Complex obj);"
    ]
  },
  {
    "q": "Which of the following is a characteristic of a pure virtual function?",
    "o": [
      "It is defined with '= 0' in the base class",
      "It has no return type",
      "It cannot be inherited",
      "It must be static"
    ]
  },
  {
    "q": "What does the vtable hold?",
    "o": [
      "Pointers to virtual functions of a class",
      "Names of all classes",
      "Function arguments",
      "Return types of functions"
    ]
  },
  {
    "q": "Which of the following allows the same operator to behave differently depending on operands?",
    "o": [
      "Operator overloading",
      "Inheritance",
      "Function templates",
      "Type casting"
    ]
  }
]