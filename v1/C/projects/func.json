[
  {
    "title": "Function Declaration and Definition",
    "ques": "Write a C program to declare and define a function that calculates the area of a rectangle. The function should take length and width as parameters and return the area. Demonstrate the use of function declaration before main() and definition after main().",
    "answer": {
      "type": "code",
      "lang": "c",
      "content": "#include <stdio.h>\n\n// Function declaration\nfloat calculateArea(float length, float width);\n\nint main() {\n    float length = 5.5, width = 3.2;\n    float area = calculateArea(length, width);\n    printf(\"Area of rectangle: %.2f\\n\", area);\n    return 0;\n}\n\n// Function definition\nfloat calculateArea(float length, float width) {\n    return length * width;\n}"
    },
    "explanation": "Let’s break down the code step-by-step:\n\n1. ***#include <stdio.h>***: This includes the standard input-output library for using `printf`.\n2. ***float calculateArea(float length, float width);***: This is the **function declaration**. It tells the compiler about the function’s name, return type (`float`), and parameters (`length` and `width`, both `float`) before it’s used in `main()`.\n3. ***int main()***: The main function where program execution begins.\n4. ***float length = 5.5, width = 3.2;***: Declares and initializes two variables for the rectangle’s dimensions.\n5. ***float area = calculateArea(length, width);***: Calls the `calculateArea` function with `length` and `width` as arguments and stores the returned value in `area`.\n6. ***printf(\"Area of rectangle: %.2f\\n\", area);***: Prints the area with 2 decimal places.\n7. ***float calculateArea(float length, float width)***: The **function definition**. It takes two `float` parameters and returns their product using the `*` operator.\n8. ***return length * width;***: Computes and returns the area as a `float`.\n\nThis demonstrates separating declaration (before `main`) and definition (after `main`) for clarity and proper compilation."
  },
  {
    "title": "Call by Value vs Call by Reference",
    "ques": "Create a C program with two functions: one that attempts to swap two integers using call by value, and another that successfully swaps them using call by reference with pointers. Explain the difference in behavior.",
    "answer": {
      "type": "code",
      "lang": "c",
      "content": "#include <stdio.h>\n\nvoid swapByValue(int a, int b);\nvoid swapByReference(int *a, int *b);\n\nint main() {\n    int x = 10, y = 20;\n    printf(\"Before swap by value: x = %d, y = %d\\n\", x, y);\n    swapByValue(x, y);\n    printf(\"After swap by value: x = %d, y = %d\\n\", x, y);\n    printf(\"Before swap by reference: x = %d, y = %d\\n\", x, y);\n    swapByReference(&x, &y);\n    printf(\"After swap by reference: x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n\nvoid swapByValue(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n}\n\nvoid swapByReference(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}"
    },
    "explanation": "Here’s the detailed explanation:\n\n1. ***void swapByValue(int a, int b);***: Declares a function that uses **call by value**. Parameters `a` and `b` are copies of the original values.\n2. ***void swapByReference(int *a, int *b);***: Declares a function that uses **call by reference** with pointers, allowing direct memory access.\n3. ***int x = 10, y = 20;***: Initializes two integers in `main()`.\n4. ***swapByValue(x, y);***: Calls the first function. Inside it:\n   - ```int temp = a; a = b; b = temp;``` swaps the local copies, but this doesn’t affect `x` and `y` in `main()` because only values were passed.\n5. ***After swap by value: x = 10, y = 20***: Output shows no change, proving call by value doesn’t modify original variables.\n6. ***swapByReference(&x, &y);***: Passes the addresses of `x` and `y` using the `&` operator.\n7. Inside ***swapByReference***:\n   - ```int temp = *a;``` stores the value at address `a` (i.e., `x`).\n   - ```*a = *b; *b = temp;``` swaps the values at the addresses, directly modifying `x` and `y`.\n8. ***After swap by reference: x = 20, y = 10***: Output confirms the swap worked.\n\n**Key Difference**: Call by value works on copies, leaving originals unchanged, while call by reference modifies the originals via pointers."
  },
  {
    "title": "Recursion",
    "ques": "Write a C program to calculate the factorial of a number using recursion. Include a base case to prevent infinite recursion, and demonstrate the function with an example input of 5.",
    "answer": {
      "type": "code",
      "lang": "c",
      "content": "#include <stdio.h>\n\nunsigned long long factorial(int n);\n\nint main() {\n    int num = 5;\n    unsigned long long result = factorial(num);\n    printf(\"Factorial of %d = %llu\\n\", num, result);\n    return 0;\n}\n\nunsigned long long factorial(int n) {\n    if (n == 0 || n == 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}"
    },
    "explanation": "Let’s analyze the code:\n\n1. ***unsigned long long factorial(int n);***: Declares a recursive function returning an `unsigned long long` to handle large factorial values.\n2. ***int num = 5;***: Sets the input number in `main()`.\n3. ***unsigned long long result = factorial(num);***: Calls the recursive function and stores the result.\n4. Inside ***factorial***:\n   - ***if (n == 0 || n == 1) { return 1; }***: The **base case**. Factorial of 0 or 1 is 1, stopping recursion.\n   - ***return n * factorial(n - 1);***: The **recursive case**. It multiplies `n` by the factorial of `n-1`, calling itself with a decremented value.\n5. For `n = 5`:\n   - `factorial(5) = 5 * factorial(4)`\n   - `factorial(4) = 4 * factorial(3)`\n   - `factorial(3) = 3 * factorial(2)`\n   - `factorial(2) = 2 * factorial(1)`\n   - `factorial(1) = 1` (base case)\n   - Unwinds: `2 * 1 = 2`, `3 * 2 = 6`, `4 * 6 = 24`, `5 * 24 = 120`.\n6. ***printf(\"Factorial of %d = %llu\\n\", num, result);***: Prints `Factorial of 5 = 120`.\n\nRecursion simplifies the factorial calculation but requires a base case to avoid infinite calls."
  },
  {
    "title": "Scope and Storage Classes",
    "ques": "Write a C program to demonstrate the use of different storage classes (auto, static, and extern) in functions. Create a function that counts how many times it’s called, and show how variable scope affects the output.",
    "answer": {
      "type": "code",
      "lang": "c",
      "content": "#include <stdio.h>\n\nint globalVar = 0; // extern storage class by default\n\nvoid countCalls();\n\nint main() {\n    auto int localVar = 10; // auto storage class\n    printf(\"Local auto variable: %d\\n\", localVar);\n    countCalls();\n    countCalls();\n    countCalls();\n    printf(\"Global extern variable: %d\\n\", globalVar);\n    return 0;\n}\n\nvoid countCalls() {\n    static int callCount = 0; // static storage class\n    callCount++;\n    globalVar++;\n    printf(\"Function called %d times, globalVar = %d\\n\", callCount, globalVar);\n}"
    },
    "explanation": "Here’s the breakdown:\n\n1. ***int globalVar = 0;***: A global variable with **extern** storage class (implicitly), accessible across all functions, initialized once.\n2. ***void countCalls();***: Declares a function to track its calls.\n3. ***auto int localVar = 10;***: An **auto** variable in `main()`, local to its block, automatically allocated and deallocated.\n4. ***printf(\"Local auto variable: %d\\n\", localVar);***: Prints `10`, showing `localVar`’s scope is limited to `main()`.\n5. Inside ***countCalls***:\n   - ***static int callCount = 0;***: A **static** variable, initialized once and retains its value between calls.\n   - ***callCount++;***: Increments each time the function is called.\n   - ***globalVar++;***: Increments the global variable.\n   - ***printf(...);***: Outputs the call count and `globalVar`.\n6. Calling `countCalls()` three times:\n   - 1st: `callCount = 1`, `globalVar = 1`\n   - 2nd: `callCount = 2`, `globalVar = 2`\n   - 3rd: `callCount = 3`, `globalVar = 3`\n7. Final ***printf***: Shows `globalVar = 3` after modifications.\n\n**Key Points**: `auto` is local and temporary, `static` persists across calls, and `extern` allows global access."
  },
  {
    "title": "Function Pointers",
    "ques": "Write a C program that uses a function pointer to perform different arithmetic operations (addition and subtraction) on two integers. Declare a function pointer, assign it to different functions, and demonstrate its use with example inputs of 10 and 5.",
    "answer": {
      "type": "code",
      "lang": "c",
      "content": "#include <stdio.h>\n\nint add(int a, int b);\nint subtract(int a, int b);\n\nint main() {\n    int x = 10, y = 5;\n    int (*operation)(int, int); // Function pointer declaration\n\n    operation = add; // Assigning add function\n    printf(\"Addition: %d + %d = %d\\n\", x, y, operation(x, y));\n\n    operation = subtract; // Reassigning to subtract function\n    printf(\"Subtraction: %d - %d = %d\\n\", x, y, operation(x, y));\n\n    return 0;\n}\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint subtract(int a, int b) {\n    return a - b;\n}"
    },
    "explanation": "Let’s dive into the code:\n\n1. ***int add(int a, int b);*** and ***int subtract(int a, int b);***: Declare two simple functions for addition and subtraction.\n2. ***int (*operation)(int, int);***: Declares a **function pointer** named `operation`. The syntax `(*operation)` indicates it’s a pointer to a function that takes two `int` parameters and returns an `int`.\n3. ***int x = 10, y = 5;***: Initializes two integers to test the operations.\n4. ***operation = add;***: Assigns the address of the `add` function to the pointer. Note: No `&` is needed; the function name alone represents its address.\n5. ***printf(\"Addition: %d + %d = %d\\n\", x, y, operation(x, y));***: Calls the function via the pointer using `operation(x, y)`, which executes `add(10, 5)` and prints `15`.\n6. ***operation = subtract;***: Reassigns the pointer to the `subtract` function.\n7. ***printf(\"Subtraction: %d - %d = %d\\n\", x, y, operation(x, y));***: Calls `subtract(10, 5)` through the pointer, printing `5`.\n8. ***int add(int a, int b)*** and ***int subtract(int a, int b)***: Define the functions to return `a + b` and `a - b`, respectively.\n\n**Why it’s cool**: Function pointers allow dynamic function selection at runtime, making code flexible and reusable. Here, `operation` acts like a switchable tool for different tasks!"
  },
  {
    "title": "Passing Arrays to Functions",
    "ques": "Write a C program that defines a function to calculate the sum of elements in an integer array. Pass the array and its size to the function, and demonstrate its use with an example array {1, 2, 3, 4, 5}. Explain how the array is handled in the function.",
    "answer": {
      "type": "code",
      "lang": "c",
      "content": "#include <stdio.h>\n\nint sumArray(int arr[], int size);\n\nint main() {\n    int numbers[] = {1, 2, 3, 4, 5};\n    int size = 5;\n    int total = sumArray(numbers, size);\n    printf(\"Sum of array elements: %d\\n\", total);\n    return 0;\n}\n\nint sumArray(int arr[], int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += arr[i];\n    }\n    return sum;\n}"
    },
    "explanation": "Let’s break this down:\n\n1. ***int sumArray(int arr[], int size);***: Declares a function that takes an array `arr[]` and its `size` as parameters, returning an `int`. Note: `arr[]` is syntactic sugar; it’s actually a pointer to the first element.\n2. ***int numbers[] = {1, 2, 3, 4, 5};***: Defines and initializes an array in `main()` with 5 elements.\n3. ***int size = 5;***: Stores the array size, which must be passed explicitly because arrays decay to pointers when passed to functions, losing size information.\n4. ***int total = sumArray(numbers, size);***: Calls the function, passing the array and its size, and stores the returned sum.\n5. Inside ***sumArray***:\n   - ***int sum = 0;***: Initializes a variable to accumulate the sum.\n   - ***for (int i = 0; i < size; i++) { sum += arr[i]; }***: Loops through the array using the index `i`, adding each element to `sum`. Here, `arr[i]` accesses elements via pointer arithmetic internally.\n   - ***return sum;***: Returns the total, which is `1 + 2 + 3 + 4 + 5 = 15`.\n6. ***printf(\"Sum of array elements: %d\\n\", total);***: Outputs `Sum of array elements: 15`.\n\n**Key Insight**: When an array is passed to a function, it ‘decays’ to a pointer (e.g., `int*`), so the function doesn’t receive the array’s size. Passing `size` separately ensures the function knows how many elements to process. This is different from passing individual variables and highlights a unique aspect of function parameter handling in C."
  }
]