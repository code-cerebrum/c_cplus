[
  {
    "q": "Which of the following is the correct syntax for exception handling in C#?",
    "o": [
      "try { /* code */ } catch (Exception e) { /* handle */ } finally { /* cleanup */ }",
      "try (Exception e) { /* code */ } catch { /* handle */ } finally { /* cleanup */ }",
      "try { /* code */ } then { /* handle */ }",
      "try { /* code */ } handle (Exception e) { /* handle */ }"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "try {\n    int x = 10 / 0;\n    Console.WriteLine(\"No exception\");\n} catch (DivideByZeroException e) {\n    Console.WriteLine(\"Caught exception: \" + e.Message);\n} finally {\n    Console.WriteLine(\"Finally block executed\");\n}",
    "o": [
      "Caught exception: Attempted to divide by zero.\nFinally block executed",
      "No exception",
      "Finally block executed\nCaught exception: Attempted to divide by zero.",
      "Caught exception: System.Exception\nFinally block executed"
    ]
  },
  {
    "q": "Which of the following best describes the purpose of the `finally` block in C#?",
    "o": [
      "It always executes regardless of whether an exception occurs or not.",
      "It handles specific exceptions thrown in the try block.",
      "It is used to define custom exceptions.",
      "It skips execution if an exception is thrown."
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "try {\n    string str = null;\n    Console.WriteLine(str.Length);\n} catch (NullReferenceException) {\n    Console.WriteLine(\"Null reference caught\");\n} finally {\n    Console.WriteLine(\"Done\");\n}",
    "o": [
      "Null reference caught\nDone",
      "Done",
      "Null reference caught",
      "Exception not caught"
    ]
  },
  {
    "q": "How can you create a custom exception in C#?",
    "o": [
      "By creating a class that inherits from Exception",
      "By writing 'throw new CustomError();'",
      "By using the 'custom exception' keyword",
      "By overriding System.Exception directly"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "public class MyException : Exception {\n    public MyException(string message) : base(message) {}\n}\n\ntry {\n    throw new MyException(\"Custom error occurred\");\n} catch (MyException ex) {\n    Console.WriteLine(ex.Message);\n}",
    "o": [
      "Custom error occurred",
      "Unhandled Exception",
      "System.Exception",
      "Compilation error"
    ]
  },
  {
    "q": "Which keyword is used to manually raise an exception in C#?",
    "o": [
      "throw",
      "raise",
      "exception",
      "error"
    ]
  },
  {
    "q": "What is the purpose of the `checked` keyword in C#?",
    "o": [
      "It enables overflow checking for integral-type arithmetic operations and conversions.",
      "It checks for null values.",
      "It validates try-catch blocks at compile time.",
      "It disables exception handling."
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "int max = int.MaxValue;\ntry {\n    int result = checked(max + 1);\n    Console.WriteLine(result);\n} catch (OverflowException) {\n    Console.WriteLine(\"Overflow occurred\");\n}",
    "o": [
      "Overflow occurred",
      "2147483648",
      "-2147483648",
      "No output"
    ]
  },
  {
    "q": "Which of the following disables overflow checking in C#?",
    "o": [
      "unchecked",
      "try-catch",
      "ignore",
      "no-check"
    ]
  },
  {
    "q": "What will happen if an exception occurs inside a try block and there is no matching catch block?",
    "o": [
      "The exception will propagate up the call stack.",
      "The program will continue execution normally.",
      "The finally block will be skipped.",
      "The compiler will fix the error automatically."
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "try {\n    int[] arr = new int[2];\n    Console.WriteLine(arr[5]);\n} catch (IndexOutOfRangeException e) {\n    Console.WriteLine(\"Exception: \" + e.GetType());\n}",
    "o": [
      "Exception: System.IndexOutOfRangeException",
      "Exception: System.NullReferenceException",
      "Exception: System.Exception",
      "Exception: System.OverflowException"
    ]
  },
  {
    "q": "What is the purpose of the `throw` keyword in C#?",
    "o": [
      "To signal the occurrence of an exception during program execution.",
      "To define a custom exception class.",
      "To log errors to the console.",
      "To skip over a block of code if an error occurs."
    ]
  },
  {
    "q": "Which of the following is true about `finally` blocks in C#?",
    "o": [
      "They are always executed regardless of whether an exception is thrown or not.",
      "They only execute if a catch block handles the exception.",
      "They are optional and never execute if an exception occurs.",
      "They replace the need for catch blocks."
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "public class MyException : Exception {\n    public MyException() : base(\"This is a custom exception\") {}\n}\n\ntry {\n    throw new MyException();\n} catch (MyException ex) {\n    Console.WriteLine(ex.Message);\n}",
    "o": [
      "This is a custom exception",
      "Unhandled exception",
      "Exception occurred",
      "Compilation failed"
    ]
  },
  {
    "q": "Which of the following is used to handle arithmetic overflows at runtime?",
    "o": [
      "checked",
      "try",
      "unchecked",
      "overflow"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "int val = int.MaxValue;\nint result = unchecked(val + 1);\nConsole.WriteLine(result);",
    "o": [
      "-2147483648",
      "Overflow occurred",
      "2147483648",
      "Compilation error"
    ]
  },
  {
    "q": "How do you define a custom exception class in C#?",
    "o": [
      "By inheriting from the Exception base class",
      "By using the `exception` keyword",
      "By creating a struct and adding throw statements",
      "By marking a class with `[Exception]` attribute"
    ]
  },
  {
    "q": "What is the role of the `catch` block in exception handling?",
    "o": [
      "To handle specific exceptions thrown in the try block",
      "To ensure code is always executed after try",
      "To declare a custom exception",
      "To wrap code that may produce compile-time errors"
    ]
  },
  {
    "q": "What will be printed?",
    "c": "try {\n    int result = checked(1000000 * 1000000);\n    Console.WriteLine(result);\n} catch (OverflowException) {\n    Console.WriteLine(\"Overflow detected\");\n}",
    "o": [
      "Overflow detected",
      "1000000000000",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which part of the exception handling structure is guaranteed to execute?",
    "o": [
      "finally",
      "catch",
      "throw",
      "error"
    ]
  },
  {
    "q": "What does the following C# code output?",
    "c": "try {\n    Console.WriteLine(\"Try block\");\n    return;\n} catch {\n    Console.WriteLine(\"Catch block\");\n} finally {\n    Console.WriteLine(\"Finally block\");\n}",
    "o": [
      "Try block\nFinally block",
      "Try block\nCatch block",
      "Catch block\nFinally block",
      "Finally block"
    ]
  },
  {
    "q": "What happens if you use 'throw;' without specifying an exception in a catch block?",
    "o": [
      "It rethrows the currently caught exception.",
      "It throws a new general exception.",
      "It compiles but does nothing.",
      "It throws null reference exception."
    ]
  },
  {
    "q": "What will be the output?",
    "c": "try {\n    int x = 100;\n    int y = 0;\n    int z = x / y;\n} catch (DivideByZeroException ex) {\n    Console.WriteLine(\"Error: \" + ex.GetType());\n} finally {\n    Console.WriteLine(\"Cleaning up...\");\n}",
    "o": [
      "Error: System.DivideByZeroException\nCleaning up...",
      "Error: System.NullReferenceException\nCleaning up...",
      "Cleaning up...",
      "No output"
    ]
  },
  {
    "q": "Which of the following best explains the use of 'unchecked' in C#?",
    "o": [
      "It disables overflow checking for integral-type operations.",
      "It checks whether an exception has been caught.",
      "It validates exceptions at compile time.",
      "It skips the try-catch block during execution."
    ]
  },
  {
    "q": "What is true about creating a custom exception in C#?",
    "o": [
      "You should inherit from System.Exception.",
      "You must use the keyword `custom`.",
      "You should override Console.WriteLine().",
      "Custom exceptions cannot contain constructors."
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "public class MyError : Exception {}\n\ntry {\n    throw new MyError();\n} catch (Exception e) {\n    Console.WriteLine(\"Caught: \" + e.GetType().Name);\n}",
    "o": [
      "Caught: MyError",
      "Caught: Exception",
      "MyError",
      "No output"
    ]
  },
  {
    "q": "Why is it a good practice to rethrow exceptions with `throw;` instead of `throw ex;`?",
    "o": [
      "Because `throw;` preserves the original stack trace.",
      "Because `throw ex;` is illegal in C#.",
      "Because `throw;` is faster in performance.",
      "Because `throw ex;` only works with built-in exceptions."
    ]
  },
  {
    "q": "Which of the following keywords is used to define that a method might throw an exception?",
    "o": [
      "throw",
      "throws",
      "raise",
      "catch"
    ]
  },
  {
    "q": "What is the output of this snippet?",
    "c": "int x = int.MaxValue;\nint y;\ntry {\n    y = checked(x + 10);\n    Console.WriteLine(\"Result: \" + y);\n} catch (OverflowException) {\n    Console.WriteLine(\"Overflow caught\");\n}",
    "o": [
      "Overflow caught",
      "Result: 2147483657",
      "Compilation error",
      "Result: -2147483649"
    ]
  },
  {
    "q": "What is the correct order of execution in a try-catch-finally block when no exception is thrown?",
    "o": [
      "try → finally",
      "try → catch → finally",
      "catch → try → finally",
      "finally → try → catch"
    ]
  },
  {
    "q": "Which of the following correctly throws an exception in C#?",
    "o": [
      "throw new Exception(\"Something went wrong\");",
      "raise Exception(\"Error\");",
      "Exception(\"Error\") throw;",
      "new Exception(\"Error\").throw();"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "try {\n    throw new InvalidOperationException(\"Invalid!\");\n} catch (InvalidOperationException ex) {\n    Console.WriteLine(\"Caught: \" + ex.Message);\n} finally {\n    Console.WriteLine(\"Done\");\n}",
    "o": [
      "Caught: Invalid!\nDone",
      "Caught: System.Exception\nDone",
      "Done",
      "Caught: Invalid!\n"
    ]
  },
  {
    "q": "What is the role of the `base` keyword in custom exception classes?",
    "o": [
      "It passes the error message to the base Exception class.",
      "It suppresses base class behavior.",
      "It overrides the default exception handling.",
      "It removes the stack trace from output."
    ]
  },
  {
    "q": "How many `catch` blocks can be used with one `try` block?",
    "o": [
      "Multiple",
      "Only one",
      "Zero",
      "Exactly two"
    ]
  },
  {
    "q": "What will the following code display?",
    "c": "int val = int.MaxValue;\ntry {\n    int result = checked(val + 100);\n    Console.WriteLine(result);\n} catch (OverflowException) {\n    Console.WriteLine(\"Caught overflow\");\n}",
    "o": [
      "Caught overflow",
      "2147483747",
      "0",
      "No output"
    ]
  },
  {
    "q": "Which statement about the `unchecked` context is true?",
    "o": [
      "It allows arithmetic overflow without throwing exceptions.",
      "It prevents runtime exceptions in all scenarios.",
      "It checks for runtime exceptions explicitly.",
      "It disables all exception handling."
    ]
  },
  {
    "q": "Which of the following correctly defines a custom exception in C#?",
    "o": [
      "public class MyException : Exception { }",
      "public class MyException inherits Exception { }",
      "exception MyException : base {}",
      "public exception MyException {}"
    ]
  },
  {
    "q": "Which keyword is used to catch any exception type?",
    "o": [
      "catch",
      "try",
      "throws",
      "checked"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "try {\n    Console.WriteLine(\"Start\");\n    throw new Exception();\n} finally {\n    Console.WriteLine(\"Cleanup\");\n}",
    "o": [
      "Start\nCleanup",
      "Start",
      "Exception",
      "Cleanup"
    ]
  },
  {
    "q": "What happens if an exception is thrown inside a catch block?",
    "o": [
      "It can be caught by another surrounding try-catch block.",
      "It is ignored and execution continues.",
      "The program terminates immediately.",
      "The finally block is skipped."
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "try {\n    int a = 10;\n    int b = 0;\n    Console.WriteLine(a / b);\n} catch (DivideByZeroException) {\n    Console.WriteLine(\"Cannot divide by zero\");\n} finally {\n    Console.WriteLine(\"Program ended\");\n}",
    "o": [
      "Cannot divide by zero\nProgram ended",
      "Program ended",
      "Cannot divide by zero",
      "Exception occurred"
    ]
  },
  {
    "q": "What does the `finally` block do if an exception is thrown but not caught?",
    "o": [
      "It still executes before the program terminates.",
      "It is skipped entirely.",
      "It runs only if there's no exception.",
      "It handles uncaught exceptions."
    ]
  },
  {
    "q": "Which of the following correctly throws a custom exception?",
    "o": [
      "throw new MyCustomException(\"Custom error\");",
      "throw MyCustomException(\"Custom error\");",
      "MyCustomException throw(\"Custom error\");",
      "raise new MyCustomException(\"Custom error\");"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "checked {\n    int x = int.MaxValue;\n    x++;\n    Console.WriteLine(x);\n}",
    "o": [
      "It throws an OverflowException.",
      "It prints a negative number.",
      "It prints 0.",
      "It throws a DivideByZeroException."
    ]
  },
  {
    "q": "How can you define a custom exception with a message?",
    "o": [
      "public class MyException : Exception {\n    public MyException(string msg) : base(msg) {}\n}",
      "public class MyException : base Exception {\n    MyException(msg) {}\n}",
      "custom exception MyException(string msg) {}\n",
      "public MyException inherits Exception(string msg) {}"
    ]
  },
  {
    "q": "What happens if you put a return statement in a try block?",
    "o": [
      "The finally block still executes before returning.",
      "The finally block is skipped.",
      "The catch block executes after return.",
      "The program crashes."
    ]
  },
  {
    "q": "Which of the following is used to disable overflow checks in arithmetic operations?",
    "o": [
      "unchecked",
      "try",
      "throw",
      "final"
    ]
  },
  {
    "q": "Which block is optional in a try-catch-finally structure?",
    "o": [
      "catch",
      "try",
      "finally",
      "All blocks are required"
    ]
  },
  {
    "q": "What will be the output?",
    "c": "try {\n    Console.WriteLine(\"Start\");\n    throw new Exception();\n    Console.WriteLine(\"End\");\n} catch {\n    Console.WriteLine(\"Error caught\");\n}",
    "o": [
      "Start\nError caught",
      "Start\nEnd\nError caught",
      "Error caught\nEnd",
      "End\nStart"
    ]
  },
  {
    "q": "Which of the following correctly demonstrates the use of the 'finally' block?",
    "c": "try {\n    // Code that may throw an exception\n} catch (Exception ex) {\n    Console.WriteLine(ex.Message);\n} finally {\n    Console.WriteLine(\"This always runs.\");\n}",
    "o": [
      "The 'finally' block executes regardless of whether an exception was thrown.",
      "The 'finally' block executes only if no exception is thrown.",
      "The 'finally' block only runs if an exception is caught.",
      "The 'finally' block must come before the catch block."
    ]
  },
  {
    "q": "Which keyword is used to throw an exception manually in C#?",
    "o": [
      "throw",
      "raise",
      "raiseException",
      "except"
    ]
  },
  {
    "q": "What is the main purpose of a custom exception class?",
    "o": [
      "To create more meaningful and specific error types for your application",
      "To replace built-in exceptions",
      "To automatically handle system-level errors",
      "To bypass the try-catch structure"
    ]
  },
  {
    "q": "What will happen when the following code is executed?",
    "c": "checked {\n    int a = int.MaxValue;\n    a++;\n    Console.WriteLine(a);\n}",
    "o": [
      "An OverflowException is thrown.",
      "The program crashes without an error.",
      "It wraps around to int.MinValue silently.",
      "Nothing happens; it prints int.MaxValue."
    ]
  },
  {
    "q": "Which of the following is NOT a correct feature of the 'try' block in C#?",
    "o": [
      "It can exist without a catch block only if a finally block is present.",
      "It must be followed by either a catch or a finally block.",
      "It catches and handles exceptions directly.",
      "It can be nested inside another try block."
    ]
  },
  {
    "q": "How would you declare and use a custom exception class called 'InvalidUserInputException'?",
    "c": "public class InvalidUserInputException : Exception {\n    public InvalidUserInputException(string message) : base(message) {}\n}\n\n// Usage\nthrow new InvalidUserInputException(\"Input cannot be negative\");",
    "o": [
      "This correctly declares and throws a custom exception.",
      "This will cause a compile-time error.",
      "You cannot inherit from Exception directly.",
      "You must override the Message property first."
    ]
  },
  {
    "q": "When should you use 'unchecked' in C#?",
    "o": [
      "To suppress overflow-checking for arithmetic operations",
      "To enable error reporting in mathematical expressions",
      "To prevent syntax errors in try blocks",
      "To auto-correct invalid values"
    ]
  },
  {
    "q": "Which of the following is true about nested try-catch blocks?",
    "o": [
      "They allow fine-grained error handling within broader exception scopes.",
      "They are not allowed in C#.",
      "Only one try-catch block is permitted per method.",
      "Nested try blocks must be labeled."
    ]
  },
  {
    "q": "What is a common use-case for a 'finally' block?",
    "o": [
      "To release resources like files or database connections",
      "To display error messages",
      "To define new exceptions",
      "To suppress runtime exceptions"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "try {\n    Console.WriteLine(\"Start\");\n    throw new Exception(\"Oops!\");\n} catch (Exception e) {\n    Console.WriteLine(\"Caught: \" + e.Message);\n} finally {\n    Console.WriteLine(\"Finally block executed\");\n}",
    "o": [
      "Start\nCaught: Oops!\nFinally block executed",
      "Caught: Oops!\nFinally block executed",
      "Start\nFinally block executed",
      "Start\nCaught: Oops!"
    ]
  },
  {
    "q": "What is the purpose of the 'catch' block in exception handling in C#?",
    "o": [
      "To handle exceptions thrown in the try block",
      "To ignore the error and continue execution",
      "To log information before the exception occurs",
      "To finally close resources"
    ]
  },
  {
    "q": "Which of the following code snippets correctly demonstrates throwing an exception with a custom message?",
    "c": "throw new Exception(\"Something went wrong!\");",
    "o": [
      "This throws a generic exception with a custom message.",
      "This throws a compile-time error.",
      "This will not work unless in a catch block.",
      "This syntax is only valid in Java."
    ]
  },
  {
    "q": "In which scenario is the 'finally' block NOT guaranteed to execute?",
    "o": [
      "When the process is terminated abruptly (e.g., Environment.Exit or system crash)",
      "When an exception is thrown",
      "When no exception occurs",
      "When a return statement is used in the try block"
    ]
  },
  {
    "q": "Which statement is true about using 'checked' in C#?",
    "o": [
      "It enables overflow checking for integral-type arithmetic operations.",
      "It disables runtime exceptions during calculations.",
      "It is used to check null references.",
      "It is applicable to floating-point operations only."
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "try {\n    int x = 0;\n    int y = 10 / x;\n} catch (DivideByZeroException) {\n    Console.WriteLine(\"Cannot divide by zero.\");\n}",
    "o": [
      "Cannot divide by zero.",
      "Compilation error",
      "Program crashes",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following correctly defines a custom exception class?",
    "c": "public class DataNotFoundException : Exception {\n    public DataNotFoundException(string message) : base(message) {}\n}",
    "o": [
      "This is a valid custom exception definition.",
      "You must inherit from SystemError, not Exception.",
      "Custom exceptions must override ToString().",
      "Exception classes cannot have constructors."
    ]
  },
  {
    "q": "What is the purpose of the 'throw;' statement without an exception object?",
    "o": [
      "To re-throw the current exception in a catch block",
      "To throw a NullReferenceException",
      "To suppress exception handling",
      "To throw a new exception randomly"
    ]
  },
  {
    "q": "What does this code demonstrate?",
    "c": "unchecked {\n    int max = int.MaxValue;\n    int result = max + 1;\n    Console.WriteLine(result);\n}",
    "o": [
      "It performs arithmetic overflow without throwing an exception.",
      "It throws an OverflowException.",
      "It results in a syntax error.",
      "It prints int.MaxValue."
    ]
  },
  {
    "q": "Which of the following is true about defining multiple catch blocks?",
    "o": [
      "They allow handling different exception types separately.",
      "Only one catch block is allowed per try block.",
      "The catch block must appear before try.",
      "Multiple catch blocks are ignored at runtime."
    ]
  },
  {
    "q": "What happens if an exception is thrown inside a 'finally' block?",
    "o": [
      "It overrides any exception thrown in the try or catch block.",
      "It is ignored silently.",
      "It is caught automatically by outer catch blocks.",
      "Finally block exceptions are always suppressed."
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "try {\n    int[] numbers = {1, 2, 3};\n    Console.WriteLine(numbers[5]);\n} catch (IndexOutOfRangeException ex) {\n    Console.WriteLine(\"Index error: \" + ex.Message);\n}",
    "o": [
      "Index error: Index was outside the bounds of the array.",
      "Compilation error",
      "NullReferenceException",
      "It will print 0"
    ]
  },
  {
    "q": "Which keyword is used to explicitly throw an exception in C#?",
    "o": [
      "throw",
      "raise",
      "error",
      "exception"
    ]
  },
  {
    "q": "What is the use of the 'finally' block in a try-catch-finally structure?",
    "o": [
      "To execute code regardless of whether an exception occurs or not",
      "To catch unhandled exceptions",
      "To skip code execution",
      "To log messages only if an error occurs"
    ]
  },
  {
    "q": "What does the following code demonstrate?",
    "c": "checked {\n    int x = int.MaxValue;\n    x += 1;\n}",
    "o": [
      "It throws an OverflowException at runtime.",
      "It wraps around silently without error.",
      "It throws a DivideByZeroException.",
      "It is a syntax error."
    ]
  },
  {
    "q": "What is the base class for all exceptions in C#?",
    "o": [
      "System.Exception",
      "System.Error",
      "System.SystemException",
      "System.Object"
    ]
  },
  {
    "q": "How do you define a custom exception class in C#?",
    "c": "public class InvalidAgeException : Exception {\n    public InvalidAgeException(string message) : base(message) {}\n}",
    "o": [
      "By inheriting from Exception and calling the base constructor",
      "By overriding the Exception class's GetType method",
      "By using the 'throws' keyword",
      "By inheriting from SystemError"
    ]
  },
  {
    "q": "Which of the following is true about 'unchecked' context?",
    "o": [
      "It disables overflow-checking for integral-type arithmetic operations.",
      "It checks for null before operations.",
      "It disables exceptions for all runtime errors.",
      "It prevents catch blocks from executing."
    ]
  },
  {
    "q": "What is the correct way to catch a specific exception?",
    "c": "try {\n    int.Parse(\"abc\");\n} catch (FormatException ex) {\n    Console.WriteLine(\"Invalid format.\");\n}",
    "o": [
      "This code correctly catches a FormatException.",
      "This code causes a syntax error.",
      "This catch block is unreachable.",
      "This catch block is missing the exception object."
    ]
  },
  {
    "q": "Which of the following is a best practice for custom exceptions?",
    "o": [
      "Use 'Exception' as the base class and add relevant constructors.",
      "Inherit from Object directly.",
      "Avoid naming exceptions with 'Exception' suffix.",
      "Do not include a message in custom exceptions."
    ]
  },
  {
    "q": "Which block is guaranteed to execute even if an exception occurs or not?",
    "o": [
      "finally",
      "catch",
      "throw",
      "checked"
    ]
  },
  {
    "q": "What happens if an exception is thrown inside a try block and there is no matching catch block?",
    "o": [
      "The program terminates unless the exception is handled elsewhere.",
      "The program continues as normal.",
      "The finally block is skipped.",
      "The code after try block is executed."
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try {\n    int result = 10 / 0;\n} catch (DivideByZeroException e) {\n    Console.WriteLine(\"Cannot divide by zero.\");\n} finally {\n    Console.WriteLine(\"Done\");\n}",
    "o": [
      "Cannot divide by zero.\nDone",
      "Done",
      "Compilation error",
      "No output"
    ]
  },
  {
    "q": "How do you explicitly throw a new exception in C#?",
    "c": "throw new InvalidOperationException(\"Invalid operation performed.\");",
    "o": [
      "Use the throw keyword followed by a new exception instance.",
      "Use the raise keyword.",
      "Use try keyword followed by throw.",
      "You can't throw exceptions manually in C#."
    ]
  },
  {
    "q": "Which of the following keywords is used to catch exceptions?",
    "o": [
      "catch",
      "throw",
      "handle",
      "rescue"
    ]
  },
  {
    "q": "In which situation would a 'finally' block not execute?",
    "o": [
      "If the process is forcibly terminated (e.g., Environment.Exit or power failure).",
      "If an exception is thrown.",
      "If a return statement is used inside the try block.",
      "If the exception is not handled."
    ]
  },
  {
    "q": "What is the purpose of a custom exception?",
    "o": [
      "To represent application-specific error conditions in a meaningful way.",
      "To override system exceptions.",
      "To replace try-catch blocks.",
      "To hide exception details."
    ]
  },
  {
    "q": "What does the following code demonstrate?",
    "c": "unchecked {\n    int max = int.MaxValue;\n    int result = max + 1;\n    Console.WriteLine(result);\n}",
    "o": [
      "Integer overflow without exception (wraps around).",
      "Throws an OverflowException.",
      "Compilation error due to overflow.",
      "Integer truncation."
    ]
  },
  {
    "q": "Which is the correct way to inherit a custom exception class?",
    "c": "public class MyException : Exception {\n    public MyException(string message) : base(message) {}\n}",
    "o": [
      "By extending the Exception base class and passing the message to base constructor.",
      "By implementing IException interface.",
      "By inheriting from System.Object.",
      "By using the override keyword."
    ]
  },
  {
    "q": "Why would you use a 'checked' block in C#?",
    "o": [
      "To enable overflow checking for arithmetic operations.",
      "To suppress overflow errors.",
      "To convert exceptions to warnings.",
      "To skip runtime checks."
    ]
  },
  {
    "q": "Which of the following will compile and run without error?",
    "c": "try {\n    int x = 5;\n} finally {\n    Console.WriteLine(\"Final cleanup.\");\n}",
    "o": [
      "A try block followed by only finally is valid.",
      "A try block must always be followed by a catch.",
      "try-finally without catch will cause compilation error.",
      "try block alone is allowed."
    ]
  },
  {
    "q": "What will happen when the code below is executed?",
    "c": "try {\n    int[] numbers = new int[3];\n    numbers[5] = 100;\n} catch (IndexOutOfRangeException ex) {\n    Console.WriteLine(\"Index error\");\n} finally {\n    Console.WriteLine(\"Execution complete\");\n}",
    "o": [
      "Index error\nExecution complete",
      "Execution complete",
      "Compilation error",
      "Runtime terminates without message"
    ]
  },
  {
    "q": "Which is a valid reason to use custom exceptions in C#?",
    "o": [
      "To create domain-specific error messages that are meaningful to the application.",
      "To override built-in exceptions like NullReferenceException.",
      "To automatically catch exceptions without using try-catch.",
      "To handle multiple exceptions in one catch block."
    ]
  },
  {
    "q": "What does the following code illustrate?",
    "c": "public class FileMissingException : Exception {\n    public FileMissingException(string msg) : base(msg) {}\n}",
    "o": [
      "Defining a custom exception class in C#.",
      "Overriding a method inside an exception class.",
      "Implementing IDisposable interface.",
      "Creating a struct for exceptions."
    ]
  },
  {
    "q": "What does 'finally' block guarantee in C# exception handling?",
    "o": [
      "It executes regardless of whether an exception occurred or not.",
      "It only runs if an exception is thrown.",
      "It executes only if the try block runs successfully.",
      "It skips execution if a return is in the try block."
    ]
  },
  {
    "q": "Which keyword causes an exception to be raised manually in C#?",
    "o": [
      "throw",
      "raise",
      "exception",
      "throws"
    ]
  },
  {
    "q": "How do you use the 'checked' keyword correctly?",
    "c": "checked {\n    int a = int.MaxValue;\n    int b = a + 1; // Triggers OverflowException\n}",
    "o": [
      "To ensure that arithmetic overflows raise exceptions.",
      "To suppress overflow-related exceptions.",
      "To define a conditional block for exception checking.",
      "To validate input values."
    ]
  },
  {
    "q": "What happens in the following code?",
    "c": "int x = unchecked(int.MaxValue + 1);",
    "o": [
      "Integer overflows silently without exception.",
      "OverflowException is thrown.",
      "Compilation error due to overflow.",
      "It resets x to zero."
    ]
  },
  {
    "q": "Which of the following is TRUE about exception handling in C#?",
    "o": [
      "You can have a try block with only a finally block.",
      "You must always use both catch and finally with try.",
      "Catch block must be first, then try.",
      "Only checked exceptions can be caught."
    ]
  },
  {
    "q": "Which part of the code below is most appropriate for releasing unmanaged resources?",
    "c": "try {\n    // some code\n} catch (Exception e) {\n    // handle error\n} finally {\n    // ?\n}",
    "o": [
      "finally",
      "catch",
      "try",
      "throw"
    ]
  },
  {
    "q": "What is the purpose of 'base(message)' in a custom exception constructor?",
    "o": [
      "It passes the error message to the base Exception class.",
      "It overrides the ToString method.",
      "It logs the exception to a file.",
      "It suppresses the exception from propagating."
    ]
  },
  {
    "q": "Which block in C# is used to ensure that cleanup code runs regardless of whether an exception occurred?",
    "o": [
      "finally",
      "catch",
      "throw",
      "using"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "try {\n    int a = 10, b = 0;\n    Console.WriteLine(a / b);\n} catch (DivideByZeroException) {\n    Console.WriteLine(\"Cannot divide by zero\");\n}",
    "o": [
      "Cannot divide by zero",
      "0",
      "Compilation Error",
      "Infinity"
    ]
  },
  {
    "q": "Which of the following correctly throws a new exception?",
    "o": [
      "throw new Exception(\"An error occurred\");",
      "throw Exception(\"An error occurred\");",
      "raise new Exception(\"An error occurred\");",
      "throw Exception.new(\"An error occurred\");"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "try {\n    throw new InvalidOperationException(\"Invalid operation\");\n} catch (Exception ex) {\n    Console.WriteLine(ex.Message);\n} finally {\n    Console.WriteLine(\"Done\");\n}",
    "o": [
      "Invalid operation\nDone",
      "Done",
      "Invalid operation",
      "No output"
    ]
  },
  {
    "q": "Which of the following is a correct custom exception class in C#?",
    "c": "public class MyCustomException : Exception {\n    public MyCustomException(string message) : base(message) {}\n}",
    "o": [
      "It correctly inherits from Exception and uses the base constructor.",
      "It must override ToString() method to work.",
      "It should not use base keyword.",
      "It should inherit from ApplicationException."
    ]
  },
  {
    "q": "What is the use of 'unchecked' in C#?",
    "o": [
      "To suppress overflow checking during arithmetic operations.",
      "To force overflow checking.",
      "To prevent runtime exceptions.",
      "To skip try-catch block."
    ]
  },
  {
    "q": "What happens when no exception is thrown in a try block with a finally block?",
    "o": [
      "Only the try and finally blocks execute.",
      "The catch block executes.",
      "The program exits immediately.",
      "An exception is still thrown."
    ]
  },
  {
    "q": "Which of the following is TRUE about the 'throw' statement?",
    "o": [
      "It is used to raise exceptions manually.",
      "It is used to catch exceptions.",
      "It is used to define custom exceptions.",
      "It is used in place of try-catch."
    ]
  },
  {
    "q": "What will the following code do?",
    "c": "checked {\n    int x = int.MaxValue;\n    x = x + 1;\n}",
    "o": [
      "Throws OverflowException",
      "Wraps around to int.MinValue",
      "Compiles but crashes silently",
      "Skips the block"
    ]
  },
  {
    "q": "Why is it recommended to derive custom exceptions from the Exception class?",
    "o": [
      "To integrate with .NET exception handling mechanisms.",
      "To avoid using the throw keyword.",
      "Because C# requires it for all classes.",
      "To bypass the need for finally blocks."
    ]
  },
  {
    "q": "What happens if an exception is thrown inside a try block but not caught by any catch block?",
    "o": [
      "The program terminates after executing the finally block",
      "The catch block automatically ignores it",
      "It gets caught silently",
      "The compiler fixes it"
    ]
  },
  {
    "q": "What does this code do?",
    "c": "try {\n    int[] arr = new int[3];\n    Console.WriteLine(arr[5]);\n} catch (IndexOutOfRangeException ex) {\n    Console.WriteLine(\"Index error: \" + ex.Message);\n} finally {\n    Console.WriteLine(\"Cleanup\");\n}",
    "o": [
      "Index error: Index was outside the bounds of the array.\nCleanup",
      "Index error\nCleanup",
      "Cleanup only",
      "No output"
    ]
  },
  {
    "q": "Which of these keywords is used to define a custom exception that inherits from the base Exception class?",
    "o": [
      "class",
      "extends",
      "derive",
      "inherits"
    ]
  },
  {
    "q": "What is the effect of this code?",
    "c": "unchecked {\n    int val = int.MaxValue + 1;\n    Console.WriteLine(val);\n}",
    "o": [
      "Performs overflow without throwing an error",
      "Throws OverflowException",
      "Does not compile",
      "Crashes at runtime"
    ]
  },
  {
    "q": "In which situation would you use a custom exception class?",
    "o": [
      "To represent application-specific error conditions",
      "To catch system exceptions",
      "To speed up performance",
      "To log to the console"
    ]
  },
  {
    "q": "What is the purpose of the `finally` block in C#?",
    "o": [
      "It always executes regardless of whether an exception occurs",
      "It only executes if an exception is thrown",
      "It only runs when no catch block is defined",
      "It is executed before the try block"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "try {\n    throw new FormatException(\"Invalid format\");\n} catch (DivideByZeroException) {\n    Console.WriteLine(\"Divide by zero\");\n} finally {\n    Console.WriteLine(\"Final block\");\n}",
    "o": [
      "Final block",
      "Invalid format",
      "Divide by zero",
      "No output"
    ]
  },
  {
    "q": "Which syntax defines a custom exception named `LoginException`?",
    "c": "public class LoginException : Exception {\n    public LoginException(string message) : base(message) {}\n}",
    "o": [
      "Correct custom exception definition",
      "Throws error due to missing override",
      "Incorrect inheritance syntax",
      "Only valid with try-catch"
    ]
  },
  {
    "q": "How does the `throw` keyword behave when used alone inside a catch block?",
    "o": [
      "Rethrows the original exception",
      "Throws a new exception automatically",
      "Ignores the exception",
      "Terminates the program"
    ]
  },
  {
    "q": "What does this code demonstrate?",
    "c": "try {\n    checked {\n        int a = int.MaxValue;\n        a++;\n    }\n} catch (OverflowException) {\n    Console.WriteLine(\"Overflow detected\");\n}",
    "o": [
      "Checked block with overflow exception handling",
      "Unchecked behavior",
      "Invalid code",
      "Infinite loop"
    ]
  },
  {
    "q": "Which part of a try-catch-finally block will always execute, even if an exception is not thrown?",
    "o": [
      "finally",
      "try",
      "catch",
      "throw"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "try {\n    int x = 0;\n    int y = 10 / x;\n} catch (DivideByZeroException) {\n    Console.WriteLine(\"Division error\");\n} finally {\n    Console.WriteLine(\"End of block\");\n}",
    "o": [
      "Division error\nEnd of block",
      "Division error only",
      "End of block only",
      "No output"
    ]
  },
  {
    "q": "Which of the following is a correct way to throw an exception in C#?",
    "o": [
      "throw new Exception(\"Something went wrong\");",
      "raise new Exception(\"Error\");",
      "exception.throw(\"Error occurred\");",
      "throw Exception(\"Oops\")"
    ]
  },
  {
    "q": "Which code correctly uses a custom exception named `AgeException`?",
    "c": "public class AgeException : Exception {\n    public AgeException(string message) : base(message) {}\n}\n\n// Usage\nthrow new AgeException(\"Age must be over 18\");",
    "o": [
      "Defines and uses a custom exception",
      "Fails because base constructor is not called",
      "Custom exceptions can't be thrown like this",
      "Exception must be sealed"
    ]
  },
  {
    "q": "What will happen in a checked block if an arithmetic overflow occurs?",
    "o": [
      "An OverflowException will be thrown",
      "The result will wrap around silently",
      "The program crashes without message",
      "It will be ignored"
    ]
  },
  {
    "q": "Which is the main purpose of using `unchecked` blocks?",
    "o": [
      "To suppress overflow exceptions during arithmetic operations",
      "To validate exceptions at runtime",
      "To automatically catch exceptions",
      "To improve performance of try blocks"
    ]
  },
  {
    "q": "Which of the following is NOT a benefit of custom exception classes?",
    "o": [
      "They reduce the need for exception handling",
      "They make error types more meaningful",
      "They allow specific catch blocks",
      "They can include additional context"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "try {\n    int result = checked(2147483647 + 1);\n    Console.WriteLine(result);\n} catch (OverflowException) {\n    Console.WriteLine(\"Overflow caught\");\n}",
    "o": [
      "Overflow caught",
      "No output",
      "2147483648",
      "Program crashes silently"
    ]
  },
  {
    "q": "Which of the following correctly rethrows the caught exception?",
    "c": "catch (Exception ex) {\n    Console.WriteLine(ex.Message);\n    throw;\n}",
    "o": [
      "Rethrows the original exception with stack trace preserved",
      "Throws a new generic exception",
      "Throws an empty exception",
      "Suppresses the exception"
    ]
  },
  {
    "q": "Which of the following keywords is NOT directly related to exception handling in C#?",
    "o": [
      "final",
      "try",
      "catch",
      "throw"
    ]
  },
  {
    "q": "What happens if an exception is thrown inside a `try` block and there's no matching `catch` block?",
    "o": [
      "The program terminates after executing the `finally` block",
      "The exception is ignored",
      "The program continues normally",
      "The compiler throws a warning"
    ]
  },
  {
    "q": "Which of the following defines a custom exception class correctly?",
    "c": "public class InvalidLoginException : Exception {\n    public InvalidLoginException(string message) : base(message) {}\n}",
    "o": [
      "Defines a custom exception that inherits from `Exception`",
      "This throws an error because base must not be used",
      "Custom exceptions can't have constructors",
      "You must override the `ToString()` method"
    ]
  },
  {
    "q": "Which of the following ensures that a block of code runs regardless of whether an exception is thrown or not?",
    "o": [
      "finally",
      "try",
      "catch",
      "throw"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "try {\n    int[] arr = new int[2];\n    arr[5] = 10;\n} catch (IndexOutOfRangeException ex) {\n    Console.WriteLine(\"Out of bounds\");\n} finally {\n    Console.WriteLine(\"Done\");\n}",
    "o": [
      "Out of bounds\nDone",
      "Done only",
      "Out of bounds only",
      "Program crashes"
    ]
  },
  {
    "q": "What is the purpose of `throw;` inside a `catch` block?",
    "o": [
      "To rethrow the same exception preserving the stack trace",
      "To throw a new exception",
      "To suppress the exception",
      "To convert it to a warning"
    ]
  },
  {
    "q": "When should you use the `checked` keyword in C#?",
    "o": [
      "When you want to ensure overflow exceptions are thrown during arithmetic operations",
      "To prevent exceptions from being thrown",
      "To automatically handle exceptions",
      "When validating input strings"
    ]
  },
  {
    "q": "What is the behavior of this code snippet?",
    "c": "unchecked {\n    int max = int.MaxValue;\n    int overflow = max + 1;\n    Console.WriteLine(overflow);\n}",
    "o": [
      "It wraps around without throwing an exception",
      "It throws an `OverflowException`",
      "It crashes at runtime",
      "It causes a compilation error"
    ]
  },
  {
    "q": "Which scenario best justifies creating a custom exception class?",
    "o": [
      "To represent a specific error domain, like `InvalidPaymentException`",
      "To simplify the code",
      "To handle system-level errors",
      "To avoid using `try-catch` blocks"
    ]
  },
  {
    "q": "Which of the following is TRUE about exception propagation in C#?",
    "o": [
      "If not caught in the current method, an exception propagates up the call stack",
      "Exceptions are always handled in the same method",
      "Exceptions stop program execution silently",
      "C# doesn’t support exception propagation"
    ]
  },
  {
    "q": "What keyword would you use to prevent arithmetic overflow exceptions from being thrown in a block?",
    "o": [
      "unchecked",
      "checked",
      "suppress",
      "noexception"
    ]
  },
  {
    "q": "What is the correct syntax to throw a new exception in C#?",
    "o": [
      "throw new Exception(\"An error occurred\");",
      "throw Exception(\"An error occurred\");",
      "Exception throw new(\"An error occurred\");",
      "new Exception(\"An error occurred\").throw();"
    ]
  },
  {
    "q": "What is the purpose of the `finally` block in exception handling?",
    "o": [
      "To execute code regardless of whether an exception occurred or not",
      "To catch specific types of exceptions",
      "To throw exceptions again",
      "To skip over the exception entirely"
    ]
  },
  {
    "q": "What does this C# code do?",
    "c": "try {\n    int x = 10 / 0;\n} catch (DivideByZeroException ex) {\n    Console.WriteLine(\"Cannot divide by zero\");\n}",
    "o": [
      "Prints 'Cannot divide by zero'",
      "Throws a runtime exception",
      "Compiler error due to division",
      "Program continues silently"
    ]
  },
  {
    "q": "Which of the following best describes a custom exception in C#?",
    "o": [
      "A user-defined class that inherits from System.Exception",
      "A delegate that handles exceptions",
      "A system-generated error handler",
      "An automatically thrown error by .NET"
    ]
  },
  {
    "q": "Which block will always be executed whether an exception is thrown or not?",
    "o": [
      "finally",
      "try",
      "catch",
      "throw"
    ]
  },
  {
    "q": "What does the following code snippet output?",
    "c": "try {\n    throw new InvalidOperationException();\n} catch (Exception) {\n    Console.WriteLine(\"Exception caught\");\n} finally {\n    Console.WriteLine(\"Cleanup done\");\n}",
    "o": [
      "Exception caught\nCleanup done",
      "Cleanup done",
      "Exception caught",
      "Program crashes"
    ]
  },
  {
    "q": "What is the behavior of the following code?",
    "c": "checked {\n    int x = int.MaxValue;\n    x = x + 1;\n}",
    "o": [
      "Throws an OverflowException",
      "Silently wraps around to negative number",
      "Compiles but skips the line",
      "Ignores overflow without error"
    ]
  },
  {
    "q": "Which of the following is a benefit of using custom exceptions?",
    "o": [
      "Provides meaningful error messages specific to application logic",
      "Makes code slower intentionally",
      "Replaces the need for try-catch",
      "Reduces memory usage"
    ]
  },
  {
    "q": "What does the `unchecked` keyword do in C#?",
    "o": [
      "Disables overflow checking for integral-type arithmetic operations",
      "Enables overflow checking",
      "Catches runtime exceptions",
      "Validates logical errors"
    ]
  },
  {
    "q": "What will happen if an exception is thrown in a method and not caught?",
    "o": [
      "It propagates up the call stack until caught or the application crashes",
      "It is automatically handled by the CLR",
      "The method stops and skips the error silently",
      "A compile-time error occurs"
    ]
  },
  {
    "q": "Which of the following blocks is optional in a try-catch-finally structure in C#?",
    "o": [
      "finally",
      "try",
      "catch",
      "All blocks are mandatory"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "try {\n    int[] nums = new int[2];\n    Console.WriteLine(nums[5]);\n} catch (IndexOutOfRangeException) {\n    Console.WriteLine(\"Index error!\");\n}",
    "o": [
      "Index error!",
      "5",
      "Program crashes",
      "nums[5]"
    ]
  },
  {
    "q": "How do you define a custom exception class in C#?",
    "o": [
      "By inheriting from System.Exception",
      "By creating a struct with 'exception' keyword",
      "By using try inside a class",
      "By overriding Console.Error"
    ]
  },
  {
    "q": "Which keyword is used to re-throw the current exception in C#?",
    "o": [
      "throw;",
      "catch;",
      "throw ex;",
      "try;"
    ]
  },
  {
    "q": "What is the primary role of the catch block?",
    "o": [
      "To handle exceptions thrown in the try block",
      "To execute code after try finishes",
      "To skip execution",
      "To define a method"
    ]
  },
  {
    "q": "What will happen when the following code runs?",
    "c": "try {\n    int val = 2147483647;\n    val = checked(val + 1);\n} catch (OverflowException) {\n    Console.WriteLine(\"Overflow occurred\");\n}",
    "o": [
      "Overflow occurred",
      "2147483648",
      "No output",
      "Compile-time error"
    ]
  },
  {
    "q": "Which C# keyword suppresses overflow checking in a numeric operation?",
    "o": [
      "unchecked",
      "checked",
      "suppress",
      "overflowoff"
    ]
  },
  {
    "q": "What is the correct way to create and throw a custom exception?",
    "c": "public class MyCustomException : Exception {\n    public MyCustomException(string message) : base(message) {}\n}\n\n// Usage:\nthrow new MyCustomException(\"Something went wrong\");",
    "o": [
      "Correct implementation and usage of a custom exception",
      "Missing base call in constructor",
      "Incorrect throw statement",
      "Wrong exception class used"
    ]
  },
  {
    "q": "Which exception is thrown when a null object is dereferenced?",
    "o": [
      "NullReferenceException",
      "ArgumentException",
      "IndexOutOfRangeException",
      "OverflowException"
    ]
  },
  {
    "q": "Which of the following statements about `finally` block is true?",
    "o": [
      "It always executes, even if an exception is not caught",
      "It runs only when an exception is thrown",
      "It is executed only if try fails",
      "It cannot be used with catch"
    ]
  },
  {
    "q": "Which block in C# is guaranteed to execute whether or not an exception occurs?",
    "o": [
      "finally",
      "catch",
      "try",
      "throw"
    ]
  },
  {
    "q": "What is the output of this code snippet?",
    "c": "try {\n    Console.WriteLine(\"Start\");\n    throw new Exception();\n} catch {\n    Console.WriteLine(\"Caught\");\n} finally {\n    Console.WriteLine(\"Finally block\");\n}",
    "o": [
      "Start\nCaught\nFinally block",
      "Start\nFinally block\nCaught",
      "Caught\nFinally block\nStart",
      "Finally block\nCaught\nStart"
    ]
  },
  {
    "q": "How can you create a custom exception with a specific message?",
    "o": [
      "public class MyError : Exception { public MyError(string msg) : base(msg) {} }",
      "public class MyError : Error {}",
      "Exception custom = new Exception();",
      "throw Exception(\"message\");"
    ]
  },
  {
    "q": "What is the effect of using `throw;` inside a catch block?",
    "o": [
      "It re-throws the caught exception preserving the original stack trace",
      "It throws a new exception",
      "It stops the application immediately",
      "It clears the exception"
    ]
  },
  {
    "q": "What will the following C# code do?",
    "c": "int x = int.MaxValue;\nint result = unchecked(x + 1);\nConsole.WriteLine(result);",
    "o": [
      "-2147483648",
      "OverflowException",
      "Runtime error",
      "0"
    ]
  },
  {
    "q": "Which exception type is best for signaling application-specific errors?",
    "o": [
      "Custom-defined exception classes",
      "System.Exception directly",
      "DivideByZeroException",
      "InvalidCastException"
    ]
  },
  {
    "q": "What is the keyword to enable overflow checking explicitly in C#?",
    "o": [
      "checked",
      "validate",
      "overflowcheck",
      "trycatch"
    ]
  },
  {
    "q": "What does this code output?",
    "c": "try {\n    int a = 5, b = 0;\n    int c = a / b;\n} catch (DivideByZeroException) {\n    Console.Write(\"Division Error\");\n} finally {\n    Console.Write(\" Done\");\n}",
    "o": [
      "Division Error Done",
      "Division Error",
      "Done",
      "0"
    ]
  },
  {
    "q": "Which of these is a correct way to throw a built-in exception?",
    "o": [
      "throw new InvalidOperationException(\"Invalid operation!\");",
      "throw InvalidOperationException(\"Invalid operation!\");",
      "throw new Exception[];",
      "throw;"
    ]
  },
  {
    "q": "Which of the following is TRUE about exception handling in C#?",
    "o": [
      "Multiple catch blocks can be used with a single try block",
      "The finally block must always be used",
      "catch must come before try",
      "Only one exception type can be caught per try"
    ]
  },
  {
    "q": "Which C# keyword is used to throw an exception manually?",
    "o": [
      "throw",
      "raise",
      "exception",
      "error"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "try {\n    Console.WriteLine(\"Before error\");\n    int[] arr = new int[2];\n    Console.WriteLine(arr[5]);\n} catch (IndexOutOfRangeException) {\n    Console.WriteLine(\"Caught exception\");\n}",
    "o": [
      "Before error\nCaught exception",
      "Caught exception",
      "Runtime error",
      "Before error"
    ]
  },
  {
    "q": "Which of the following custom exception declarations is correct?",
    "o": [
      "public class MyException : Exception {}",
      "class MyException inherits Exception {}",
      "public MyException extends Exception {}",
      "Exception MyException = new Exception();"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "try {\n    Console.WriteLine(\"Try block\");\n} finally {\n    Console.WriteLine(\"Finally block\");\n}",
    "o": [
      "Try block\nFinally block",
      "Finally block\nTry block",
      "Try block",
      "Finally block"
    ]
  },
  {
    "q": "When using `checked`, what happens if arithmetic overflows?",
    "o": [
      "An OverflowException is thrown",
      "It silently wraps around the value",
      "It throws an IndexOutOfRangeException",
      "It resets the value to zero"
    ]
  },
  {
    "q": "Which statement is true about the `finally` block?",
    "o": [
      "It runs regardless of whether an exception was thrown or not",
      "It only runs if an exception was caught",
      "It skips if the try block completes",
      "It runs only when catch is used"
    ]
  },
  {
    "q": "What happens when you throw an exception using `throw ex;` in a catch block?",
    "o": [
      "It resets the stack trace of the exception",
      "It preserves the original stack trace",
      "It hides the exception",
      "It causes a syntax error"
    ]
  },
  {
    "q": "Identify the correct use of `unchecked` in C#.",
    "c": "int x = int.MaxValue;\nint y = unchecked(x + 1);\nConsole.WriteLine(y);",
    "o": [
      "-2147483648",
      "OverflowException",
      "Compile-time error",
      "NullReferenceException"
    ]
  },
  {
    "q": "Which of these exception types can be caught in C#?",
    "o": [
      "System.DivideByZeroException",
      "System.MemoryError",
      "System.OverflowError",
      "System.IndexOutOfBoundException"
    ]
  },
  {
    "q": "What is required for a class to be used as a custom exception?",
    "o": [
      "It must inherit from System.Exception",
      "It must override the ToString() method",
      "It must implement IException interface",
      "It must be abstract"
    ]
  },
  {
    "q": "Which block is always executed in a try-catch-finally structure?",
    "o": [
      "finally",
      "try",
      "catch",
      "else"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try {\n    int num = 10;\n    int result = num / 0;\n    Console.WriteLine(result);\n} catch (DivideByZeroException) {\n    Console.WriteLine(\"Cannot divide by zero\");\n} finally {\n    Console.WriteLine(\"Cleanup done\");\n}",
    "o": [
      "Cannot divide by zero\nCleanup done",
      "Cleanup done",
      "10\nCleanup done",
      "Runtime Error"
    ]
  },
  {
    "q": "Which of the following correctly defines and throws a custom exception?",
    "c": "public class MyCustomException : Exception {}\n\n...\n\nif (somethingWrong)\n    throw new MyCustomException();",
    "o": [
      "Correct usage of custom exception",
      "Incorrect syntax - missing 'base' call",
      "Should extend ApplicationException",
      "Cannot throw a custom exception"
    ]
  },
  {
    "q": "What is the purpose of the `checked` keyword in C#?",
    "o": [
      "To enable overflow checking in arithmetic operations",
      "To suppress exceptions",
      "To skip code blocks on error",
      "To automatically catch exceptions"
    ]
  },
  {
    "q": "What does the `unchecked` keyword do in C#?",
    "o": [
      "Suppresses overflow exceptions during arithmetic operations",
      "Forces exception to be thrown",
      "Skips catch block execution",
      "Validates object types"
    ]
  },
  {
    "q": "Which of the following will correctly rethrow an exception while preserving the original stack trace?",
    "c": "catch (Exception ex) {\n    // some logging\n    throw;\n}",
    "o": [
      "throw;",
      "throw ex;",
      "rethrow ex;",
      "raise ex;"
    ]
  },
  {
    "q": "How do you define a custom exception with a message?",
    "c": "public class LoginException : Exception {\n    public LoginException(string message) : base(message) {}\n}",
    "o": [
      "Correct custom exception with message",
      "Missing constructor call",
      "Should override Message property",
      "Only default constructor is allowed"
    ]
  },
  {
    "q": "Which of the following is a base class for all exceptions in C#?",
    "o": [
      "System.Exception",
      "System.Object",
      "System.BaseException",
      "System.Throw"
    ]
  },
  {
    "q": "Which exception is thrown when you access a null object in C#?",
    "o": [
      "NullReferenceException",
      "InvalidCastException",
      "IndexOutOfRangeException",
      "DivideByZeroException"
    ]
  },
  {
    "q": "What is the role of the catch block in exception handling?",
    "o": [
      "To handle specific exceptions thrown in the try block",
      "To skip execution if an error occurs",
      "To ensure the program compiles",
      "To always execute before the try block"
    ]
  },
  {
    "q": "Which of the following statements about try-catch-finally in C# is TRUE?",
    "o": [
      "The finally block always executes, regardless of whether an exception is thrown or not.",
      "The finally block only executes if an exception is thrown.",
      "The finally block is optional and never recommended.",
      "The try block executes only if an exception occurs."
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "try {\n    int[] arr = new int[2];\n    arr[5] = 100;\n} catch (IndexOutOfRangeException) {\n    Console.WriteLine(\"Index error\");\n} finally {\n    Console.WriteLine(\"Execution complete\");\n}",
    "o": [
      "Index error\nExecution complete",
      "Execution complete",
      "100\nExecution complete",
      "Compilation error"
    ]
  },
  {
    "q": "How can you prevent arithmetic overflow exceptions during compilation?",
    "o": [
      "Use the 'unchecked' keyword",
      "Use a try-catch block",
      "Use nullable types",
      "Use the 'override' keyword"
    ]
  },
  {
    "q": "Which of the following is TRUE about custom exception classes in C#?",
    "o": [
      "They must inherit from System.Exception",
      "They cannot include constructors",
      "They must override the ToString() method",
      "They must be sealed"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try {\n    int x = 2147483647;\n    int y = checked(x + 1);\n} catch (OverflowException) {\n    Console.WriteLine(\"Overflow caught\");\n}",
    "o": [
      "Overflow caught",
      "2147483648",
      "0",
      "Runtime Error"
    ]
  },
  {
    "q": "When defining a custom exception in C#, what should the class name conventionally end with?",
    "o": [
      "Exception",
      "Error",
      "Ex",
      "ExceptionClass"
    ]
  },
  {
    "q": "Which of the following is the correct way to catch any type of exception?",
    "o": [
      "catch (Exception ex)",
      "catch ()",
      "catch (any)",
      "catch {}"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try {\n    throw new ArgumentException(\"Invalid argument\");\n} catch (ArgumentNullException) {\n    Console.WriteLine(\"Null argument\");\n} catch (ArgumentException) {\n    Console.WriteLine(\"Argument error\");\n}",
    "o": [
      "Argument error",
      "Null argument",
      "Invalid argument",
      "Compilation error"
    ]
  },
  {
    "q": "In which case should you use 'throw;' instead of 'throw ex;' inside a catch block?",
    "o": [
      "To preserve the original stack trace",
      "To log a new exception message",
      "To throw a new exception",
      "To avoid catching the same exception twice"
    ]
  },
  {
    "q": "Which of the following correctly uses 'unchecked' to suppress overflow detection?",
    "c": "int x = int.MaxValue;\nint y = unchecked(x + 1);",
    "o": [
      "This will not throw an OverflowException",
      "This will cause a compile-time error",
      "This will throw an OverflowException",
      "This syntax is invalid"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "try {\n    int result = 10 / 0;\n} catch (DivideByZeroException ex) {\n    Console.WriteLine(\"Cannot divide by zero.\");\n} finally {\n    Console.WriteLine(\"Finally block executed.\");\n}",
    "o": [
      "Cannot divide by zero.\nFinally block executed.",
      "Finally block executed.",
      "Runtime error",
      "Program crashes without any message"
    ]
  },
  {
    "q": "What is the purpose of the 'finally' block in exception handling?",
    "o": [
      "To ensure a block of code runs regardless of whether an exception was thrown",
      "To catch fatal exceptions only",
      "To log the exception only",
      "To throw a new exception"
    ]
  },
  {
    "q": "Which exception type is thrown when a null object is accessed?",
    "o": [
      "NullReferenceException",
      "InvalidCastException",
      "ArgumentNullException",
      "ObjectDisposedException"
    ]
  },
  {
    "q": "What is the correct way to define a custom exception in C#?",
    "c": "public class MyCustomException : Exception {\n    public MyCustomException(string message) : base(message) {}\n}",
    "o": [
      "This is a valid custom exception class",
      "Custom exceptions must be sealed",
      "Constructor must not take parameters",
      "You cannot extend Exception directly"
    ]
  },
  {
    "q": "Which block of code is guaranteed to run, even if an exception occurs and is not caught?",
    "o": [
      "finally",
      "catch",
      "try",
      "throw"
    ]
  },
  {
    "q": "What is the output of this code snippet?",
    "c": "try {\n    string str = null;\n    Console.WriteLine(str.Length);\n} catch (Exception e) {\n    Console.WriteLine(\"An error occurred\");\n}",
    "o": [
      "An error occurred",
      "0",
      "null",
      "Length is undefined"
    ]
  },
  {
    "q": "What happens when you use 'throw ex;' inside a catch block?",
    "o": [
      "It resets the stack trace of the original exception",
      "It preserves the stack trace",
      "It prevents the exception from being thrown again",
      "It ignores the exception completely"
    ]
  },
  {
    "q": "What is the default base class for all exceptions in C#?",
    "o": [
      "System.Exception",
      "System.SystemException",
      "System.BaseException",
      "System.Error"
    ]
  },
  {
    "q": "Which keyword is used to raise an exception manually in C#?",
    "o": [
      "throw",
      "raise",
      "exception",
      "catch"
    ]
  },
  {
    "q": "What is the purpose of using the 'checked' keyword?",
    "o": [
      "To enable overflow checking for integral-type arithmetic operations",
      "To catch syntax errors",
      "To validate reference types",
      "To manage memory manually"
    ]
  },
  {
    "q": "What is the result of the following C# code?",
    "c": "try {\n    int[] arr = new int[3];\n    arr[5] = 100;\n} catch (IndexOutOfRangeException) {\n    Console.WriteLine(\"Index out of bounds!\");\n}",
    "o": [
      "Index out of bounds!",
      "100",
      "Array index 5",
      "No output"
    ]
  },
  {
    "q": "Why would you use a 'finally' block in C#?",
    "o": [
      "To clean up resources like file handles or connections",
      "To catch any exceptions that were not handled",
      "To ignore all exceptions",
      "To run code only if an exception occurs"
    ]
  },
  {
    "q": "Which of the following keywords is used to define a block of code that may throw an exception?",
    "o": [
      "try",
      "throw",
      "catch",
      "finally"
    ]
  },
  {
    "q": "What is true about custom exception classes in C#?",
    "o": [
      "They must inherit from System.Exception or one of its derived classes",
      "They cannot have constructors",
      "They must be declared as static",
      "They cannot contain custom properties"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try {\n    int a = int.Parse(\"abc\");\n} catch (FormatException) {\n    Console.WriteLine(\"Invalid format\");\n}",
    "o": [
      "Invalid format",
      "abc",
      "0",
      "No output"
    ]
  },
  {
    "q": "When should the 'throw' keyword be used inside a catch block without specifying an exception?",
    "o": [
      "To re-throw the caught exception preserving the original stack trace",
      "To throw a new exception",
      "To catch and suppress the exception",
      "To ignore the exception"
    ]
  },
  {
    "q": "What does the 'unchecked' keyword do in C#?",
    "o": [
      "Disables overflow checking for arithmetic operations",
      "Enables automatic exception handling",
      "Disables exception propagation",
      "Ignores null reference exceptions"
    ]
  },
  {
    "q": "Which of the following is a valid catch block?",
    "o": [
      "catch (Exception ex)",
      "catch Exception ex",
      "catch { Exception ex }",
      "catch(Exception: ex)"
    ]
  },
  {
    "q": "Which of these can be used to throw a custom exception?",
    "c": "throw new MyCustomException(\"Something went wrong\");",
    "o": [
      "Valid custom exception throw",
      "Incorrect syntax",
      "Cannot throw user-defined exceptions",
      "Only system-defined exceptions can be thrown"
    ]
  },
  {
    "q": "Which exception is thrown when an arithmetic overflow occurs in a 'checked' context?",
    "o": [
      "OverflowException",
      "DivideByZeroException",
      "ArithmeticException",
      "InvalidOperationException"
    ]
  },
  {
    "q": "What happens if an exception occurs and there is no catch block, but a finally block is present?",
    "o": [
      "The finally block executes, then the exception is rethrown",
      "The program terminates silently",
      "The exception is ignored",
      "Only the catch block executes"
    ]
  },
  {
    "q": "Which keyword is used to force an exception in C#?",
    "o": [
      "throw",
      "catch",
      "raise",
      "try"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "try {\n    int x = 5 / 0;\n} catch (DivideByZeroException ex) {\n    Console.WriteLine(\"Cannot divide by zero\");\n} finally {\n    Console.WriteLine(\"Finally block\");\n}",
    "o": [
      "Cannot divide by zero\nFinally block",
      "Finally block",
      "DivideByZeroException",
      "Runtime Error"
    ]
  },
  {
    "q": "In C#, what is the purpose of using 'checked'?",
    "o": [
      "To enable overflow checking for integral-type arithmetic operations",
      "To check if an exception is thrown",
      "To validate data types at runtime",
      "To prevent null reference exceptions"
    ]
  },
  {
    "q": "How do you define a custom exception class in C#?",
    "o": [
      "public class MyException : Exception {}",
      "custom class MyException inherits Exception {}",
      "class MyException implements Exception {}",
      "public MyException : inherits Exception {}"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try {\n    int val = checked(2147483647 + 1);\n} catch (OverflowException) {\n    Console.WriteLine(\"Overflow occurred\");\n}",
    "o": [
      "Overflow occurred",
      "2147483648",
      "Runtime Error",
      "No output"
    ]
  },
  {
    "q": "Which block always executes regardless of an exception being thrown?",
    "o": [
      "finally",
      "catch",
      "try",
      "throw"
    ]
  },
  {
    "q": "What should a custom exception class include to ensure it is serializable?",
    "o": [
      "[Serializable] attribute and a protected constructor with SerializationInfo and StreamingContext",
      "Only a default constructor",
      "An interface implementation",
      "The override of ToString() method only"
    ]
  },
  {
    "q": "What is the difference between 'throw' and 'throw ex' inside a catch block?",
    "o": [
      "'throw' preserves the original stack trace; 'throw ex' resets it",
      "Both are exactly the same",
      "‘throw ex’ catches the exception silently",
      "‘throw’ is used only for built-in exceptions"
    ]
  },
  {
    "q": "Which of the following will prevent arithmetic overflow at runtime?",
    "o": [
      "Using 'checked' keyword",
      "Using 'try-catch' only",
      "Using 'unchecked' keyword",
      "Using 'finally' block"
    ]
  },
  {
    "q": "Which of the following is true about the 'finally' block in C#?",
    "o": [
      "It executes regardless of whether an exception is thrown or not",
      "It executes only if no exception occurs",
      "It executes only when an exception is caught",
      "It is optional and cannot be used alone"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try {\n    throw new Exception(\"Something went wrong\");\n} catch (Exception ex) {\n    Console.WriteLine(ex.Message);\n} finally {\n    Console.WriteLine(\"Cleanup done\");\n}",
    "o": [
      "Something went wrong\nCleanup done",
      "Exception\nCleanup done",
      "Something went wrong",
      "Cleanup done"
    ]
  },
  {
    "q": "What will happen if 'throw;' is used inside a catch block?",
    "o": [
      "The original exception is rethrown",
      "A new exception is thrown",
      "The program exits immediately",
      "It throws a NullReferenceException"
    ]
  },
  {
    "q": "Which of the following correctly throws a custom exception?",
    "o": [
      "throw new MyCustomException(\"Custom error message\");",
      "raise MyCustomException(\"Custom error message\")",
      "throw MyCustomException(\"Custom error message\")",
      "new MyCustomException(\"Custom error message\");"
    ]
  },
  {
    "q": "What is the output of this code using 'unchecked'?",
    "c": "int max = int.MaxValue;\nint result = unchecked(max + 1);\nConsole.WriteLine(result);",
    "o": [
      "-2147483648",
      "OverflowException",
      "2147483648",
      "Compilation Error"
    ]
  },
  {
    "q": "Which block is mandatory in C# exception handling?",
    "o": [
      "try",
      "catch",
      "finally",
      "throw"
    ]
  },
  {
    "q": "What happens when an exception is thrown inside a 'finally' block?",
    "o": [
      "It overrides any previously thrown exception",
      "It gets ignored",
      "It is logged but does not propagate",
      "It is suppressed silently"
    ]
  },
  {
    "q": "Why should you avoid using 'throw ex;' inside catch blocks?",
    "o": [
      "It resets the stack trace",
      "It cannot rethrow the exception",
      "It causes compilation error",
      "It skips the finally block"
    ]
  },
  {
    "q": "How can you define a custom exception class called 'DataError'?",
    "o": [
      "public class DataError : Exception {}",
      "public Exception DataError() {}",
      "class DataError extends Exception {}",
      "exception class DataError {}"
    ]
  },
  {
    "q": "Which keyword disables overflow checking for arithmetic operations in C#?",
    "o": [
      "unchecked",
      "ignore",
      "bypass",
      "try"
    ]
  },
  {
    "q": "Which block is guaranteed to execute regardless of whether an exception is thrown?",
    "o": [
      "finally",
      "catch",
      "try",
      "throw"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "try {\n    Console.WriteLine(\"A\");\n    throw new Exception();\n    Console.WriteLine(\"B\");\n} catch {\n    Console.WriteLine(\"C\");\n} finally {\n    Console.WriteLine(\"D\");\n}",
    "o": [
      "A\nC\nD",
      "A\nB\nC\nD",
      "A\nD",
      "C\nD"
    ]
  },
  {
    "q": "What is the correct syntax to throw an exception in C#?",
    "o": [
      "throw new Exception(\"Something went wrong\");",
      "raise Exception(\"Something went wrong\")",
      "throw Exception(\"Something went wrong\")",
      "raise new Exception(\"Something went wrong\")"
    ]
  },
  {
    "q": "What does the following code demonstrate?",
    "c": "try {\n    int value = int.MaxValue;\n    int result = checked(value + 1);\n} catch (OverflowException) {\n    Console.WriteLine(\"Overflow detected.\");\n}",
    "o": [
      "Using checked to detect overflow",
      "Throwing a null reference exception",
      "Unchecked overflow handling",
      "Compiling without runtime checks"
    ]
  },
  {
    "q": "Which of the following best describes a custom exception class in C#?",
    "o": [
      "A class that inherits from Exception and adds specific logic for custom errors.",
      "A sealed class that prevents any exceptions from being thrown.",
      "A static class used only for logging errors.",
      "A method that replaces built-in exceptions."
    ]
  },
  {
    "q": "Which of the following statements about 'unchecked' is TRUE?",
    "o": [
      "It suppresses overflow-checking for integral arithmetic.",
      "It throws an exception on every overflow.",
      "It is required in every try-catch block.",
      "It logs all overflow exceptions."
    ]
  },
  {
    "q": "What is the purpose of 'inner exception' in C#?",
    "o": [
      "To provide details about the original exception that caused the current one.",
      "To define a private error scope.",
      "To skip handling of exceptions.",
      "To restart the try block."
    ]
  },
  {
    "q": "What does this code print?",
    "c": "try {\n    Console.WriteLine(\"Start\");\n} finally {\n    Console.WriteLine(\"Cleanup\");\n}",
    "o": [
      "Start\nCleanup",
      "Cleanup\nStart",
      "Start",
      "Only Cleanup"
    ]
  },
  {
    "q": "Which is the correct way to define a custom exception with an inner exception?",
    "o": [
      "public class MyException : Exception {\n    public MyException(string message, Exception inner) : base(message, inner) {}\n}",
      "class MyException(Exception e, String m) { base(e, m); }",
      "new Exception(message, inner) = MyException()",
      "def MyException(msg, inner): pass"
    ]
  },
  {
    "q": "When using 'checked' in C#, what kind of exceptions are typically caught?",
    "o": [
      "OverflowException",
      "NullReferenceException",
      "DivideByZeroException",
      "IOException"
    ]
  },
  {
    "q": "Which of the following keywords is used to re-throw the same exception in a catch block?",
    "o": [
      "throw;",
      "throw ex;",
      "rethrow;",
      "raise;"
    ]
  },
  {
    "q": "What is the purpose of the 'finally' block in exception handling?",
    "o": [
      "To ensure a block of code always runs, even if an exception occurs.",
      "To log only unhandled exceptions.",
      "To catch critical system-level exceptions.",
      "To replace the catch block when it’s missing."
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "try {\n    Console.WriteLine(\"Inside try\");\n    int x = 5 / 0;\n} catch (DivideByZeroException) {\n    Console.WriteLine(\"Caught division by zero\");\n} finally {\n    Console.WriteLine(\"Finally executed\");\n}",
    "o": [
      "Inside try\nCaught division by zero\nFinally executed",
      "Caught division by zero\nFinally executed",
      "Inside try\nFinally executed",
      "Finally executed"
    ]
  },
  {
    "q": "Which base class should all custom exception classes inherit from?",
    "o": [
      "Exception",
      "BaseException",
      "Error",
      "ApplicationException"
    ]
  },
  {
    "q": "Which scenario is best suited for using 'checked' in C#?",
    "o": [
      "When you want the runtime to throw an exception on integer overflow.",
      "When you want to ignore arithmetic overflows silently.",
      "When handling file I/O operations.",
      "To manage null references safely."
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try {\n    unchecked {\n        int max = int.MaxValue;\n        int result = max + 1;\n        Console.WriteLine(result);\n    }\n} catch (OverflowException) {\n    Console.WriteLine(\"Overflow caught\");\n}",
    "o": [
      "-2147483648",
      "Overflow caught",
      "2147483648",
      "Compilation error"
    ]
  },
  {
    "q": "What is the correct way to define a custom exception with a default constructor?",
    "o": [
      "public class MyException : Exception {\n    public MyException() : base(\"Default message\") {}\n}",
      "class MyException(Exception) {\n    def __init__(self): pass\n}",
      "new Exception(\"MyException\")",
      "Exception(\"MyException\")"
    ]
  },
  {
    "q": "Which keyword is used to bypass overflow checking for integral types in C#?",
    "o": [
      "unchecked",
      "checked",
      "unsafe",
      "bypass"
    ]
  },
  {
    "q": "What happens if an exception occurs but no catch block exists for it?",
    "o": [
      "The program terminates and the runtime displays an error.",
      "It is silently ignored.",
      "It is logged to a file by default.",
      "The program continues to execute the next line."
    ]
  },
  {
    "q": "In which case would using a custom exception be most appropriate?",
    "o": [
      "To represent an application-specific error like InvalidStudentIDException.",
      "To handle file-not-found errors.",
      "To divide two integers safely.",
      "To check for null variables."
    ]
  },
  {
    "q": "What will happen if an exception is thrown in a try block and no catch block exists, but a finally block is present?",
    "o": [
      "The finally block will execute, then the program will crash.",
      "The exception will be silently ignored.",
      "The program will skip the finally block.",
      "Nothing will happen; execution continues as normal."
    ]
  },
  {
    "q": "Which statement is used to explicitly throw an exception in C#?",
    "o": [
      "throw new Exception(\"Error occurred\");",
      "raise new Exception(\"Error occurred\");",
      "Exception(\"Error occurred\");",
      "raise Exception(\"Error occurred\");"
    ]
  },
  {
    "q": "Which of the following will cause an OverflowException at runtime when arithmetic overflow occurs?",
    "c": "checked {\n    int x = int.MaxValue;\n    x = x + 1;\n    Console.WriteLine(x);\n}",
    "o": [
      "It throws an OverflowException.",
      "It prints a negative number.",
      "It compiles but shows a warning.",
      "Nothing happens."
    ]
  },
  {
    "q": "Why would you use a custom exception class instead of a built-in exception?",
    "o": [
      "To provide a more meaningful error specific to the application domain.",
      "To improve performance during exception handling.",
      "Because built-in exceptions are deprecated.",
      "To avoid using try-catch blocks."
    ]
  },
  {
    "q": "What is the correct way to wrap code that may throw exceptions?",
    "o": [
      "Use a try block followed by one or more catch blocks.",
      "Use an if statement before every line.",
      "Use a for loop to check errors.",
      "Use Console.ReadLine() inside the block."
    ]
  },
  {
    "q": "What will this code output?",
    "c": "try {\n    throw new Exception(\"Test\");\n} catch (Exception ex) {\n    Console.WriteLine(\"Caught: \" + ex.Message);\n} finally {\n    Console.WriteLine(\"Finally executed\");\n}",
    "o": [
      "Caught: Test\nFinally executed",
      "Caught: \nFinally executed",
      "Finally executed",
      "Caught: Test"
    ]
  },
  {
    "q": "What is a key benefit of using the 'finally' block?",
    "o": [
      "Ensures resource cleanup regardless of exception occurrence.",
      "Stops all exceptions from propagating.",
      "Hides exceptions from users.",
      "Only runs if no exception occurs."
    ]
  },
  {
    "q": "Which of these is a correctly defined custom exception class?",
    "o": [
      "public class InvalidAgeException : Exception { }",
      "class InvalidAgeException inherits Exception { }",
      "Exception InvalidAge = new Exception();",
      "def InvalidAgeException(Exception): pass"
    ]
  },
  {
    "q": "When is the 'checked' keyword most useful?",
    "o": [
      "When performing arithmetic operations that might overflow.",
      "When catching file I/O errors.",
      "When validating user input length.",
      "When working with strings and dates."
    ]
  },
  {
    "q": "What is the purpose of using 'throw;' without any arguments inside a catch block?",
    "o": [
      "To rethrow the original exception without resetting the stack trace.",
      "To throw a new exception with default settings.",
      "To ignore the current exception.",
      "To log the exception to a file."
    ]
  },
  {
    "q": "What happens when an exception is thrown and not caught in C#?",
    "o": [
      "The application terminates abruptly.",
      "The exception is silently ignored.",
      "The code in the finally block will be skipped.",
      "The program continues execution normally."
    ]
  },
  {
    "q": "Which keyword is used to define a block of code that will always execute, whether an exception is thrown or not?",
    "o": [
      "finally",
      "catch",
      "throw",
      "checked"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "try {\n    int[] arr = new int[2];\n    Console.WriteLine(arr[5]);\n} catch (IndexOutOfRangeException) {\n    Console.WriteLine(\"Index error\");\n} finally {\n    Console.WriteLine(\"Done\");\n}",
    "o": [
      "Index error\nDone",
      "Index error",
      "Done",
      "Compilation error"
    ]
  },
  {
    "q": "How do you declare a custom exception class in C#?",
    "o": [
      "public class MyException : Exception {}",
      "public MyException extends Exception {}",
      "class MyException implements Exception {}",
      "def MyException(Exception): pass"
    ]
  },
  {
    "q": "Which of the following throws an exception explicitly in C#?",
    "o": [
      "throw new InvalidOperationException(\"Invalid operation\");",
      "catch new InvalidOperationException(\"Invalid operation\");",
      "raise InvalidOperationException(\"Invalid operation\");",
      "exception InvalidOperationException(\"Invalid operation\");"
    ]
  },
  {
    "q": "What is the purpose of the 'unchecked' keyword in C#?",
    "o": [
      "To suppress overflow-checking for integral-type arithmetic operations.",
      "To catch unchecked exceptions automatically.",
      "To ensure arithmetic exceptions are always thrown.",
      "To handle null reference exceptions."
    ]
  },
  {
    "q": "Which of these statements about the finally block is TRUE?",
    "o": [
      "It runs even if an exception occurs or not.",
      "It only runs if an exception is thrown.",
      "It is optional after a catch block.",
      "It only runs if no exception is caught."
    ]
  },
  {
    "q": "Which exception is thrown when dividing by zero in C#?",
    "o": [
      "DivideByZeroException",
      "ArithmeticException",
      "InvalidOperationException",
      "NullReferenceException"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "try {\n    int result = checked(1000000 * 1000000);\n    Console.WriteLine(result);\n} catch (OverflowException e) {\n    Console.WriteLine(\"Overflow caught\");\n}",
    "o": [
      "Overflow caught",
      "1000000000000",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Why should custom exceptions inherit from System.Exception?",
    "o": [
      "To ensure they are compatible with try-catch blocks.",
      "To prevent compile-time errors.",
      "To use them as variables.",
      "To avoid garbage collection."
    ]
  },
  {
    "q": "Which block ensures cleanup code runs whether or not an exception is thrown?",
    "o": [
      "finally",
      "try",
      "catch",
      "throw"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "try {\n    int x = 10 / 0;\n} catch (DivideByZeroException) {\n    Console.WriteLine(\"Division error\");\n} finally {\n    Console.WriteLine(\"Cleanup\");\n}",
    "o": [
      "Division error\nCleanup",
      "Cleanup",
      "Division error",
      "Exception"
    ]
  },
  {
    "q": "How can you throw a custom exception with a message?",
    "o": [
      "throw new MyException(\"Custom error\");",
      "catch new MyException(\"Custom error\");",
      "raise MyException(\"Custom error\")",
      "new throw(MyException)"
    ]
  },
  {
    "q": "What is the correct way to create a custom exception?",
    "o": [
      "public class FileMissingException : Exception {}",
      "public class FileMissingException : BaseException {}",
      "class FileMissingException inherits Exception {}",
      "exception FileMissingException {}"
    ]
  },
  {
    "q": "Which exception type is thrown when trying to access a member on a null object?",
    "o": [
      "NullReferenceException",
      "InvalidOperationException",
      "ObjectDisposedException",
      "IndexOutOfRangeException"
    ]
  },
  {
    "q": "What does the 'checked' keyword do in C#?",
    "o": [
      "Enables overflow checking for arithmetic operations.",
      "Checks for null values during execution.",
      "Forces type casting in try blocks.",
      "Marks code that will always throw exceptions."
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "int a = int.MaxValue;\ntry {\n    int result = checked(a + 1);\n    Console.WriteLine(result);\n} catch (OverflowException) {\n    Console.WriteLine(\"Overflow detected\");\n}",
    "o": [
      "Overflow detected",
      "0",
      "-2147483648",
      "Compile time error"
    ]
  },
  {
    "q": "When should you use 'unchecked' in C#?",
    "o": [
      "To disable overflow checking in arithmetic expressions.",
      "To suppress all exceptions in a block.",
      "To ignore logical errors at runtime.",
      "To skip exception logging."
    ]
  },
  {
    "q": "Which statement about try-catch is correct?",
    "o": [
      "A try block must be followed by at least one catch or finally block.",
      "A try block can exist without any catch or finally block.",
      "Only catch blocks are allowed with try, not finally.",
      "Multiple finally blocks can follow one try."
    ]
  },
  {
    "q": "What will the following code do?",
    "c": "try {\n    string str = null;\n    Console.WriteLine(str.Length);\n} catch (Exception ex) {\n    Console.WriteLine(\"Error: \" + ex.Message);\n}",
    "o": [
      "Error: Object reference not set to an instance of an object.",
      "0",
      "Compile time error",
      "No output"
    ]
  },
  {
    "q": "What keyword is used in C# to re-throw the current exception inside a catch block?",
    "o": [
      "throw;",
      "raise;",
      "catch;",
      "exception;"
    ]
  },
  {
    "q": "Which of the following will correctly handle multiple types of exceptions?",
    "c": "try {\n    // code\n} catch (FormatException) {\n    Console.WriteLine(\"Format error\");\n} catch (Exception) {\n    Console.WriteLine(\"General error\");\n}",
    "o": [
      "The code will handle both specific and general exceptions correctly.",
      "Only the first catch block will ever execute.",
      "The second catch will override the first.",
      "The program will throw a compile-time error."
    ]
  },
  {
    "q": "Which method is commonly overridden in a custom exception class to return error details?",
    "o": [
      "ToString()",
      "Equals()",
      "GetData()",
      "Clone()"
    ]
  },
  {
    "q": "Which block is guaranteed to execute regardless of an exception being thrown?",
    "o": [
      "finally",
      "catch",
      "throw",
      "assert"
    ]
  },
  {
    "q": "What is the result of using 'unchecked' in arithmetic operations?",
    "o": [
      "Disables overflow checking, allowing wraparound values.",
      "Raises an exception when overflow occurs.",
      "Ensures type safety.",
      "Throws null if the operation fails."
    ]
  },
  {
    "q": "Which of the following represents a valid custom exception declaration?",
    "o": [
      "public class MyCustomException : ApplicationException {}",
      "public class MyCustomException : object {}",
      "public class MyCustomException : Error {}",
      "public class MyCustomException inherits Exception {}"
    ]
  },
  {
    "q": "What will the output be?",
    "c": "try {\n    int[] arr = new int[3];\n    Console.WriteLine(arr[5]);\n} catch (IndexOutOfRangeException) {\n    Console.WriteLine(\"Out of bounds\");\n}",
    "o": [
      "Out of bounds",
      "0",
      "5",
      "No output"
    ]
  },
  {
    "q": "What is the best practice when writing custom exception classes in C#?",
    "o": [
      "Inherit from Exception or ApplicationException and implement standard constructors.",
      "Always throw the base Exception class directly.",
      "Avoid adding constructors to the custom class.",
      "Use static methods instead of throwing."
    ]
  },
  {
    "q": "In which scenario will a catch block not be executed?",
    "o": [
      "When no exception is thrown in the try block.",
      "When finally is used instead.",
      "When the catch block is empty.",
      "When the exception is re-thrown."
    ]
  },
  {
    "q": "What will the following code do?",
    "c": "int a = 1000000;\nint b = 1000000;\ntry {\n    int result = checked(a * b);\n    Console.WriteLine(result);\n} catch (OverflowException) {\n    Console.WriteLine(\"Overflow occurred\");\n}",
    "o": [
      "Overflow occurred",
      "1000000000000",
      "0",
      "Compile error"
    ]
  },
  {
    "q": "What does the 'finally' block ensure in C# exception handling?",
    "o": [
      "That the code runs regardless of whether an exception occurred or not.",
      "That only one catch block executes.",
      "That no exception will ever occur.",
      "That exceptions are always suppressed."
    ]
  },
  {
    "q": "Which of the following throws a custom exception?",
    "c": "public class MyException : Exception {}\n\n...\n\nthrow new MyException();",
    "o": [
      "It correctly throws a custom exception.",
      "It results in a compile-time error.",
      "The custom class must end with 'Error'.",
      "Only built-in exceptions can be thrown."
    ]
  },
  {
    "q": "How do you catch all exceptions regardless of their type?",
    "o": [
      "catch (Exception ex)",
      "catch ()",
      "catch (BaseException ex)",
      "catch (object ex)"
    ]
  },
  {
    "q": "What will happen if a 'throw;' statement is used without an active exception?",
    "o": [
      "It causes a runtime error.",
      "It throws the base Exception.",
      "It silently does nothing.",
      "It compiles but skips the block."
    ]
  },
  {
    "q": "What is the result of using 'checked' during arithmetic operations?",
    "o": [
      "It throws an exception if an overflow occurs.",
      "It disables overflow checking.",
      "It catches divide-by-zero exceptions.",
      "It logs the overflow to the console."
    ]
  },
  {
    "q": "Which of these is the correct syntax for defining a custom exception?",
    "o": [
      "public class MyError : Exception { }",
      "class MyError inherits Exception { }",
      "define class MyError(Exception):",
      "public error MyError extends Exception { }"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try {\n    int x = 5 / 0;\n} catch (DivideByZeroException) {\n    Console.WriteLine(\"Cannot divide by zero\");\n} finally {\n    Console.WriteLine(\"Finally block executed\");\n}",
    "o": [
      "Cannot divide by zero\nFinally block executed",
      "Finally block executed",
      "Cannot divide by zero",
      "Exception thrown at runtime"
    ]
  },
  {
    "q": "In C#, what type of exceptions are typically used to represent application-specific errors?",
    "o": [
      "Custom exceptions derived from Exception",
      "Built-in exceptions only",
      "NullReferenceException",
      "System-defined errors only"
    ]
  },
  {
    "q": "When should you use 'unchecked' in C#?",
    "o": [
      "To allow arithmetic overflow without throwing exceptions",
      "To make all exceptions catchable",
      "To log overflow issues",
      "To ensure division always succeeds"
    ]
  },
  {
    "q": "What is the behavior of this code?",
    "c": "try {\n    int result = int.MaxValue + 10;\n    Console.WriteLine(result);\n} catch (OverflowException) {\n    Console.WriteLine(\"Overflow!\");\n}",
    "o": [
      "No exception will be thrown; result wraps around.",
      "An OverflowException will be thrown.",
      "It prints 'Overflow!'.",
      "It causes a compile-time error."
    ]
  },
  {
    "q": "Which block is executed regardless of whether an exception is thrown or not in C#?",
    "o": [
      "finally",
      "try",
      "catch",
      "throw"
    ]
  },
  {
    "q": "What is the purpose of using multiple catch blocks in a try-catch statement?",
    "o": [
      "To handle different types of exceptions separately",
      "To catch the same exception multiple times",
      "To prevent execution of finally block",
      "To suppress all exceptions silently"
    ]
  },
  {
    "q": "What happens if a catch block does not match the thrown exception type?",
    "o": [
      "The exception is propagated to the next higher context",
      "It is caught by the catch block",
      "It causes a compile-time error",
      "The program exits silently"
    ]
  },
  {
    "q": "What does the 'throw' statement do in C#?",
    "o": [
      "It signals the occurrence of an exception",
      "It terminates the program",
      "It logs the error to the console",
      "It retries the code block"
    ]
  },
  {
    "q": "Which keyword is used to rethrow the current exception in a catch block?",
    "o": [
      "throw",
      "rethrow",
      "return",
      "catch"
    ]
  },
  {
    "q": "What is the output of the following code snippet?",
    "c": "try {\n    int[] arr = new int[2];\n    Console.WriteLine(arr[5]);\n} catch (IndexOutOfRangeException ex) {\n    Console.WriteLine(\"Index error\");\n} finally {\n    Console.WriteLine(\"Done\");\n}",
    "o": [
      "Index error\nDone",
      "Index error",
      "Done",
      "Exception not caught"
    ]
  },
  {
    "q": "How do you define a custom exception in C#?",
    "o": [
      "By creating a class that inherits from Exception",
      "By overriding the System.Exception class directly",
      "By creating a class that implements IError",
      "By using the keyword 'custom exception'"
    ]
  },
  {
    "q": "Which block is mandatory in a try-catch-finally structure?",
    "o": [
      "try",
      "catch",
      "finally",
      "None"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "try {\n    checked {\n        int val = int.MaxValue + 1;\n        Console.WriteLine(val);\n    }\n} catch (OverflowException) {\n    Console.WriteLine(\"Overflow occurred\");\n}",
    "o": [
      "Overflow occurred",
      "Compile-time error",
      "Runtime crash",
      "2147483648"
    ]
  },
  {
    "q": "Why would you use the 'unchecked' keyword in C#?",
    "o": [
      "To suppress overflow checking during arithmetic operations",
      "To enable strict overflow rules",
      "To handle null reference exceptions",
      "To check for object types at runtime"
    ]
  },
  {
    "q": "What is the purpose of a finally block in C#?",
    "o": [
      "To execute code regardless of whether an exception occurs or not",
      "To handle only specific exceptions",
      "To skip execution if no exception occurs",
      "To catch and rethrow exceptions"
    ]
  },
  {
    "q": "What will be the output of the following code snippet?",
    "c": "try\n{\n    int x = 10;\n    int y = 0;\n    int result = x / y;\n}\ncatch (DivideByZeroException)\n{\n    Console.WriteLine(\"Cannot divide by zero.\");\n}\nfinally\n{\n    Console.WriteLine(\"Execution completed.\");\n}",
    "o": [
      "Cannot divide by zero.\nExecution completed.",
      "Execution completed.",
      "Cannot divide by zero.",
      "Runtime error"
    ]
  },
  {
    "q": "Which of the following correctly throws an exception in C#?",
    "o": [
      "throw new Exception(\"Something went wrong\");",
      "throw Exception(\"Something went wrong\")",
      "raise new Exception(\"Something went wrong\")",
      "throw Exception[\"Something went wrong\"]"
    ]
  },
  {
    "q": "What will be printed by the following code?",
    "c": "try\n{\n    int a = 5;\n    int b = 2;\n    Console.WriteLine(a / b);\n}\ncatch (Exception)\n{\n    Console.WriteLine(\"Error occurred\");\n}\nfinally\n{\n    Console.WriteLine(\"Done\");\n}",
    "o": [
      "2\nDone",
      "2",
      "Error occurred\nDone",
      "Error occurred"
    ]
  },
  {
    "q": "What is the purpose of a custom exception class in C#?",
    "o": [
      "To define application-specific error handling logic",
      "To avoid using try-catch blocks",
      "To override .NET's exception messages",
      "To throw errors without using the 'throw' keyword"
    ]
  },
  {
    "q": "What will happen when the following code runs?",
    "c": "public class MyException : Exception {}\n\nthrow new MyException();",
    "o": [
      "A MyException is thrown and can be caught by a catch block",
      "The compiler throws an error because custom exceptions are not allowed",
      "Nothing happens unless MyException overrides ToString()",
      "The program ignores the exception"
    ]
  },
  {
    "q": "Which of the following uses the 'checked' keyword correctly in C#?",
    "o": [
      "int result = checked(a * b);",
      "checked int result = a * b;",
      "int result = (checked)a * b;",
      "int result = a * checked(b);"
    ]
  },
  {
    "q": "What is the effect of using 'unchecked' in a block?",
    "o": [
      "It disables overflow-checking for arithmetic operations",
      "It prevents exceptions from being caught",
      "It logs arithmetic exceptions",
      "It forces overflow-checking during runtime"
    ]
  },
  {
    "q": "What will be the result of this code execution?",
    "c": "checked\n{\n    int max = int.MaxValue;\n    int overflow = max + 1;\n    Console.WriteLine(overflow);\n}",
    "o": [
      "Runtime exception due to overflow",
      "Overflow is ignored and wraps around",
      "0",
      "2147483647"
    ]
  },
  {
    "q": "Which statement is true about exception handling in C#?",
    "o": [
      "A try block must be followed by either a catch block or a finally block",
      "A try block must be followed by both catch and finally blocks",
      "Only one catch block is allowed after a try block",
      "finally block is required after every try block"
    ]
  },
  {
    "q": "Which block is guaranteed to execute regardless of whether an exception is thrown or not?",
    "o": [
      "finally",
      "try",
      "catch",
      "throw"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "try\n{\n    throw new InvalidOperationException(\"Invalid operation\");\n}\ncatch (InvalidOperationException ex)\n{\n    Console.WriteLine(ex.Message);\n}\nfinally\n{\n    Console.WriteLine(\"Cleanup done.\");\n}",
    "o": [
      "Invalid operation\nCleanup done.",
      "Invalid operation",
      "Cleanup done.",
      "Exception thrown"
    ]
  },
  {
    "q": "Which of the following is a valid way to define a custom exception in C#?",
    "o": [
      "public class MyError : Exception {}",
      "public exception MyError : Exception {}",
      "class MyError inherits Exception {}",
      "def class MyError extends Exception"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "try\n{\n    Console.WriteLine(\"Inside try\");\n    return;\n}\nfinally\n{\n    Console.WriteLine(\"Inside finally\");\n}",
    "o": [
      "Inside try\nInside finally",
      "Inside try",
      "Inside finally",
      "No output"
    ]
  },
  {
    "q": "What happens when an exception is not caught in a try-catch block?",
    "o": [
      "The program terminates with a runtime error",
      "The exception is ignored silently",
      "The exception is converted to a warning",
      "finally block is skipped"
    ]
  },
  {
    "q": "What is the role of the 'throw' statement in C#?",
    "o": [
      "To signal the occurrence of an exception",
      "To skip the catch block",
      "To suppress runtime errors",
      "To terminate a loop"
    ]
  },
  {
    "q": "Which of the following code segments causes a compile-time error?",
    "c": "try\n{\n    Console.WriteLine(\"Start\");\n}\ncatch\n{\n    Console.WriteLine(\"Error\");\n}\nfinally\n{\n    Console.WriteLine(\"Finally block\");\n}\nthrow;",
    "o": [
      "throw;",
      "catch\n{\n    Console.WriteLine(\"Error\");\n}",
      "finally\n{\n    Console.WriteLine(\"Finally block\");\n}",
      "Console.WriteLine(\"Start\");"
    ]
  },
  {
    "q": "Which of the following uses the 'unchecked' keyword to allow overflow without exception?",
    "o": [
      "int result = unchecked(a + b);",
      "unchecked int result = a + b;",
      "int result = a + unchecked b;",
      "int result = a + b unchecked;"
    ]
  },
  {
    "q": "Which method from the Exception class returns a string representation of the current exception?",
    "o": [
      "ToString()",
      "Message()",
      "StackTrace()",
      "GetType()"
    ]
  },
  {
    "q": "What will the following code produce?",
    "c": "public class CustomException : Exception\n{\n    public CustomException(string message) : base(message) {}\n}\n\ntry\n{\n    throw new CustomException(\"Custom error occurred\");\n}\ncatch (CustomException e)\n{\n    Console.WriteLine(e.Message);\n}",
    "o": [
      "Custom error occurred",
      "System.Exception",
      "Error",
      "No output"
    ]
  },
  {
    "q": "Which keyword is used to manually raise an exception in C#?",
    "o": [
      "throw",
      "raise",
      "error",
      "exception"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "try\n{\n    int[] arr = new int[3];\n    Console.WriteLine(arr[5]);\n}\ncatch (IndexOutOfRangeException)\n{\n    Console.WriteLine(\"Index error\");\n}",
    "o": [
      "Index error",
      "5",
      "Runtime exception",
      "No output"
    ]
  },
  {
    "q": "Which of the following best describes a custom exception class in C#?",
    "o": [
      "A user-defined class that inherits from System.Exception",
      "A class that implements IError interface",
      "A static class with error messages",
      "A sealed class for logging"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "try\n{\n    int val = int.MaxValue;\n    int result = checked(val + 1);\n    Console.WriteLine(result);\n}\ncatch (OverflowException)\n{\n    Console.WriteLine(\"Overflow occurred\");\n}",
    "o": [
      "Overflow occurred",
      "2147483647",
      "-2147483648",
      "Compile-time error"
    ]
  },
  {
    "q": "What happens if an exception is thrown inside a try block, but there is no matching catch block?",
    "o": [
      "The exception is propagated up the call stack",
      "The exception is ignored",
      "The program continues without interruption",
      "The finally block is skipped"
    ]
  },
  {
    "q": "Choose the correct syntax to wrap code in an unchecked context:",
    "o": [
      "unchecked { int result = a * b; }",
      "unchecked: int result = a * b;",
      "int result = a * b unchecked;",
      "unchecked(int result = a * b);"
    ]
  },
  {
    "q": "Which of the following exception types should be used for arithmetic overflows when checked context is used?",
    "o": [
      "OverflowException",
      "DivideByZeroException",
      "IndexOutOfRangeException",
      "FormatException"
    ]
  },
  {
    "q": "What is the base class of all exceptions in C#?",
    "o": [
      "System.Exception",
      "System.BaseException",
      "System.Error",
      "System.SystemException"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "try\n{\n    Console.WriteLine(\"Start\");\n    throw new Exception();\n}\nfinally\n{\n    Console.WriteLine(\"In finally\");\n}",
    "o": [
      "Start\nIn finally",
      "Start",
      "In finally",
      "Exception"
    ]
  },
  {
    "q": "Which keyword is used to ensure overflow checking in arithmetic operations?",
    "o": [
      "checked",
      "overflow",
      "trycheck",
      "ensure"
    ]
  },
  {
    "q": "Which of the following statements is true about the 'catch' block in C#?",
    "o": [
      "It is used to handle exceptions thrown in the associated try block",
      "It must always be followed by a 'finally' block",
      "It can only catch system-defined exceptions",
      "It automatically rethrows the exception"
    ]
  },
  {
    "q": "What will be printed when the following code is executed?",
    "c": "try\n{\n    Console.WriteLine(\"Trying...\");\n    throw new NullReferenceException();\n}\ncatch (Exception)\n{\n    Console.WriteLine(\"Caught an exception\");\n}\nfinally\n{\n    Console.WriteLine(\"Finally block executed\");\n}",
    "o": [
      "Trying...\nCaught an exception\nFinally block executed",
      "Caught an exception\nFinally block executed",
      "Trying...\nFinally block executed",
      "Caught an exception"
    ]
  },
  {
    "q": "Which of the following is required to create a custom exception in C#?",
    "o": [
      "Inheriting from the Exception class",
      "Overriding the ToString() method",
      "Implementing IException interface",
      "Using the 'sealed' keyword"
    ]
  },
  {
    "q": "What will be the result of executing this code?",
    "c": "try\n{\n    throw new ApplicationException(\"App error\");\n}\ncatch (ApplicationException ex)\n{\n    Console.WriteLine(ex.Message);\n}",
    "o": [
      "App error",
      "ApplicationException",
      "System error",
      "Runtime terminated"
    ]
  },
  {
    "q": "What happens if code inside a 'finally' block throws an exception?",
    "o": [
      "It overrides any previous exception and propagates",
      "It is ignored silently",
      "It is caught by the previous catch block",
      "It prevents the program from compiling"
    ]
  },
  {
    "q": "What does the 'checked' keyword do in C#?",
    "o": [
      "It enforces overflow checking for integral-type arithmetic operations",
      "It skips overflow checking",
      "It prevents any kind of exceptions",
      "It validates logical expressions"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "int x = int.MaxValue;\nint y;\ntry\n{\n    y = unchecked(x + 1);\n    Console.WriteLine(y);\n}\ncatch\n{\n    Console.WriteLine(\"Error\");\n}",
    "o": [
      "-2147483648",
      "Overflow occurred",
      "Error",
      "2147483647"
    ]
  },
  {
    "q": "Which part of this exception class is essential for a custom exception?",
    "c": "public class InvalidAgeException : Exception\n{\n    public InvalidAgeException(string message) : base(message) {}\n}",
    "o": [
      "The constructor that calls the base class constructor",
      "Overriding GetType() method",
      "Using a sealed modifier",
      "Implementing IDisposable"
    ]
  },
  {
    "q": "In which of the following situations is it ideal to use a custom exception?",
    "o": [
      "When the application has domain-specific error cases",
      "When the system throws a runtime error",
      "To handle syntax errors",
      "To improve compiler error messages"
    ]
  },
  {
    "q": "Which output will this code generate?",
    "c": "try\n{\n    int x = 1000000;\n    int y = 1000000;\n    int z = checked(x * y);\n    Console.WriteLine(z);\n}\ncatch (OverflowException)\n{\n    Console.WriteLine(\"Overflow detected\");\n}",
    "o": [
      "Overflow detected",
      "1000000000000",
      "0",
      "Compile-time error"
    ]
  },
  {
    "q": "Which of the following is the correct way to rethrow the same exception in a catch block?",
    "o": [
      "throw;",
      "throw ex;",
      "raise;",
      "throw new Exception();"
    ]
  },
  {
    "q": "What will be the output of this code snippet?",
    "c": "try\n{\n    int x = 10;\n    int y = 0;\n    int z = x / y;\n}\ncatch (DivideByZeroException)\n{\n    Console.WriteLine(\"Cannot divide by zero\");\n}\nfinally\n{\n    Console.WriteLine(\"Execution complete\");\n}",
    "o": [
      "Cannot divide by zero\nExecution complete",
      "DivideByZeroException",
      "Execution complete",
      "Runtime error"
    ]
  },
  {
    "q": "Which keyword is used to allow arithmetic overflow without throwing an exception?",
    "o": [
      "unchecked",
      "ignore",
      "safe",
      "noscan"
    ]
  },
  {
    "q": "What will happen when this code is executed?",
    "c": "try\n{\n    int result = checked(2147483647 + 1);\n}\ncatch (OverflowException)\n{\n    Console.WriteLine(\"Overflow occurred\");\n}",
    "o": [
      "Overflow occurred",
      "2147483648",
      "0",
      "No output"
    ]
  },
  {
    "q": "Which of the following correctly throws a new custom exception?",
    "o": [
      "throw new MyCustomException(\"Something went wrong\");",
      "throw MyCustomException(\"Something went wrong\");",
      "raise new MyCustomException(\"Something went wrong\")",
      "throw exception(\"Something went wrong\");"
    ]
  },
  {
    "q": "Why would you use a `finally` block in C#?",
    "o": [
      "To ensure cleanup code runs regardless of an exception",
      "To catch any unhandled exceptions",
      "To restart the application",
      "To suppress compiler warnings"
    ]
  },
  {
    "q": "What will be the result of this code?",
    "c": "try\n{\n    throw new Exception(\"Main error\");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine(\"Caught: \" + ex.Message);\n    throw;\n}",
    "o": [
      "Caught: Main error",
      "Exception",
      "Main error\nCaught again",
      "Unhandled exception"
    ]
  },
  {
    "q": "Which of the following is NOT a standard .NET exception?",
    "o": [
      "FileNotUploadedException",
      "DivideByZeroException",
      "NullReferenceException",
      "IndexOutOfRangeException"
    ]
  },
  {
    "q": "How many catch blocks can follow a single try block?",
    "o": [
      "Multiple",
      "Only one",
      "None",
      "Exactly three"
    ]
  },
  {
    "q": "What does the following code output?",
    "c": "try\n{\n    Console.WriteLine(\"Start\");\n    throw new Exception();\n}\ncatch (Exception)\n{\n    Console.WriteLine(\"Caught\");\n}\nfinally\n{\n    Console.WriteLine(\"Always runs\");\n}",
    "o": [
      "Start\nCaught\nAlways runs",
      "Start\nAlways runs",
      "Caught\nAlways runs",
      "Caught"
    ]
  },
  {
    "q": "What is the primary role of the `finally` block in C# exception handling?",
    "o": [
      "To execute cleanup code regardless of whether an exception occurred",
      "To catch only runtime exceptions",
      "To log exceptions to a file",
      "To define fallback values for thrown exceptions"
    ]
  },
  {
    "q": "What will be printed by the following C# code?",
    "c": "try\n{\n    Console.WriteLine(\"In try\");\n    throw new InvalidOperationException();\n}\ncatch (NullReferenceException)\n{\n    Console.WriteLine(\"Caught NullReferenceException\");\n}\nfinally\n{\n    Console.WriteLine(\"Finally block\");\n}",
    "o": [
      "In try\nFinally block",
      "In try\nCaught NullReferenceException\nFinally block",
      "Caught NullReferenceException\nFinally block",
      "In try\nCaught InvalidOperationException\nFinally block"
    ]
  },
  {
    "q": "How do you define a custom exception in C#?",
    "o": [
      "By creating a class that inherits from System.Exception",
      "By using the `exception` keyword",
      "By implementing the IException interface",
      "By declaring a delegate with an error handler"
    ]
  },
  {
    "q": "Which of the following code snippets demonstrates the correct usage of the `checked` keyword?",
    "c": "int a = int.MaxValue;\nint result = checked(a + 1);",
    "o": [
      "It throws an OverflowException at runtime",
      "It silently wraps around to a negative value",
      "It causes a compile-time error",
      "It returns 0"
    ]
  },
  {
    "q": "Which is the most suitable situation to use the `unchecked` keyword?",
    "o": [
      "When overflow checking is not needed for performance reasons",
      "When validating exception messages",
      "When working with nullable types",
      "When implementing a try-catch block"
    ]
  },
  {
    "q": "What happens if a `throw` statement is used without specifying an exception object?",
    "o": [
      "It rethrows the current exception",
      "It causes a compile-time error",
      "It throws a generic Exception",
      "It suppresses the original exception"
    ]
  },
  {
    "q": "What will be printed by this code?",
    "c": "try\n{\n    int[] arr = new int[2];\n    arr[5] = 10;\n}\ncatch (IndexOutOfRangeException)\n{\n    Console.WriteLine(\"Index error caught\");\n}",
    "o": [
      "Index error caught",
      "5",
      "Unhandled exception",
      "Array size exceeded"
    ]
  },
  {
    "q": "Which statement is true about exception propagation in C#?",
    "o": [
      "If an exception is not caught in a method, it propagates up the call stack",
      "Exceptions are only handled in the method where they are thrown",
      "Only runtime exceptions can propagate",
      "Exception propagation happens only with built-in exceptions"
    ]
  },
  {
    "q": "Choose the correct constructor call for a custom exception with a message:",
    "c": "public class LimitExceededException : Exception\n{\n    public LimitExceededException(string message) : base(message) {}\n}",
    "o": [
      "throw new LimitExceededException(\"Limit exceeded\");",
      "raise LimitExceededException(\"Limit exceeded\")",
      "throw LimitExceededException[\"Limit exceeded\"]",
      "throw LimitExceededException(\"Limit exceeded\")"
    ]
  },
  {
    "q": "What will this code produce?",
    "c": "try\n{\n    Console.WriteLine(\"Running...\");\n}\nfinally\n{\n    Console.WriteLine(\"Cleaning up...\");\n}",
    "o": [
      "Running...\nCleaning up...",
      "Cleaning up...\nRunning...",
      "Only Running...",
      "Only Cleaning up..."
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try\n{\n    int[] nums = new int[3];\n    Console.WriteLine(nums[3]);\n}\ncatch (IndexOutOfRangeException ex)\n{\n    Console.WriteLine(\"Out of bounds\");\n}",
    "o": [
      "Out of bounds",
      "3",
      "Unhandled exception",
      "0"
    ]
  },
  {
    "q": "Which of the following is a benefit of using custom exception classes in C#?",
    "o": [
      "They provide more meaningful error messages for specific business rules",
      "They improve runtime performance",
      "They reduce the need for try-catch blocks",
      "They replace standard exception types"
    ]
  },
  {
    "q": "What happens when an exception is thrown inside a catch block?",
    "o": [
      "The new exception replaces the original and propagates",
      "The original exception is rethrown",
      "The program silently terminates",
      "The finally block is skipped"
    ]
  },
  {
    "q": "What will be the result of this code snippet?",
    "c": "try\n{\n    Console.WriteLine(\"Begin\");\n    throw new FormatException();\n}\ncatch (FormatException)\n{\n    Console.WriteLine(\"Handled FormatException\");\n}\nfinally\n{\n    Console.WriteLine(\"Done\");\n}",
    "o": [
      "Begin\nHandled FormatException\nDone",
      "Begin\nDone",
      "Handled FormatException",
      "Begin\nHandled FormatException"
    ]
  },
  {
    "q": "Which of the following demonstrates correct use of an `unchecked` context?",
    "c": "int max = int.MaxValue;\nint result = unchecked(max + 1);",
    "o": [
      "No exception is thrown; result wraps to negative",
      "An OverflowException is thrown",
      "A compile-time error occurs",
      "Value stays at MaxValue"
    ]
  },
  {
    "q": "Why might you use `throw;` instead of `throw ex;` inside a catch block?",
    "o": [
      "`throw;` preserves the original stack trace",
      "`throw;` throws a different exception type",
      "`throw;` logs the error automatically",
      "`throw;` prevents nested exceptions"
    ]
  },
  {
    "q": "What does this custom exception code do?",
    "c": "public class AgeException : Exception\n{\n    public AgeException(string message) : base(message) {}\n}",
    "o": [
      "It defines a custom exception with a message",
      "It overrides the system exception handler",
      "It automatically logs the error to a file",
      "It handles all types of exceptions"
    ]
  },
  {
    "q": "What keyword combination enables overflow detection in arithmetic operations?",
    "o": [
      "checked",
      "verified",
      "try-catch",
      "guarded"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "try\n{\n    int x = 5;\n    int y = 0;\n    Console.WriteLine(x / y);\n}\ncatch (DivideByZeroException ex)\n{\n    Console.WriteLine(\"Cannot divide by zero\");\n}",
    "o": [
      "Cannot divide by zero",
      "0",
      "Unhandled exception",
      "DivideByZero"
    ]
  },
  {
    "q": "Which situation is best handled by creating a custom exception?",
    "o": [
      "When enforcing domain-specific rules like \"NegativeDepositException\"",
      "When catching a missing file error",
      "When handling network timeouts",
      "When parsing JSON"
    ]
  },
  {
    "q": "What will be the output of the following C# code?",
    "c": "try\n{\n    Console.WriteLine(\"A\");\n    throw new Exception();\n    Console.WriteLine(\"B\");\n}\ncatch\n{\n    Console.WriteLine(\"C\");\n}\nfinally\n{\n    Console.WriteLine(\"D\");\n}",
    "o": [
      "A\nC\nD",
      "A\nB\nC\nD",
      "A\nD",
      "C\nD"
    ]
  },
  {
    "q": "Which of the following is a correct way to create a custom exception named `InvalidAgeException`?",
    "o": [
      "public class InvalidAgeException : Exception {}",
      "public InvalidAgeException : Exception {}",
      "class InvalidAgeException inherits Exception {}",
      "Exception InvalidAgeException() {}"
    ]
  },
  {
    "q": "What happens when an exception is not caught in any catch block?",
    "o": [
      "It propagates up the call stack",
      "It gets automatically logged",
      "It is silently ignored",
      "The application retries the operation"
    ]
  },
  {
    "q": "Which of the following best describes the `finally` block?",
    "o": [
      "It always executes regardless of whether an exception occurs",
      "It executes only if an exception is thrown",
      "It skips execution if there is no catch block",
      "It overrides catch behavior"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "try\n{\n    int x = int.MaxValue;\n    int y = checked(x + 1);\n}\ncatch (OverflowException)\n{\n    Console.WriteLine(\"Overflow detected\");\n}",
    "o": [
      "Overflow detected",
      "2147483648",
      "0",
      "No output"
    ]
  },
  {
    "q": "Which is the correct way to throw an exception manually?",
    "o": [
      "throw new Exception(\"Manual error\");",
      "raise Exception(\"Manual error\")",
      "Exception(\"Manual error\").throw();",
      "throw Exception[];"
    ]
  },
  {
    "q": "What is the purpose of the `unchecked` keyword in C#?",
    "o": [
      "To suppress overflow checking during arithmetic operations",
      "To enforce strict exception handling",
      "To disable all catch blocks temporarily",
      "To convert runtime exceptions into compile-time warnings"
    ]
  },
  {
    "q": "What will this code snippet output?",
    "c": "try\n{\n    int result = 100 / 0;\n    Console.WriteLine(\"Success\");\n}\ncatch (DivideByZeroException)\n{\n    Console.WriteLine(\"Math error\");\n}\nfinally\n{\n    Console.WriteLine(\"End\");\n}",
    "o": [
      "Math error\nEnd",
      "Success\nEnd",
      "0\nEnd",
      "End"
    ]
  },
  {
    "q": "Why should custom exception classes inherit from `System.Exception`?",
    "o": [
      "To be compatible with the C# exception handling model",
      "To prevent compiler errors",
      "To enable multiple inheritance",
      "To override the garbage collector behavior"
    ]
  },
  {
    "q": "Which of the following statements about the `throw` keyword is true?",
    "o": [
      "`throw` is used to signal the occurrence of an exceptional condition",
      "`throw` is optional in try-catch blocks",
      "`throw` only works inside constructors",
      "`throw` is used to end a method abruptly without error"
    ]
  },
  {
    "q": "Which of the following correctly rethrows the original exception in a catch block?",
    "o": [
      "throw;",
      "throw ex;",
      "raise;",
      "rethrow();"
    ]
  },
  {
    "q": "What does this C# code do?",
    "c": "public class FileLoadException : Exception\n{\n    public FileLoadException(string msg) : base(msg) {}\n}",
    "o": [
      "Creates a custom exception that can accept a message",
      "Catches system-level file errors",
      "Overrides default constructor behavior",
      "Automatically logs file errors"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try\n{\n    Console.WriteLine(\"Start\");\n    int.Parse(\"abc\");\n}\ncatch (FormatException)\n{\n    Console.WriteLine(\"Invalid format\");\n}\nfinally\n{\n    Console.WriteLine(\"Finally block\");\n}",
    "o": [
      "Start\nInvalid format\nFinally block",
      "Invalid format\nFinally block",
      "Start\nFinally block",
      "Invalid format"
    ]
  },
  {
    "q": "What keyword ensures an arithmetic overflow throws an exception?",
    "o": [
      "checked",
      "verified",
      "safe",
      "overflow"
    ]
  },
  {
    "q": "Which is a valid reason to use a custom exception class?",
    "o": [
      "To represent domain-specific error conditions",
      "To replace standard exception types",
      "To catch all types of runtime errors",
      "To improve compile-time safety"
    ]
  },
  {
    "q": "What will be printed by this code?",
    "c": "try\n{\n    throw new ApplicationException(\"App error\");\n}\ncatch (ApplicationException ex)\n{\n    Console.WriteLine(ex.Message);\n}",
    "o": [
      "App error",
      "ApplicationException",
      "Exception thrown",
      "Handled"
    ]
  },
  {
    "q": "How does the `finally` block behave when an exception occurs and is not caught?",
    "o": [
      "It still executes before program termination",
      "It is skipped entirely",
      "It executes only if catch exists",
      "It delays the exception"
    ]
  },
  {
    "q": "Which scenario is best suited for `unchecked`?",
    "o": [
      "When overflow detection is unnecessary for performance reasons",
      "When debugging overflow exceptions",
      "When logging every arithmetic operation",
      "When using floating-point operations"
    ]
  },
  {
    "q": "What does the following code demonstrate?",
    "c": "try\n{\n    int x = 1000 * 1000 * 1000;\n}\ncatch (OverflowException)\n{\n    Console.WriteLine(\"Overflow!\");\n}",
    "o": [
      "Without `checked`, this may not throw an exception",
      "OverflowException is always thrown",
      "OverflowException is caught and ignored",
      "Runtime will crash"
    ]
  },
  {
    "q": "Which of the following is true about `try-catch-finally` in C#?",
    "o": [
      "The finally block executes even if an exception is not thrown",
      "The finally block is only optional when catch is present",
      "The catch block is always mandatory",
      "try cannot be used without catch"
    ]
  },
  {
    "q": "What will be the result of the following C# code?",
    "c": "try\n{\n    int x = 10;\n    int y = 0;\n    int z = x / y;\n    Console.WriteLine(z);\n}\ncatch (DivideByZeroException ex)\n{\n    Console.WriteLine(\"Division by zero!\");\n}",
    "o": [
      "Division by zero!",
      "0",
      "Infinity",
      "Unhandled Exception"
    ]
  },
  {
    "q": "Which statement is true about exception propagation in C#?",
    "o": [
      "If not handled, exceptions move up the call stack until caught or the program crashes",
      "Exceptions are automatically suppressed by the runtime",
      "Unhandled exceptions are logged and ignored",
      "C# retries failed operations automatically"
    ]
  },
  {
    "q": "What will be printed by this code?",
    "c": "try\n{\n    Console.WriteLine(\"Before error\");\n    throw new NullReferenceException();\n}\ncatch\n{\n    Console.WriteLine(\"Caught\");\n}\nfinally\n{\n    Console.WriteLine(\"Cleanup\");\n}",
    "o": [
      "Before error\nCaught\nCleanup",
      "Before error\nCleanup",
      "Caught\nCleanup",
      "Before error\nCaught"
    ]
  },
  {
    "q": "Which of the following is true about the `checked` keyword in C#?",
    "o": [
      "It forces runtime overflow checking for integral types",
      "It prevents logical errors in floating point operations",
      "It verifies null references at compile time",
      "It restricts exception propagation"
    ]
  },
  {
    "q": "What is the correct way to define a custom exception with an additional property?",
    "o": [
      "public class MyException : Exception { public int Code { get; set; } }",
      "exception MyException : Exception { public int Code; }",
      "public MyException inherits Exception { int Code; }",
      "Exception MyException(int Code) { }"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "try\n{\n    int value = unchecked(int.MaxValue + 1);\n    Console.WriteLine(value);\n}\ncatch (OverflowException)\n{\n    Console.WriteLine(\"Overflow!\");\n}",
    "o": [
      "-2147483648",
      "Overflow!",
      "0",
      "Unhandled Exception"
    ]
  },
  {
    "q": "Which is a valid reason to use a `finally` block?",
    "o": [
      "To ensure cleanup code runs regardless of exceptions",
      "To suppress runtime errors silently",
      "To catch any unhandled exceptions",
      "To optimize arithmetic performance"
    ]
  },
  {
    "q": "What does this code demonstrate?",
    "c": "try\n{\n    throw new ArgumentException(\"Invalid input\");\n}\ncatch (ArgumentException e)\n{\n    Console.WriteLine(e.Message);\n}",
    "o": [
      "Manual exception throwing and catching",
      "Implicit exception conversion",
      "Logging exceptions automatically",
      "Uncaught runtime exception"
    ]
  },
  {
    "q": "Which of the following will suppress overflow exceptions?",
    "o": [
      "unchecked",
      "checked",
      "finally",
      "suppress"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "try\n{\n    Console.WriteLine(\"Try\");\n}\nfinally\n{\n    Console.WriteLine(\"Finally\");\n}",
    "o": [
      "Try\nFinally",
      "Try",
      "Finally",
      "No output"
    ]
  },
  {
    "q": "What will this C# code print?",
    "c": "try\n{\n    Console.WriteLine(\"Inside try\");\n    throw new Exception(\"Boom\");\n}\nfinally\n{\n    Console.WriteLine(\"In finally\");\n}",
    "o": [
      "Inside try\nIn finally",
      "In finally\nInside try",
      "Boom",
      "Nothing"
    ]
  },
  {
    "q": "Which keyword is used to define a code block that should always execute, even if an exception is thrown?",
    "o": [
      "finally",
      "catch",
      "throw",
      "checked"
    ]
  },
  {
    "q": "What will be the output of this code snippet?",
    "c": "try\n{\n    int[] arr = new int[2];\n    Console.WriteLine(arr[5]);\n}\ncatch (IndexOutOfRangeException)\n{\n    Console.WriteLine(\"Index error\");\n}",
    "o": [
      "Index error",
      "5",
      "Runtime error",
      "Nothing"
    ]
  },
  {
    "q": "Why might you use a `custom exception` in C#?",
    "o": [
      "To provide more meaningful and domain-specific error messages",
      "To bypass standard exception logging",
      "To avoid using try-catch blocks",
      "To automatically fix errors at runtime"
    ]
  },
  {
    "q": "Which is the correct way to use the `throw` keyword inside a catch block to rethrow the original exception?",
    "o": [
      "throw;",
      "throw ex;",
      "rethrow();",
      "throw new Exception();"
    ]
  },
  {
    "q": "What is the result of executing this code?",
    "c": "int a = int.MaxValue;\nint b = checked(a + 1);",
    "o": [
      "An OverflowException is thrown",
      "The value wraps around to negative",
      "The value becomes zero",
      "No exception is thrown"
    ]
  },
  {
    "q": "What is the role of `unchecked` in C#?",
    "o": [
      "It disables overflow checking for integral-type arithmetic operations",
      "It checks for exceptions at compile time",
      "It prevents runtime exceptions from being logged",
      "It skips the finally block"
    ]
  },
  {
    "q": "How do you define a custom exception class named `ValidationError`?",
    "o": [
      "public class ValidationError : Exception {}",
      "Exception ValidationError() {}",
      "define ValidationError : Exception {}",
      "public class ValidationError implements Exception {}"
    ]
  },
  {
    "q": "Which of the following code snippets will definitely execute even if an exception occurs?",
    "o": [
      "Code inside the finally block",
      "Code after the try-catch block",
      "Code inside the catch block",
      "Code in the constructor"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "try\n{\n    int value = checked(100000 * 100000);\n    Console.WriteLine(value);\n}\ncatch (OverflowException)\n{\n    Console.WriteLine(\"Overflow occurred\");\n}",
    "o": [
      "Overflow occurred",
      "10000000000",
      "0",
      "No output"
    ]
  },
  {
    "q": "What does the following C# code demonstrate?",
    "c": "try\n{\n    int x = int.MaxValue;\n    int y = checked(x + 1);\n}\ncatch (OverflowException)\n{\n    Console.WriteLine(\"Overflow caught\");\n}",
    "o": [
      "Use of checked context to detect overflow",
      "Use of unchecked block to allow overflow",
      "Casting exception to overflow handler",
      "Invalid use of catch block"
    ]
  },
  {
    "q": "What is a correct purpose of a `finally` block in exception handling?",
    "o": [
      "To ensure that cleanup code runs regardless of an exception",
      "To provide a backup exception handler",
      "To validate exception types at runtime",
      "To log only unhandled exceptions"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "try\n{\n    Console.WriteLine(\"Start\");\n    int[] arr = null;\n    Console.WriteLine(arr.Length);\n}\ncatch (NullReferenceException)\n{\n    Console.WriteLine(\"Null reference\");\n}\nfinally\n{\n    Console.WriteLine(\"End\");\n}",
    "o": [
      "Start\nNull reference\nEnd",
      "Null reference\nEnd",
      "Start\nEnd",
      "NullReferenceException"
    ]
  },
  {
    "q": "When is it appropriate to throw a custom exception?",
    "o": [
      "When you want to represent a specific business logic error",
      "When default exceptions are unavailable",
      "When you want to ignore exceptions",
      "When you want to avoid using try-catch"
    ]
  },
  {
    "q": "Which statement about `unchecked` blocks is true?",
    "o": [
      "They suppress overflow exceptions in arithmetic operations",
      "They catch all arithmetic errors",
      "They ensure all exceptions are thrown at runtime",
      "They validate numeric limits during execution"
    ]
  },
  {
    "q": "Which of the following defines a custom exception that passes a message to its base class?",
    "o": [
      "public class MyError : Exception { public MyError(string msg) : base(msg) {} }",
      "exception MyError { MyError(string msg) => msg; }",
      "public class MyError inherits Exception { MyError(string msg) { } }",
      "public MyError : Exception { MyError() { super(msg); } }"
    ]
  },
  {
    "q": "What will be printed by the following code?",
    "c": "try\n{\n    Console.WriteLine(\"A\");\n}\nfinally\n{\n    Console.WriteLine(\"B\");\n}",
    "o": [
      "A\nB",
      "B\nA",
      "A",
      "B"
    ]
  },
  {
    "q": "What happens when you throw an exception using `throw new Exception(\"error\")`?",
    "o": [
      "An exception is created and execution jumps to the nearest catch block",
      "The exception is ignored at runtime",
      "The error is silently logged",
      "A warning is shown but execution continues"
    ]
  },
  {
    "q": "Which block executes even if a `return` statement is present in the `try` block?",
    "o": [
      "finally",
      "catch",
      "throw",
      "goto"
    ]
  },
  {
    "q": "What is the result of executing this code?",
    "c": "int result = unchecked(int.MaxValue + 1);\nConsole.WriteLine(result);",
    "o": [
      "-2147483648",
      "OverflowException",
      "Compile-time error",
      "0"
    ]
  },
  {
    "q": "Which of the following best describes the use of `throw` in C#?",
    "o": [
      "It is used to signal the occurrence of an exception",
      "It is used to handle exceptions silently",
      "It retries failed operations",
      "It prevents runtime type checking"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "try\n{\n    int x = 5;\n    int y = 0;\n    Console.WriteLine(x / y);\n}\ncatch (DivideByZeroException ex)\n{\n    Console.WriteLine(\"Cannot divide by zero\");\n}\nfinally\n{\n    Console.WriteLine(\"Finished\");\n}",
    "o": [
      "Cannot divide by zero\nFinished",
      "Finished",
      "Cannot divide by zero",
      "Unhandled exception"
    ]
  },
  {
    "q": "What does a `finally` block guarantee in a C# program?",
    "o": [
      "It always executes after try and catch blocks",
      "It executes only if an exception occurs",
      "It only runs if no catch is defined",
      "It suppresses all exceptions"
    ]
  },
  {
    "q": "What will be printed by the following code?",
    "c": "try\n{\n    throw new InvalidOperationException(\"Invalid op\");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine(ex.GetType().Name);\n}",
    "o": [
      "InvalidOperationException",
      "Exception",
      "Invalid op",
      "System.Exception"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "try\n{\n    int result = checked(int.MaxValue + 1);\n    Console.WriteLine(result);\n}\ncatch (OverflowException)\n{\n    Console.WriteLine(\"Overflow detected\");\n}",
    "o": [
      "Overflow detected",
      "0",
      "-1",
      "No output"
    ]
  },
  {
    "q": "What is the correct way to throw an exception with a custom message?",
    "o": [
      "throw new Exception(\"Something went wrong\");",
      "raise Exception(\"Something went wrong\");",
      "throw Exception(\"Something went wrong\");",
      "Exception(\"Something went wrong\");"
    ]
  },
  {
    "q": "What is the purpose of defining a custom exception class?",
    "o": [
      "To represent application-specific errors with meaningful context",
      "To avoid using existing exceptions",
      "To create exceptions that never throw",
      "To suppress compiler warnings"
    ]
  },
  {
    "q": "What is the output of the following C# code?",
    "c": "try\n{\n    Console.WriteLine(\"Try block\");\n    return;\n}\nfinally\n{\n    Console.WriteLine(\"Finally block\");\n}",
    "o": [
      "Try block\nFinally block",
      "Try block",
      "Finally block",
      "Nothing"
    ]
  },
  {
    "q": "Which of these statements about the `checked` keyword is TRUE?",
    "o": [
      "It enables overflow checking for arithmetic operations",
      "It suppresses all exceptions at runtime",
      "It ensures reference types are non-null",
      "It limits catch block execution"
    ]
  },
  {
    "q": "Which of the following correctly defines a custom exception class with a constructor that accepts a string message?",
    "o": [
      "public class MyCustomException : Exception { public MyCustomException(string msg) : base(msg) {} }",
      "exception MyCustomException { string msg; }",
      "public class MyCustomException inherits Exception { constructor(msg) {} }",
      "class MyCustomException extends Exception { public MyCustomException() {} }"
    ]
  },
  {
    "q": "Which exception is thrown when dividing an integer by zero in C#?",
    "o": [
      "DivideByZeroException",
      "ArithmeticException",
      "OverflowException",
      "InvalidOperationException"
    ]
  },
  {
    "q": "What will this code snippet output?",
    "c": "try\n{\n    Console.WriteLine(\"Before throw\");\n    throw new Exception(\"Error occurred\");\n    Console.WriteLine(\"After throw\");\n}\ncatch (Exception)\n{\n    Console.WriteLine(\"Caught exception\");\n}",
    "o": [
      "Before throw\nCaught exception",
      "Before throw\nAfter throw",
      "Caught exception",
      "Error occurred"
    ]
  },
  {
    "q": "Which of the following ensures that a block of code is executed regardless of an exception?",
    "o": [
      "finally block",
      "catch block",
      "using block",
      "if block"
    ]
  },
  {
    "q": "How do you define a custom exception named `InvalidDataException`?",
    "o": [
      "public class InvalidDataException : Exception {}",
      "class InvalidDataException implements Exception {}",
      "exception InvalidDataException : Exception {}",
      "InvalidDataException = class(Exception) {}"
    ]
  },
  {
    "q": "What will this code display?",
    "c": "try\n{\n    int result = unchecked(int.MaxValue + 10);\n    Console.WriteLine(result);\n}\ncatch\n{\n    Console.WriteLine(\"Exception\");\n}",
    "o": [
      "-2147483639",
      "Exception",
      "0",
      "Compile time error"
    ]
  },
  {
    "q": "What is the correct way to re-throw a caught exception without losing stack trace?",
    "o": [
      "throw;",
      "throw ex;",
      "throw new Exception(ex.Message);",
      "rethrow();"
    ]
  },
  {
    "q": "Which keyword disables overflow checking in arithmetic expressions?",
    "o": [
      "unchecked",
      "checked",
      "unsafe",
      "override"
    ]
  },
  {
    "q": "Which of the following would throw an OverflowException at runtime?",
    "c": "int a = int.MaxValue;\nint b = checked(a + 1);",
    "o": [
      "An OverflowException will be thrown",
      "The result will be zero",
      "The result will wrap around",
      "No exception will occur"
    ]
  },
  {
    "q": "What is the result of executing this code?",
    "c": "try\n{\n    throw new ArgumentNullException();\n}\ncatch (ArgumentException)\n{\n    Console.WriteLine(\"Argument Exception\");\n}\ncatch (Exception)\n{\n    Console.WriteLine(\"General Exception\");\n}",
    "o": [
      "General Exception",
      "Argument Exception",
      "Unhandled exception",
      "No output"
    ]
  },
  {
    "q": "Why might you use a `checked` block in numeric operations?",
    "o": [
      "To ensure overflow exceptions are thrown when limits are exceeded",
      "To reduce performance overhead",
      "To suppress runtime type checks",
      "To convert float to int safely"
    ]
  },
  {
    "q": "Which of the following keywords is used to explicitly raise an exception in C#?",
    "o": [
      "throw",
      "raise",
      "except",
      "error"
    ]
  },
  {
    "q": "What is the result of the following code?",
    "c": "try\n{\n    int x = 10;\n    int y = 0;\n    int z = x / y;\n}\nfinally\n{\n    Console.WriteLine(\"Done\");\n}",
    "o": [
      "Unhandled exception after printing 'Done'",
      "Handled exception and printed 'Done'",
      "Only 'Done' is printed",
      "Nothing is printed"
    ]
  },
  {
    "q": "What is a recommended practice when creating a custom exception class?",
    "o": [
      "Inherit from System.Exception",
      "Avoid using any base class",
      "Inherit from System.Object",
      "Use a struct instead of a class"
    ]
  },
  {
    "q": "Which block is executed regardless of whether an exception is thrown or not?",
    "o": [
      "finally",
      "catch",
      "throw",
      "try"
    ]
  },
  {
    "q": "What happens if no catch block matches the thrown exception?",
    "o": [
      "The program terminates with an unhandled exception",
      "The finally block executes and suppresses the error",
      "The compiler automatically adds a generic catch block",
      "Nothing happens"
    ]
  },
  {
    "q": "Which code snippet demonstrates a proper custom exception class?",
    "o": [
      "public class DataException : Exception { public DataException(string message) : base(message) {} }",
      "class DataException extends Exception { void DataException(string msg) {} }",
      "public DataException inherits Exception { string message; }",
      "exception DataException { constructor(string msg) {} }"
    ]
  },
  {
    "q": "What does this code output?",
    "c": "try\n{\n    Console.WriteLine(\"Start\");\n    throw new Exception();\n}\ncatch\n{\n    Console.WriteLine(\"Caught\");\n}\nfinally\n{\n    Console.WriteLine(\"Cleanup\");\n}",
    "o": [
      "Start\nCaught\nCleanup",
      "Caught\nCleanup",
      "Start\nCleanup",
      "Start\nCaught"
    ]
  },
  {
    "q": "What does the `checked` keyword do in arithmetic operations?",
    "o": [
      "It enables overflow checking and throws exceptions if overflow occurs",
      "It suppresses all numeric exceptions",
      "It ensures safe division operations",
      "It disables integer promotions"
    ]
  },
  {
    "q": "Which keyword disables overflow exception checks for a specific block?",
    "o": [
      "unchecked",
      "unchecked_block",
      "disablecheck",
      "skipcheck"
    ]
  },
  {
    "q": "Which of the following best describes a scenario to use `try-catch-finally`?",
    "o": [
      "When a risky operation may throw an exception, but cleanup must always occur",
      "When the program contains no exception logic",
      "To replace error codes with console logs",
      "To avoid handling exceptions"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try\n{\n    int[] arr = new int[2];\n    Console.WriteLine(arr[5]);\n}\ncatch (IndexOutOfRangeException)\n{\n    Console.WriteLine(\"Index out of range\");\n}",
    "o": [
      "Index out of range",
      "5",
      "Exception",
      "Compile-time error"
    ]
  },
  {
    "q": "Which is true about the `finally` block in C#?",
    "o": [
      "It is executed regardless of whether an exception is thrown or not",
      "It is only executed when no exception is thrown",
      "It is skipped if a return statement is encountered",
      "It executes only when an exception is caught"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "try\n{\n    int x = 10;\n    int y = 0;\n    int result = x / y;\n}\ncatch (DivideByZeroException ex)\n{\n    Console.WriteLine(\"Division Error\");\n}\nfinally\n{\n    Console.WriteLine(\"End of block\");\n}",
    "o": [
      "Division Error\nEnd of block",
      "Division Error",
      "End of block",
      "Runtime crash"
    ]
  },
  {
    "q": "What does this custom exception class do?",
    "c": "public class FileMissingException : Exception\n{\n    public FileMissingException(string fileName)\n        : base($\"File {fileName} is missing\") {}\n}",
    "o": [
      "Provides a specific error message when a file is missing",
      "Hides system file errors from the user",
      "Automatically retries file access",
      "Suppresses all I/O exceptions"
    ]
  },
  {
    "q": "What happens when arithmetic overflow occurs in an unchecked block?",
    "o": [
      "The result wraps around without throwing an exception",
      "An OverflowException is thrown",
      "The compiler generates an error",
      "The program halts"
    ]
  },
  {
    "q": "What does this code print?",
    "c": "try\n{\n    throw new NullReferenceException(\"Null error\");\n}\ncatch (Exception e)\n{\n    Console.WriteLine(e.Message);\n}",
    "o": [
      "Null error",
      "System.NullReferenceException",
      "Exception",
      "Unhandled exception"
    ]
  },
  {
    "q": "When should you create a custom exception class?",
    "o": [
      "When you need to provide domain-specific error information",
      "When existing exceptions are too fast",
      "To improve performance of try-catch",
      "To avoid using built-in exceptions altogether"
    ]
  },
  {
    "q": "Which of the following correctly demonstrates use of a `checked` block?",
    "o": [
      "checked { int z = int.MaxValue + 1; }",
      "check { int z = int.MaxValue + 1; }",
      "checked (int.MaxValue + 1);",
      "verify { int z = int.MaxValue + 1; }"
    ]
  },
  {
    "q": "Which of the following code examples demonstrates the correct syntax for an `unchecked` expression?",
    "o": [
      "int z = unchecked(int.MaxValue + 1);",
      "unchecked int z = int.MaxValue + 1;",
      "int z = unchecked +1;",
      "int z = disable(int.MaxValue + 1);"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "try\n{\n    Console.WriteLine(\"Inside try\");\n    return;\n}\nfinally\n{\n    Console.WriteLine(\"In finally\");\n}",
    "o": [
      "Inside try\nIn finally",
      "Inside try",
      "In finally",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is the base class for all exceptions in C#?",
    "o": [
      "System.Exception",
      "System.BaseException",
      "System.Error",
      "System.SystemException"
    ]
  },
  {
    "q": "What does the following code print?",
    "c": "try\n{\n    throw new InvalidOperationException(\"Invalid operation\");\n}\ncatch (InvalidOperationException ex)\n{\n    Console.WriteLine(ex.GetType().Name);\n}",
    "o": [
      "InvalidOperationException",
      "Exception",
      "Invalid operation",
      "System.Exception"
    ]
  },
  {
    "q": "What is the purpose of the `catch` block in a try-catch-finally structure?",
    "o": [
      "To handle exceptions thrown in the try block",
      "To always run cleanup code",
      "To ignore errors silently",
      "To validate logic before throwing an error"
    ]
  },
  {
    "q": "Which of the following will compile and execute without throwing an exception?",
    "c": "int result = unchecked(int.MaxValue + 10);",
    "o": [
      "Wraparound occurs and no exception is thrown",
      "An OverflowException is thrown",
      "A Compile-time error occurs",
      "The result is null"
    ]
  },
  {
    "q": "How do you throw an instance of a custom exception?",
    "o": [
      "throw new MyCustomException(\"Error message\");",
      "throw MyCustomException(\"Error message\");",
      "raise new MyCustomException(\"Error message\")",
      "throw Exception.MyCustomException"
    ]
  },
  {
    "q": "What happens if a `finally` block contains a return statement?",
    "o": [
      "It overrides any previous return from the try or catch block",
      "It is ignored if the try block returns",
      "It throws an exception",
      "It is skipped entirely"
    ]
  },
  {
    "q": "Which of the following code snippets will throw an OverflowException?",
    "c": "int result = checked(int.MaxValue + 1);",
    "o": [
      "OverflowException is thrown",
      "Wraparound occurs",
      "Compile-time error",
      "No output or exception"
    ]
  },
  {
    "q": "When should you use the `checked` keyword?",
    "o": [
      "When you want to catch arithmetic overflow errors at runtime",
      "To prevent null reference exceptions",
      "To validate user input",
      "To bypass try-catch blocks"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "try\n{\n    Console.WriteLine(\"Start\");\n    int.Parse(\"abc\");\n}\ncatch (FormatException)\n{\n    Console.WriteLine(\"Invalid format\");\n}",
    "o": [
      "Start\nInvalid format",
      "Start\nabc",
      "Invalid format",
      "Exception"
    ]
  },
  {
    "q": "Which of the following defines a correct custom exception class in C#?",
    "o": [
      "public class MyException : Exception { public MyException(string message) : base(message) {} }",
      "exception class MyException inherits Exception { string message; }",
      "MyException : Exception { constructor(string msg) {} }",
      "define MyException as Exception with message"
    ]
  },
  {
    "q": "What is the main purpose of a `catch` block?",
    "o": [
      "To handle exceptions thrown in the try block",
      "To finalize variable assignments",
      "To execute after return statements",
      "To log only syntax errors"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "try\n{\n    int[] arr = {1, 2};\n    Console.WriteLine(arr[3]);\n}\ncatch (Exception e)\n{\n    Console.WriteLine(\"Exception caught\");\n}",
    "o": [
      "Exception caught",
      "1",
      "3",
      "No output"
    ]
  },
  {
    "q": "Which statement is true about exception handling in C#?",
    "o": [
      "The finally block runs even if an exception is not thrown",
      "The catch block always runs before finally",
      "The catch block can be omitted if finally is present",
      "A try block must always have a catch block"
    ]
  },
  {
    "q": "What does the `unchecked` keyword do?",
    "o": [
      "Suppresses overflow-checking for integral-type arithmetic operations",
      "Forces garbage collection during execution",
      "Skips null checking",
      "Ignores all exceptions"
    ]
  },
  {
    "q": "What will be printed?",
    "c": "try\n{\n    Console.WriteLine(\"Try block\");\n    return;\n}\nfinally\n{\n    Console.WriteLine(\"Finally block\");\n}",
    "o": [
      "Try block\nFinally block",
      "Try block",
      "Finally block",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following is a correct way to declare and throw a custom exception?",
    "o": [
      "throw new ValidationException(\"Invalid input\");",
      "throw ValidationException(\"Invalid input\");",
      "raise new ValidationException(\"Invalid input\");",
      "exception throw ValidationException"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "try\n{\n    Console.WriteLine(\"A\");\n    throw new Exception();\n}\ncatch\n{\n    Console.WriteLine(\"B\");\n    throw;\n}\nfinally\n{\n    Console.WriteLine(\"C\");\n}",
    "o": [
      "A\nB\nC",
      "A\nC",
      "A\nB",
      "B\nC"
    ]
  },
  {
    "q": "Which block is guaranteed to execute even if an exception is re-thrown?",
    "o": [
      "finally",
      "catch",
      "throw",
      "retry"
    ]
  },
  {
    "q": "What does the following code demonstrate?",
    "c": "public class LimitExceededException : Exception\n{\n    public LimitExceededException() : base(\"Limit exceeded\") {}\n}",
    "o": [
      "Creating a custom exception with a default message",
      "Overloading an exception constructor",
      "Throwing a built-in exception",
      "Using an anonymous exception"
    ]
  },
  {
    "q": "What is the effect of `checked` on arithmetic operations?",
    "o": [
      "It forces overflow detection at runtime",
      "It skips validation for overflow",
      "It compiles faster by ignoring bounds",
      "It converts values silently on overflow"
    ]
  },
  {
    "q": "Which keyword is used to manually throw an exception in C#?",
    "o": [
      "throw",
      "raise",
      "except",
      "error"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try\n{\n    int value = checked(2147483647 + 1);\n    Console.WriteLine(value);\n}\ncatch (OverflowException)\n{\n    Console.WriteLine(\"Overflow occurred\");\n}",
    "o": [
      "Overflow occurred",
      "2147483648",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "What will happen if an exception is thrown in a `try` block and there is no matching `catch` block?",
    "o": [
      "The `finally` block will still execute, then the exception is rethrown",
      "The program crashes immediately",
      "The exception is ignored",
      "The exception is converted to a warning"
    ]
  },
  {
    "q": "Which of these demonstrates correct syntax for using `finally`?",
    "c": "try\n{\n    // Code that may throw\n}\ncatch (Exception ex)\n{\n    Console.WriteLine(ex.Message);\n}\nfinally\n{\n    Console.WriteLine(\"Always executes\");\n}",
    "o": [
      "Always executes after try or catch",
      "Only runs if catch is triggered",
      "Only runs if no exception occurs",
      "Never runs if return is called"
    ]
  },
  {
    "q": "Which of the following defines a custom exception with an additional `ErrorCode` property?",
    "c": "public class MyAppException : Exception\n{\n    public int ErrorCode { get; set; }\n    public MyAppException(string message, int code) : base(message) => ErrorCode = code;\n}",
    "o": [
      "A custom exception with additional data",
      "An invalid exception declaration",
      "An anonymous class",
      "A built-in exception"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try\n{\n    Console.WriteLine(\"Before\");\n    throw new ApplicationException();\n    Console.WriteLine(\"After\");\n}\ncatch\n{\n    Console.WriteLine(\"Caught\");\n}",
    "o": [
      "Before\nCaught",
      "Before\nAfter\nCaught",
      "Caught\nAfter",
      "After\nCaught"
    ]
  },
  {
    "q": "Which of the following best describes a `checked` context?",
    "o": [
      "It enables overflow-checking for integral-type arithmetic operations",
      "It disables exception propagation",
      "It automatically logs exceptions to console",
      "It is required for division operations"
    ]
  },
  {
    "q": "What happens if an exception is thrown in a `finally` block?",
    "o": [
      "It replaces any previously thrown exception",
      "It is ignored if the try block failed",
      "It is never allowed",
      "The program suppresses all exceptions"
    ]
  },
  {
    "q": "What is the behavior of this code?",
    "c": "try\n{\n    Console.WriteLine(\"Try\");\n}\nfinally\n{\n    Console.WriteLine(\"Finally\");\n}",
    "o": [
      "Try\nFinally",
      "Try",
      "Finally",
      "No output"
    ]
  },
  {
    "q": "Which of these exceptions would most likely be thrown by invalid type casting?",
    "o": [
      "InvalidCastException",
      "IndexOutOfRangeException",
      "NullReferenceException",
      "FormatException"
    ]
  },
  {
    "q": "Which statement correctly describes the `finally` block in exception handling?",
    "o": [
      "It always executes, whether an exception is thrown or not.",
      "It only executes if an exception is caught.",
      "It only executes if no exception is thrown.",
      "It executes only if the try block contains a return statement."
    ]
  },
  {
    "q": "What will be the result of the following code?",
    "c": "try\n{\n    int x = 10;\n    int y = 0;\n    int result = x / y;\n    Console.WriteLine(result);\n}\ncatch (DivideByZeroException)\n{\n    Console.WriteLine(\"Cannot divide by zero\");\n}",
    "o": [
      "Cannot divide by zero",
      "0",
      "10",
      "Compilation error"
    ]
  },
  {
    "q": "Which class should a custom exception inherit from in C#?",
    "o": [
      "System.Exception",
      "System.Error",
      "System.Application",
      "System.Fault"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "try\n{\n    int a = checked(1000000 * 1000000);\n    Console.WriteLine(a);\n}\ncatch (OverflowException)\n{\n    Console.WriteLine(\"Overflow detected\");\n}",
    "o": [
      "Overflow detected",
      "0",
      "1000000000000",
      "No output"
    ]
  },
  {
    "q": "Which of the following keywords is used to define an unchecked context?",
    "o": [
      "unchecked",
      "overflow",
      "skip",
      "ignore"
    ]
  },
  {
    "q": "What does the following custom exception class represent?",
    "c": "public class AgeLimitException : Exception\n{\n    public AgeLimitException(string message) : base(message) {}\n}",
    "o": [
      "A user-defined exception with a custom message",
      "An exception derived from System.IO",
      "An exception without any constructor",
      "An invalid exception class"
    ]
  },
  {
    "q": "What is the correct output of this code?",
    "c": "try\n{\n    Console.WriteLine(\"Start\");\n}\nfinally\n{\n    Console.WriteLine(\"End\");\n}",
    "o": [
      "Start\nEnd",
      "End\nStart",
      "Start",
      "End"
    ]
  },
  {
    "q": "Which of the following exceptions is thrown by explicitly using the `throw` keyword?",
    "o": [
      "Any exception derived from System.Exception",
      "Only system-defined exceptions",
      "Only runtime exceptions",
      "Only syntax-related exceptions"
    ]
  },
  {
    "q": "Why would you use the `checked` keyword in C#?",
    "o": [
      "To enable overflow detection in arithmetic operations",
      "To catch all exceptions automatically",
      "To log runtime errors",
      "To ensure no null references occur"
    ]
  },
  {
    "q": "What will the following code display?",
    "c": "try\n{\n    throw new ArgumentNullException();\n}\ncatch (ArgumentException)\n{\n    Console.WriteLine(\"Argument exception\");\n}\ncatch (Exception)\n{\n    Console.WriteLine(\"General exception\");\n}",
    "o": [
      "Argument exception",
      "General exception",
      "ArgumentNullException",
      "No output"
    ]
  },
  {
    "q": "What happens if you place a `return` inside a `try` block but also have a `finally` block?",
    "o": [
      "The `finally` block still executes before the method returns.",
      "The `finally` block is skipped due to return.",
      "It results in a compile-time error.",
      "The return is overridden by the finally block."
    ]
  },
  {
    "q": "What will this code print?",
    "c": "try\n{\n    Console.WriteLine(\"Inside try\");\n    throw new Exception();\n}\ncatch\n{\n    Console.WriteLine(\"Caught exception\");\n}\nfinally\n{\n    Console.WriteLine(\"Inside finally\");\n}",
    "o": [
      "Inside try\nCaught exception\nInside finally",
      "Inside try\nInside finally",
      "Caught exception\nInside finally",
      "Inside finally"
    ]
  },
  {
    "q": "Which scenario best suits the use of a custom exception class?",
    "o": [
      "When you need to represent a domain-specific error condition",
      "When syntax errors need to be caught at runtime",
      "When dividing numbers by zero",
      "When array bounds are exceeded"
    ]
  },
  {
    "q": "Which of the following keywords enables arithmetic overflow checking?",
    "o": [
      "checked",
      "try",
      "catch",
      "validate"
    ]
  },
  {
    "q": "What does this code demonstrate?",
    "c": "public class FileFormatException : Exception\n{\n    public FileFormatException(string msg) : base(msg) {}\n}",
    "o": [
      "Defining a custom exception",
      "Defining a generic class",
      "Overriding the base class constructor incorrectly",
      "Implementing a logging mechanism"
    ]
  },
  {
    "q": "What will this program output?",
    "c": "try\n{\n    int a = 5;\n    int b = 0;\n    Console.WriteLine(a / b);\n}\ncatch (DivideByZeroException)\n{\n    Console.WriteLine(\"Math error\");\n}\nfinally\n{\n    Console.WriteLine(\"Cleanup\");\n}",
    "o": [
      "Math error\nCleanup",
      "5\nCleanup",
      "Cleanup",
      "Math error"
    ]
  },
  {
    "q": "Which block is optional when using try-catch-finally in C#?",
    "o": [
      "catch",
      "try",
      "finally",
      "None of them are optional"
    ]
  },
  {
    "q": "What is the use of the `throw;` statement inside a `catch` block without specifying an exception?",
    "o": [
      "It rethrows the caught exception",
      "It suppresses the exception",
      "It throws a null exception",
      "It logs the exception silently"
    ]
  },
  {
    "q": "What will this output?",
    "c": "try\n{\n    unchecked\n    {\n        int x = int.MaxValue + 10;\n        Console.WriteLine(\"Unchecked result\");\n    }\n}\ncatch (OverflowException)\n{\n    Console.WriteLine(\"Overflow caught\");\n}",
    "o": [
      "Unchecked result",
      "Overflow caught",
      "Compilation error",
      "Runtime exception"
    ]
  },
  {
    "q": "Which condition causes an `OverflowException` in a checked context?",
    "o": [
      "An integer calculation that exceeds the type's limit",
      "A null reference",
      "Calling a method that doesn't exist",
      "Invalid cast between unrelated types"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "try\n{\n    int[] numbers = new int[3];\n    Console.WriteLine(numbers[5]);\n}\ncatch (IndexOutOfRangeException)\n{\n    Console.WriteLine(\"Index out of bounds\");\n}",
    "o": [
      "Index out of bounds",
      "5",
      "Runtime error",
      "Compilation error"
    ]
  },
  {
    "q": "Which of the following statements about `finally` is correct?",
    "o": [
      "It is used to ensure that clean-up code runs regardless of whether an exception occurs.",
      "It is executed only if an exception occurs.",
      "It must always appear with a catch block.",
      "It can be skipped during execution."
    ]
  },
  {
    "q": "What is the purpose of a custom exception class?",
    "o": [
      "To define user-specific error conditions that can be thrown and caught",
      "To override system exceptions only",
      "To reduce program size",
      "To disable default exceptions"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try\n{\n    Console.WriteLine(\"A\");\n    throw new Exception();\n}\ncatch (Exception)\n{\n    Console.WriteLine(\"B\");\n}\nfinally\n{\n    Console.WriteLine(\"C\");\n}",
    "o": [
      "A\nB\nC",
      "A\nC",
      "B\nC",
      "A\nB"
    ]
  },
  {
    "q": "Which exception type is commonly used when accessing a null object?",
    "o": [
      "NullReferenceException",
      "InvalidCastException",
      "ArgumentOutOfRangeException",
      "DivideByZeroException"
    ]
  },
  {
    "q": "What will this code output in a `checked` context?",
    "c": "checked\n{\n    int max = int.MaxValue;\n    int result = max + 1;\n    Console.WriteLine(result);\n}",
    "o": [
      "A runtime OverflowException is thrown",
      "2147483648",
      "0",
      "Compilation error"
    ]
  },
  {
    "q": "Which keyword allows arithmetic overflows to occur silently?",
    "o": [
      "unchecked",
      "try",
      "silent",
      "nullable"
    ]
  },
  {
    "q": "How do you throw a custom exception named `InvalidGradeException`?",
    "o": [
      "throw new InvalidGradeException(\"Grade must be between 0 and 100\");",
      "throw InvalidGradeException;",
      "raise new InvalidGradeException(\"Invalid\");",
      "throw Exception.InvalidGrade(\"Invalid\");"
    ]
  },
  {
    "q": "What is required to define a custom exception class?",
    "o": [
      "Inheriting from System.Exception",
      "Implementing IDisposable",
      "Inheriting from System.Object",
      "Implementing IException"
    ]
  },
  {
    "q": "Which of the following is true about `throw;` with no exception object?",
    "o": [
      "It rethrows the current exception in a catch block",
      "It throws a new default exception",
      "It throws null",
      "It does not work in C#"
    ]
  },
  {
    "q": "What happens if no catch block matches the thrown exception?",
    "o": [
      "The exception propagates up the call stack.",
      "The exception is ignored.",
      "The program continues normally.",
      "The finally block is skipped."
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "try\n{\n    Console.WriteLine(\"Try block\");\n    throw new InvalidOperationException();\n}\ncatch (ArgumentException)\n{\n    Console.WriteLine(\"Argument exception\");\n}\nfinally\n{\n    Console.WriteLine(\"Finally block\");\n}",
    "o": [
      "Try block\nFinally block",
      "Argument exception\nFinally block",
      "Try block\nArgument exception",
      "Finally block"
    ]
  },
  {
    "q": "Why would you use a custom exception class instead of a standard one?",
    "o": [
      "To represent application-specific error conditions",
      "To replace all built-in exceptions",
      "To optimize runtime performance",
      "To avoid using try-catch blocks"
    ]
  },
  {
    "q": "Which keyword is used to enforce overflow checking in arithmetic operations?",
    "o": [
      "checked",
      "guard",
      "safe",
      "verify"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "try\n{\n    Console.WriteLine(\"Start\");\n    throw new Exception(\"Boom\");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine(ex.Message);\n}\nfinally\n{\n    Console.WriteLine(\"Done\");\n}",
    "o": [
      "Boom\nDone",
      "Start\nBoom",
      "Start\nDone",
      "Exception\nDone"
    ]
  },
  {
    "q": "What does the `finally` block ensure in exception handling?",
    "o": [
      "Cleanup code runs regardless of what happens in try or catch.",
      "Exceptions are always swallowed.",
      "Only runs if no exception occurs.",
      "Avoids throwing any exceptions."
    ]
  },
  {
    "q": "What will be the result of this code using `unchecked`?",
    "c": "unchecked\n{\n    int val = int.MaxValue + 1;\n    Console.WriteLine(val);\n}",
    "o": [
      "Arithmetic overflow occurs silently",
      "An OverflowException is thrown",
      "Compile-time error",
      "Program crashes"
    ]
  },
  {
    "q": "Which line throws an exception explicitly?",
    "o": [
      "throw new Exception(\"Error occurred\");",
      "return new Exception();",
      "catch(Exception e)",
      "try { Console.WriteLine(\"x\"); }"
    ]
  },
  {
    "q": "How do you access the message of a thrown exception in a catch block?",
    "o": [
      "ex.Message",
      "ex.ToString()",
      "ex.Data",
      "ex.GetType()"
    ]
  },
  {
    "q": "What is the purpose of the base constructor in a custom exception?",
    "o": [
      "To pass the error message to the base Exception class",
      "To throw the exception automatically",
      "To create a default catch block",
      "To suppress stack trace generation"
    ]
  },
  {
    "q": "What is the purpose of using `throw;` inside a catch block?",
    "o": [
      "To rethrow the original exception",
      "To throw a new exception",
      "To skip the exception handling",
      "To suppress the exception"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "try\n{\n    int[] arr = new int[2];\n    arr[3] = 10;\n}\ncatch (IndexOutOfRangeException ex)\n{\n    Console.WriteLine(\"Out of range!\");\n}\nfinally\n{\n    Console.WriteLine(\"Done\");\n}",
    "o": [
      "Out of range!\nDone",
      "Done",
      "Out of range!",
      "Runtime crash"
    ]
  },
  {
    "q": "Which of the following statements defines a valid custom exception class in C#?",
    "o": [
      "public class MyException : Exception {}",
      "public MyException extends Exception {}",
      "public exception MyException : BaseException {}",
      "custom Exception MyException {}"
    ]
  },
  {
    "q": "In which block should you place code that must always execute regardless of exceptions?",
    "o": [
      "finally",
      "catch",
      "throw",
      "using"
    ]
  },
  {
    "q": "What happens when a `throw` statement is used outside of a catch block without specifying an exception?",
    "o": [
      "It causes a compile-time error",
      "It throws a null exception",
      "It logs the error silently",
      "It restarts the program"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "checked\n{\n    int result = int.MaxValue + 1;\n    Console.WriteLine(result);\n}",
    "o": [
      "An OverflowException is thrown",
      "0",
      "2147483648",
      "Compile-time error"
    ]
  },
  {
    "q": "Which of the following allows integer overflow to happen without throwing an exception?",
    "o": [
      "unchecked block",
      "checked block",
      "finally block",
      "throw statement"
    ]
  },
  {
    "q": "Why would you want to use the `checked` keyword in C#?",
    "o": [
      "To detect arithmetic overflow at runtime",
      "To disable exception handling",
      "To make code run faster",
      "To ignore null references"
    ]
  },
  {
    "q": "How can you define a constructor in a custom exception to accept a custom message?",
    "o": [
      "public MyException(string message) : base(message) {}",
      "public MyException(string message) => message;",
      "public MyException => base(message);",
      "MyException(string message) base.message = message;"
    ]
  },
  {
    "q": "What is the correct order of blocks when handling exceptions?",
    "o": [
      "try -> catch -> finally",
      "catch -> try -> finally",
      "finally -> try -> catch",
      "try -> finally -> catch"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try\n{\n    Console.WriteLine(\"Inside try\");\n    throw new Exception(\"Some error\");\n}\nfinally\n{\n    Console.WriteLine(\"Inside finally\");\n}",
    "o": [
      "Inside try\nInside finally",
      "Inside finally",
      "Some error",
      "Inside try"
    ]
  },
  {
    "q": "Which exception is thrown when you try to divide a number by zero in C#?",
    "o": [
      "DivideByZeroException",
      "InvalidOperationException",
      "OverflowException",
      "NullReferenceException"
    ]
  },
  {
    "q": "What will be the output of the following code using unchecked block?",
    "c": "unchecked\n{\n    int max = int.MaxValue;\n    int result = max + 10;\n    Console.WriteLine(result);\n}",
    "o": [
      "Arithmetic overflow occurs without exception",
      "Program crashes",
      "OverflowException is thrown",
      "Compilation error"
    ]
  },
  {
    "q": "Why is the `base` keyword used in a custom exception constructor?",
    "o": [
      "To pass the error message to the base Exception class",
      "To override the base class methods",
      "To create a new exception object",
      "To suppress stack traces"
    ]
  },
  {
    "q": "What does the catch block do in a try-catch statement?",
    "o": [
      "Handles exceptions thrown in the try block",
      "Always executes regardless of exception",
      "Prevents compilation errors",
      "Initializes cleanup code"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "try\n{\n    throw new ArgumentNullException();\n}\ncatch (Exception ex)\n{\n    Console.WriteLine(ex.GetType().Name);\n}",
    "o": [
      "ArgumentNullException",
      "NullReferenceException",
      "Exception",
      "ArgumentException"
    ]
  },
  {
    "q": "What will happen if no exception is thrown in a try block?",
    "o": [
      "The finally block will still execute",
      "The catch block will execute",
      "The program will terminate",
      "An empty exception is thrown"
    ]
  },
  {
    "q": "Which block must be used with either catch or finally in a try statement?",
    "o": [
      "try",
      "throw",
      "catch",
      "unchecked"
    ]
  },
  {
    "q": "What is the primary benefit of using a custom exception?",
    "o": [
      "To provide more meaningful error information specific to the application",
      "To reduce runtime errors",
      "To catch system exceptions faster",
      "To avoid using try-catch blocks"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "try\n{\n    int x = 0;\n    int y = 5 / x;\n}\ncatch (DivideByZeroException)\n{\n    Console.WriteLine(\"Division by zero\");\n}\nfinally\n{\n    Console.WriteLine(\"Cleanup done\");\n}",
    "o": [
      "Division by zero\nCleanup done",
      "Cleanup done",
      "Division by zero",
      "Program crashes"
    ]
  },
  {
    "q": "What happens if an exception is thrown inside a `finally` block?",
    "o": [
      "It overrides any previously thrown exception",
      "It is ignored by the runtime",
      "It is caught by the nearest catch block",
      "It prevents execution of the try block"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try\n{\n    Console.WriteLine(\"Trying\");\n    throw new InvalidOperationException();\n}\ncatch (NullReferenceException)\n{\n    Console.WriteLine(\"Null Reference\");\n}\nfinally\n{\n    Console.WriteLine(\"Finalizing\");\n}",
    "o": [
      "Trying\nFinalizing",
      "Null Reference\nFinalizing",
      "Trying\nNull Reference",
      "Trying"
    ]
  },
  {
    "q": "Which exception should you throw to indicate that a method received an invalid argument?",
    "o": [
      "ArgumentException",
      "InvalidOperationException",
      "FormatException",
      "IndexOutOfRangeException"
    ]
  },
  {
    "q": "What is required for a custom exception class in C#?",
    "o": [
      "It must inherit from System.Exception",
      "It must be marked as sealed",
      "It must override ToString() method",
      "It must be defined inside a try block"
    ]
  },
  {
    "q": "What does the `throw ex;` statement do in a catch block?",
    "o": [
      "Throws a new exception with a reset stack trace",
      "Rethrows the original exception without stack info",
      "Silently logs the exception",
      "Ends program immediately"
    ]
  },
  {
    "q": "What is the result of the following code?",
    "c": "checked\n{\n    int a = int.MaxValue;\n    a++;\n    Console.WriteLine(a);\n}",
    "o": [
      "An OverflowException is thrown",
      "It prints the value 0",
      "It prints the maximum int value",
      "Compilation fails"
    ]
  },
  {
    "q": "Why might you wrap arithmetic operations in a `checked` block?",
    "o": [
      "To catch overflows at runtime",
      "To prevent division by zero",
      "To allow implicit type conversion",
      "To disable exception handling"
    ]
  },
  {
    "q": "How do you rethrow the original exception without resetting the stack trace?",
    "o": [
      "throw;",
      "throw ex;",
      "throw new Exception(ex.Message);",
      "return ex;"
    ]
  },
  {
    "q": "Which keyword allows overflow operations to proceed silently without an exception?",
    "o": [
      "unchecked",
      "catch",
      "throw",
      "finally"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try\n{\n    Console.WriteLine(\"A\");\n}\nfinally\n{\n    Console.WriteLine(\"B\");\n}",
    "o": [
      "A\nB",
      "B",
      "A",
      "Exception"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "try\n{\n    int x = int.MaxValue;\n    unchecked { x = x + 1; }\n    Console.WriteLine(x);\n}\ncatch\n{\n    Console.WriteLine(\"Exception\");\n}",
    "o": [
      "-2147483648",
      "Exception",
      "2147483647",
      "0"
    ]
  },
  {
    "q": "Which of the following is the base class for all exceptions in C#?",
    "o": [
      "System.Exception",
      "System.Error",
      "System.ApplicationException",
      "System.BaseException"
    ]
  },
  {
    "q": "What happens when an exception is thrown but not caught?",
    "o": [
      "The program terminates abruptly",
      "The program ignores the exception",
      "The program retries the block",
      "The exception is logged silently"
    ]
  },
  {
    "q": "How do you declare a custom exception named `LoginFailedException`?",
    "o": [
      "public class LoginFailedException : Exception {}",
      "class LoginFailedException inherits Exception {}",
      "define exception LoginFailedException : System {}",
      "new Exception LoginFailedException()"
    ]
  },
  {
    "q": "What will this code do?",
    "c": "try\n{\n    throw new FormatException();\n}\ncatch (Exception e)\n{\n    Console.WriteLine(\"Caught: \" + e.GetType().Name);\n}",
    "o": [
      "Caught: FormatException",
      "Caught: Exception",
      "Caught: FormatError",
      "No output"
    ]
  },
  {
    "q": "Which block is **guaranteed** to execute whether or not an exception is thrown?",
    "o": [
      "finally",
      "try",
      "catch",
      "throw"
    ]
  },
  {
    "q": "What is the correct way to throw an exception manually in C#?",
    "o": [
      "throw new Exception(\"Error message\");",
      "Exception(\"Error message\");",
      "raise Exception(\"Error message\");",
      "throw Exception(\"Error message\");"
    ]
  },
  {
    "q": "Which statement is used to rethrow the **same** exception from within a catch block?",
    "o": [
      "throw;",
      "throw ex;",
      "throw new Exception();",
      "return;"
    ]
  },
  {
    "q": "When using the `checked` keyword in C#, what kind of operations does it monitor?",
    "o": [
      "Integer arithmetic operations for overflow",
      "Division operations for zero",
      "All method calls for exceptions",
      "Floating point overflows"
    ]
  },
  {
    "q": "What is the output of this code?",
    "c": "try\n{\n    Console.WriteLine(\"Try block\");\n}\ncatch\n{\n    Console.WriteLine(\"Catch block\");\n}\nfinally\n{\n    Console.WriteLine(\"Finally block\");\n}",
    "o": [
      "Try block\nFinally block",
      "Try block\nCatch block",
      "Catch block\nFinally block",
      "Only Finally block"
    ]
  },
  {
    "q": "What is the role of the `finally` block in exception handling?",
    "o": [
      "To execute cleanup code regardless of exception occurrence",
      "To handle the exception if no catch block matches",
      "To suppress any thrown exceptions",
      "To throw exceptions automatically"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try\n{\n    Console.WriteLine(\"Start\");\n    int[] arr = new int[2];\n    Console.WriteLine(arr[5]);\n}\ncatch (IndexOutOfRangeException)\n{\n    Console.WriteLine(\"Index error\");\n}\nfinally\n{\n    Console.WriteLine(\"Done\");\n}",
    "o": [
      "Start\nIndex error\nDone",
      "Start\nDone",
      "Index error\nDone",
      "Start\nIndex error"
    ]
  },
  {
    "q": "Which of the following defines a custom exception correctly?",
    "o": [
      "public class InvalidUserException : Exception { }",
      "public InvalidUserException inherits Exception { }",
      "Exception InvalidUser = new Exception();",
      "class Exception : InvalidUserException { }"
    ]
  },
  {
    "q": "What will this code print?",
    "c": "try\n{\n    int val = checked(2147483647 + 1);\n    Console.WriteLine(val);\n}\ncatch (OverflowException)\n{\n    Console.WriteLine(\"Overflow caught\");\n}",
    "o": [
      "Overflow caught",
      "2147483648",
      "0",
      "No output"
    ]
  },
  {
    "q": "Which of the following keywords is used to raise an exception?",
    "o": [
      "throw",
      "catch",
      "finally",
      "raise"
    ]
  },
  {
    "q": "When would you typically use an `ApplicationException`?",
    "o": [
      "To represent user-defined application-level errors",
      "To catch system-level errors",
      "To prevent a try block from executing",
      "To suppress internal exceptions"
    ]
  },
  {
    "q": "What is the default behavior of C# if an exception is not caught?",
    "o": [
      "The application terminates with a runtime error",
      "The application continues silently",
      "The exception is logged and ignored",
      "The exception is converted to a warning"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "try\n{\n    throw new NullReferenceException();\n}\ncatch (Exception e)\n{\n    Console.WriteLine(e.Message);\n}",
    "o": [
      "Object reference not set to an instance of an object.",
      "NullReferenceException",
      "Unhandled exception",
      "Compilation error"
    ]
  },
  {
    "q": "How can you allow arithmetic overflow without throwing an exception?",
    "o": [
      "Use the `unchecked` keyword",
      "Use the `ignore` keyword",
      "Use the `safe` keyword",
      "Disable overflow check in project settings"
    ]
  },
  {
    "q": "What happens if both try and finally blocks contain a return statement?",
    "o": [
      "The return in finally block overrides the one in try",
      "Both returns are executed sequentially",
      "Compiler throws an error",
      "The return in try block takes precedence"
    ]
  },
  {
    "q": "What does the `throw;` statement do inside a catch block?",
    "o": [
      "Rethrows the caught exception while preserving the original stack trace",
      "Throws a new exception with the same message",
      "Suppresses the caught exception",
      "Logs the exception and continues execution"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try\n{\n    Console.WriteLine(\"Executing try\");\n    throw new Exception(\"Test\");\n}\ncatch\n{\n    Console.WriteLine(\"Caught\");\n}\nfinally\n{\n    Console.WriteLine(\"Cleanup\");\n}",
    "o": [
      "Executing try\nCaught\nCleanup",
      "Executing try\nCleanup",
      "Caught\nCleanup",
      "Executing try\nCaught"
    ]
  },
  {
    "q": "Which of the following is true about `checked` blocks in C#?",
    "o": [
      "They enable overflow checking for integral-type arithmetic operations",
      "They prevent null reference exceptions",
      "They automatically catch all exceptions",
      "They disable all exception handling"
    ]
  },
  {
    "q": "What kind of exception should you throw when a method receives a null argument that it does not accept?",
    "o": [
      "ArgumentNullException",
      "NullReferenceException",
      "InvalidOperationException",
      "IndexOutOfRangeException"
    ]
  },
  {
    "q": "What is the role of a catch block with an empty parameter `catch { }`?",
    "o": [
      "It catches all exceptions without exposing the exception object",
      "It catches only specific exception types",
      "It rethrows the exception immediately",
      "It logs the exception by default"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "try\n{\n    Console.WriteLine(\"Hello\");\n}\nfinally\n{\n    Console.WriteLine(\"Goodbye\");\n}",
    "o": [
      "Hello\nGoodbye",
      "Goodbye\nHello",
      "Hello",
      "Goodbye"
    ]
  },
  {
    "q": "How would you define a custom exception class with a constructor that accepts a message?",
    "o": [
      "public class MyException : Exception {\n    public MyException(string message) : base(message) {}\n}",
      "class MyException(string message) : inherits Exception {}",
      "public class MyException : Exception(message) {}",
      "public MyException(string msg) => Exception(msg);"
    ]
  },
  {
    "q": "What is the result of executing the following code?",
    "c": "int x = int.MaxValue;\nunchecked\n{\n    x = x + 1;\n}\nConsole.WriteLine(x);",
    "o": [
      "-2147483648",
      "2147483647",
      "OverflowException",
      "0"
    ]
  },
  {
    "q": "What type of exceptions are recommended to derive custom exceptions from?",
    "o": [
      "System.Exception",
      "System.SystemException",
      "System.Error",
      "System.InvalidOperationException"
    ]
  },
  {
    "q": "Which of the following causes a compile-time error in exception handling?",
    "o": [
      "A `throw` statement outside a try-catch block without an exception object",
      "A catch block without a parameter",
      "A finally block without a try",
      "Nested try-catch blocks"
    ]
  },
  {
    "q": "Which exception is typically thrown when dividing an integer by zero in C#?",
    "o": [
      "DivideByZeroException",
      "ArithmeticException",
      "OverflowException",
      "InvalidOperationException"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try\n{\n    int result = 10 / 0;\n}\ncatch (DivideByZeroException)\n{\n    Console.WriteLine(\"Cannot divide by zero\");\n}",
    "o": [
      "Cannot divide by zero",
      "Unhandled exception",
      "Compilation error",
      "Program terminates silently"
    ]
  },
  {
    "q": "What is the purpose of using `base(message)` in a custom exception class constructor?",
    "o": [
      "It passes the message to the base Exception class",
      "It logs the message automatically",
      "It suppresses the exception",
      "It throws the exception"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try\n{\n    Console.WriteLine(\"Try block\");\n    throw new Exception(\"Oops\");\n}\nfinally\n{\n    Console.WriteLine(\"Finally block\");\n}",
    "o": [
      "Try block\nFinally block",
      "Finally block\nTry block",
      "Exception\nFinally block",
      "Try block"
    ]
  },
  {
    "q": "Which keyword disables overflow checking for arithmetic operations?",
    "o": [
      "unchecked",
      "checked",
      "disable",
      "safe"
    ]
  },
  {
    "q": "What will the following code do?",
    "c": "checked\n{\n    int x = int.MaxValue;\n    x += 1;\n}",
    "o": [
      "Throw an OverflowException",
      "Wrap the value to minimum int",
      "Ignore the overflow",
      "Compile but not run"
    ]
  },
  {
    "q": "Which of the following statements is used to throw a new custom exception?",
    "o": [
      "throw new MyCustomException(\"Error message\");",
      "raise MyCustomException(\"Error message\");",
      "throw MyCustomException();",
      "new MyCustomException(\"Error message\");"
    ]
  },
  {
    "q": "How many catch blocks can follow a single try block in C#?",
    "o": [
      "Multiple",
      "Only one",
      "None",
      "Two maximum"
    ]
  },
  {
    "q": "What happens if an exception is thrown inside a finally block?",
    "o": [
      "It can suppress exceptions from the try or catch blocks",
      "It gets ignored automatically",
      "It is logged and continues execution",
      "It is always rethrown to the outer scope"
    ]
  },
  {
    "q": "Which of the following is the correct way to write a catch block that handles any exception?",
    "o": [
      "catch (Exception ex)",
      "catch all",
      "catch ()",
      "catch (any)"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "try\n{\n    throw new ArgumentException(\"Invalid arg\");\n}\ncatch (ArgumentException ex)\n{\n    Console.WriteLine(ex.GetType().Name);\n}",
    "o": [
      "ArgumentException",
      "Exception",
      "InvalidOperationException",
      "SystemException"
    ]
  },
  {
    "q": "Why would you use the `checked` keyword in C#?",
    "o": [
      "To enable overflow checking for arithmetic operations",
      "To catch all exceptions automatically",
      "To prevent compilation errors",
      "To ignore null references"
    ]
  },
  {
    "q": "Which of the following is a correct declaration of a catch block handling a specific custom exception?",
    "o": [
      "catch (MyCustomException ex)",
      "catch MyCustomException(ex)",
      "catch { MyCustomException ex; }",
      "catch (ex : MyCustomException)"
    ]
  },
  {
    "q": "What is the purpose of the `finally` block?",
    "o": [
      "To ensure execution of code regardless of exceptions",
      "To handle exceptions that are not caught",
      "To throw new exceptions",
      "To log all exceptions"
    ]
  },
  {
    "q": "What is the result of this code?",
    "c": "try\n{\n    int x = int.MaxValue;\n    x++;\n    Console.WriteLine(x);\n}\ncatch (OverflowException)\n{\n    Console.WriteLine(\"Overflow!\");\n}",
    "o": [
      "-2147483648",
      "Overflow!",
      "2147483648",
      "0"
    ]
  },
  {
    "q": "How do you explicitly rethrow the current exception from within a catch block?",
    "o": [
      "throw;",
      "throw ex;",
      "rethrow;",
      "resume;"
    ]
  },
  {
    "q": "What kind of exception should be thrown when an invalid operation occurs in the current object state?",
    "o": [
      "InvalidOperationException",
      "ArgumentNullException",
      "IndexOutOfRangeException",
      "FormatException"
    ]
  },
  {
    "q": "What does this code print?",
    "c": "try\n{\n    Console.WriteLine(\"A\");\n    throw new Exception();\n}\ncatch\n{\n    Console.WriteLine(\"B\");\n}\nfinally\n{\n    Console.WriteLine(\"C\");\n}",
    "o": [
      "A\nB\nC",
      "A\nC",
      "B\nC",
      "A\nB"
    ]
  },
  {
    "q": "Which statement best describes the use of `unchecked`?",
    "o": [
      "It disables overflow checking during arithmetic operations",
      "It throws exceptions for all overflows",
      "It checks for division by zero",
      "It validates memory usage"
    ]
  },
  {
    "q": "What is a recommended practice when creating a custom exception?",
    "o": [
      "Inherit from Exception and implement necessary constructors",
      "Use SystemException as the base class",
      "Avoid setting error messages",
      "Inherit from Object directly"
    ]
  },
  {
    "q": "Which of the following blocks is guaranteed to execute regardless of whether an exception occurs?",
    "o": [
      "finally",
      "catch",
      "throw",
      "checked"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "try\n{\n    Console.WriteLine(\"Start\");\n    throw new InvalidOperationException();\n}\ncatch (NullReferenceException)\n{\n    Console.WriteLine(\"NullReference\");\n}\nfinally\n{\n    Console.WriteLine(\"End\");\n}",
    "o": [
      "Start\nEnd",
      "Start\nNullReference\nEnd",
      "NullReference\nEnd",
      "End"
    ]
  },
  {
    "q": "Which statement is used to manually throw an exception in C#?",
    "o": [
      "throw",
      "raise",
      "throws",
      "emit"
    ]
  },
  {
    "q": "Which of the following exceptions can occur during arithmetic overflow when using `checked`?",
    "o": [
      "OverflowException",
      "ArithmeticException",
      "InvalidOperationException",
      "IndexOutOfRangeException"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try\n{\n    int[] arr = new int[2];\n    Console.WriteLine(arr[5]);\n}\ncatch (IndexOutOfRangeException)\n{\n    Console.WriteLine(\"Out of bounds\");\n}",
    "o": [
      "Out of bounds",
      "Compilation error",
      "0",
      "Unhandled Exception"
    ]
  },
  {
    "q": "How do you correctly define a custom exception named `DataException`?",
    "o": [
      "public class DataException : Exception { }",
      "public DataException inherits Exception { }",
      "class DataException extends Exception { }",
      "exception class DataException : base { }"
    ]
  },
  {
    "q": "What happens if no catch block handles the exception thrown in a try block?",
    "o": [
      "The program terminates with an unhandled exception",
      "The finally block is skipped",
      "The compiler reports an error",
      "The exception is ignored"
    ]
  },
  {
    "q": "What will be the output of this code?",
    "c": "try\n{\n    Console.WriteLine(\"Hello\");\n}\ncatch\n{\n    Console.WriteLine(\"Catch\");\n}\nfinally\n{\n    Console.WriteLine(\"Finally\");\n}",
    "o": [
      "Hello\nFinally",
      "Hello\nCatch\nFinally",
      "Catch\nFinally",
      "Finally"
    ]
  },
  {
    "q": "What is the default base class for all exceptions in C#?",
    "o": [
      "System.Exception",
      "System.SystemException",
      "System.BaseException",
      "System.Error"
    ]
  },
  {
    "q": "Which of the following best describes the `checked` context?",
    "o": [
      "It raises an exception on arithmetic overflow",
      "It disables exceptions for all blocks",
      "It is used to catch null references",
      "It logs exception messages"
    ]
  },
  {
    "q": "What happens when an exception is thrown in a try block but there is no matching catch block?",
    "o": [
      "The runtime searches for a catch block higher up the call stack",
      "The application ignores the exception and continues",
      "The finally block is skipped",
      "The exception is automatically resolved"
    ]
  },
  {
    "q": "Which keyword is used to rethrow the original exception caught in a catch block?",
    "o": [
      "throw",
      "rethrow",
      "raise",
      "return"
    ]
  },
  {
    "q": "What is the output of the following code?",
    "c": "try\n{\n    int a = 10;\n    int b = 0;\n    Console.WriteLine(a / b);\n}\ncatch (DivideByZeroException)\n{\n    Console.WriteLine(\"Cannot divide\");\n}\nfinally\n{\n    Console.WriteLine(\"Cleanup\");\n}",
    "o": [
      "Cannot divide\nCleanup",
      "Cannot divide",
      "Cleanup",
      "Runtime Error"
    ]
  },
  {
    "q": "Which statement is true about using `unchecked` in C#?",
    "o": [
      "It suppresses overflow exceptions during arithmetic operations",
      "It validates type casting operations",
      "It logs arithmetic errors",
      "It ensures memory safety"
    ]
  },
  {
    "q": "Which of the following correctly creates and throws a new custom exception?",
    "o": [
      "throw new MyCustomException(\"Something went wrong\");",
      "raise MyCustomException(\"Something went wrong\");",
      "throw MyCustomException(\"Something went wrong\")",
      "emit MyCustomException(\"Something went wrong\");"
    ]
  },
  {
    "q": "What will the following code output?",
    "c": "try\n{\n    int x = int.MaxValue;\n    x = checked(x + 1);\n}\ncatch (OverflowException)\n{\n    Console.WriteLine(\"Overflow occurred\");\n}",
    "o": [
      "Overflow occurred",
      "2147483648",
      "Compilation error",
      "No output"
    ]
  },
  {
    "q": "Which of the following is a valid reason to create a custom exception class?",
    "o": [
      "To represent domain-specific errors in your application",
      "To replace all standard exceptions",
      "To improve memory performance",
      "To reduce code size"
    ]
  },
  {
    "q": "What does the finally block ensure?",
    "o": [
      "That critical code executes regardless of an exception",
      "That no exception is thrown",
      "That only caught exceptions are handled",
      "That the program halts if needed"
    ]
  },
  {
    "q": "What is the behavior of `unchecked` when an overflow occurs in an integer operation?",
    "o": [
      "It wraps around the result silently",
      "It throws an OverflowException",
      "It returns null",
      "It logs an error"
    ]
  },
  {
    "q": "What will the following code print?",
    "c": "try\n{\n    Console.WriteLine(\"1\");\n}\ncatch\n{\n    Console.WriteLine(\"2\");\n}\nfinally\n{\n    Console.WriteLine(\"3\");\n}",
    "o": [
      "1\n3",
      "1\n2\n3",
      "2\n3",
      "1"
    ]
  },
  {
    "q": "Which exception is thrown when accessing an object that is null?",
    "o": [
      "NullReferenceException",
      "InvalidOperationException",
      "ArgumentException",
      "FormatException"
    ]
  },
  {
    "q": "What will be the output of the following code?",
    "c": "try\n{\n    throw new Exception(\"Error occurred\");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine(ex.Message);\n}\nfinally\n{\n    Console.WriteLine(\"Done\");\n}",
    "o": [
      "Error occurred\nDone",
      "Error occurred",
      "Done",
      "Unhandled Exception"
    ]
  },
  {
    "q": "What must a custom exception class in C# inherit from?",
    "o": [
      "System.Exception",
      "System.Error",
      "System.Object",
      "System.BaseException"
    ]
  },
  {
    "q": "What happens if an exception is thrown inside a `finally` block?",
    "o": [
      "It overrides any previous exception and propagates up",
      "It is ignored and execution continues",
      "It is caught by the previous catch block",
      "It is logged automatically"
    ]
  },
  {
    "q": "Which of the following best demonstrates a valid custom exception constructor?",
    "o": [
      "public MyException(string message) : base(message) { }",
      "public MyException(string message) => base(message);",
      "class MyException(message) : Exception { }",
      "throw MyException(string msg);"
    ]
  },
  {
    "q": "What will this code output?",
    "c": "try\n{\n    int result = checked(1000000 * 1000000);\n    Console.WriteLine(result);\n}\ncatch (OverflowException)\n{\n    Console.WriteLine(\"Overflow\");\n}",
    "o": [
      "Overflow",
      "1000000000000",
      "Runtime error",
      "0"
    ]
  },
  {
    "q": "When is a `finally` block skipped during execution?",
    "o": [
      "When the process is terminated abruptly (e.g., Environment.FailFast)",
      "When no exception is thrown",
      "When the exception is caught",
      "When return is used inside catch"
    ]
  },
  {
    "q": "Which of the following keywords disables overflow checking?",
    "o": [
      "unchecked",
      "unchecked()",
      "disable",
      "overflow"
    ]
  },
  {
    "q": "What will be the output of the code below?",
    "c": "try\n{\n    Console.WriteLine(\"Try block\");\n    return;\n}\nfinally\n{\n    Console.WriteLine(\"Finally block\");\n}",
    "o": [
      "Try block\nFinally block",
      "Try block",
      "Finally block",
      "Nothing"
    ]
  },
  {
    "q": "Which of the following best describes the use of multiple catch blocks in C#?",
    "o": [
      "They allow handling different exception types separately",
      "They are required for every try block",
      "They catch exceptions in parallel",
      "They prevent use of finally blocks"
    ]
  }
]