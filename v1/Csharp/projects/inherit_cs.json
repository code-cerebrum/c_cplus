[
  {
    "title": "Single and Multilevel Inheritance",
    "ques": "Create a C# program demonstrating single and multilevel inheritance. Define a base class 'Vehicle' with a property 'Speed', a derived class 'Car' that inherits from 'Vehicle' and adds a 'Model' property, and a further derived class 'SportsCar' that inherits from 'Car' and adds a 'TopSpeed' property. Display the properties of a SportsCar object.",
    "answer": {
      "type": "code",
      "lang": "c#",
      "content": "using System;\n\nclass Vehicle {\n    public int Speed { get; set; }\n\n    public Vehicle(int speed) {\n        Speed = speed;\n    }\n}\n\nclass Car : Vehicle {\n    public string Model { get; set; }\n\n    public Car(int speed, string model) : base(speed) {\n        Model = model;\n    }\n}\n\nclass SportsCar : Car {\n    public int TopSpeed { get; set; }\n\n    public SportsCar(int speed, string model, int topSpeed) : base(speed, model) {\n        TopSpeed = topSpeed;\n    }\n\n    public void DisplayInfo() {\n        Console.WriteLine($\"Speed: {Speed}, Model: {Model}, TopSpeed: {TopSpeed}\");\n    }\n}\n\nclass Program {\n    static void Main() {\n        SportsCar car = new SportsCar(120, \"Ferrari\", 300);\n        car.DisplayInfo();\n    }\n}"
    },
    "explanation": "This program demonstrates ***single and multilevel inheritance***:\n- ```Vehicle``` is the base class with a ***Speed*** property and a constructor to initialize it.\n- ```Car``` inherits from ```Vehicle``` (single inheritance) using the ```:``` symbol, adding a ***Model*** property. The constructor uses ```base(speed)``` to pass the speed to the ```Vehicle``` constructor.\n- ```SportsCar``` inherits from ```Car``` (multilevel inheritance), adding a ***TopSpeed*** property. Its constructor chains to ```Car``` using ```base(speed, model)```.\n- The ```DisplayInfo``` method in ```SportsCar``` shows all inherited and new properties.\n- In ```Main```, a ```SportsCar``` object is created and its details are displayed, showing inheritance across all levels."
  },
  {
    "title": "Method Overriding and Virtual Methods",
    "ques": "Write a C# program to demonstrate method overriding with virtual methods. Create a base class 'Animal' with a virtual method 'Speak', and a derived class 'Dog' that overrides it to provide a specific implementation. Call the method on both an Animal reference and a Dog object.",
    "answer": {
      "type": "code",
      "lang": "c#",
      "content": "using System;\n\nclass Animal {\n    public virtual void Speak() {\n        Console.WriteLine(\"The animal makes a sound.\");\n    }\n}\n\nclass Dog : Animal {\n    public override void Speak() {\n        Console.WriteLine(\"The dog barks.\");\n    }\n}\n\nclass Program {\n    static void Main() {\n        Animal genericAnimal = new Animal();\n        Animal dogAsAnimal = new Dog();\n        Dog dog = new Dog();\n\n        genericAnimal.Speak();\n        dogAsAnimal.Speak();\n        dog.Speak();\n    }\n}"
    },
    "explanation": "This program showcases ***method overriding*** with ***virtual methods***:\n- ```Animal``` has a ***virtual*** method ```Speak```, marked with the ```virtual``` keyword, allowing it to be overridden.\n- ```Dog``` inherits from ```Animal``` and ***overrides*** ```Speak``` using the ```override``` keyword, providing a specific implementation.\n- In ```Main```:\n  - ```genericAnimal``` is an ```Animal``` object, so it calls the base ```Speak``` method.\n  - ```dogAsAnimal``` is a ```Dog``` object referenced as an ```Animal``` type, but due to ***polymorphism***, the overridden ```Speak``` in ```Dog``` is called.\n  - ```dog``` is a ```Dog``` object, directly calling its overridden ```Speak```.\nThis demonstrates how ***virtual methods*** enable runtime polymorphism."
  },
  {
    "title": "Abstract Classes and Interfaces",
    "ques": "Design a C# program using an abstract class and an interface. Create an abstract class 'Shape' with an abstract method 'CalculateArea', and an interface 'IDrawable' with a method 'Draw'. Implement a 'Circle' class that inherits from 'Shape' and implements 'IDrawable'. Calculate and display the area and drawing action for a Circle object.",
    "answer": {
      "type": "code",
      "lang": "c#",
      "content": "using System;\n\nabstract class Shape {\n    public abstract double CalculateArea();\n}\n\ninterface IDrawable {\n    void Draw();\n}\n\nclass Circle : Shape, IDrawable {\n    private double radius;\n\n    public Circle(double r) {\n        radius = r;\n    }\n\n    public override double CalculateArea() {\n        return Math.PI * radius * radius;\n    }\n\n    public void Draw() {\n        Console.WriteLine(\"Drawing a circle with radius \" + radius);\n    }\n}\n\nclass Program {\n    static void Main() {\n        Circle circle = new Circle(5.0);\n        Console.WriteLine(\"Area: \" + circle.CalculateArea());\n        circle.Draw();\n    }\n}"
    },
    "explanation": "This program uses ***abstract classes*** and ***interfaces***:\n- ```Shape``` is an ***abstract class*** with an ***abstract method*** ```CalculateArea```, marked with ```abstract```, requiring derived classes to implement it.\n- ```IDrawable``` is an ***interface*** defining a ```Draw``` method, which implementing classes must provide.\n- ```Circle``` inherits from ```Shape``` and implements ```IDrawable``` using the ```:``` syntax for both.\n  - It overrides ```CalculateArea``` with a formula for a circle’s area (πr²).\n  - It implements ```Draw``` to describe the drawing action.\n- In ```Main```, a ```Circle``` object is created, and its area is calculated and displayed, followed by the drawing action, showing both ***abstraction*** and ***interface implementation***."
  },
  {
    "title": "Sealed Classes and Methods",
    "ques": "Write a C# program to demonstrate sealed classes and methods. Create a base class 'Base' with a virtual method 'Process', a derived class 'Derived' that overrides it and seals the method, and a sealed class 'FinalClass'. Attempt to inherit from 'FinalClass' and override the sealed method to show their restrictions.",
    "answer": {
      "type": "code",
      "lang": "c#",
      "content": "using System;\n\nclass Base {\n    public virtual void Process() {\n        Console.WriteLine(\"Processing in Base.\");\n    }\n}\n\nclass Derived : Base {\n    public override sealed void Process() {\n        Console.WriteLine(\"Processing in Derived.\");\n    }\n}\n\nsealed class FinalClass {\n    public void Show() {\n        Console.WriteLine(\"This is a sealed class.\");\n    }\n}\n\n// Uncommenting the below will cause a compilation error\n/*\nclass Attempt : FinalClass {\n}\n\nclass MoreDerived : Derived {\n    public override void Process() { // Error: Cannot override sealed method\n        Console.WriteLine(\"Attempting to override.\");\n    }\n}\n*/\n\nclass Program {\n    static void Main() {\n        Derived derived = new Derived();\n        derived.Process();\n        FinalClass final = new FinalClass();\n        final.Show();\n    }\n}"
    },
    "explanation": "This program demonstrates ***sealed classes*** and ***sealed methods***:\n- ```Base``` has a ***virtual*** method ```Process```.\n- ```Derived``` overrides ```Process``` and marks it as ***sealed*** with the ```sealed``` keyword, preventing further overrides.\n- ```FinalClass``` is a ***sealed class***, meaning it cannot be inherited from.\n- Commented-out sections show:\n  - Attempting to inherit from ```FinalClass``` would cause a compilation error.\n  - Attempting to override the ***sealed*** ```Process``` method in a further derived class also fails.\n- In ```Main```, ```Derived``` and ```FinalClass``` objects work as expected, but their sealed nature restricts further extension, enforcing design constraints."
  },
  {
    "title": "Multilevel Inheritance with Interface and Polymorphism",
    "ques": "Create a C# program that demonstrates multilevel inheritance and polymorphism with an interface. Define a base class 'Employee' with a property 'Salary', a derived class 'Manager' that inherits from 'Employee' and adds a 'Department' property, and a further derived class 'SeniorManager' that implements an interface 'IPromotable' with a method 'Promote'. Override a virtual method 'DisplayRole' across the hierarchy and use polymorphism to call it on different object types.",
    "answer": {
      "type": "code",
      "lang": "c#",
      "content": "using System;\n\ninterface IPromotable {\n    void Promote();\n}\n\nclass Employee {\n    public double Salary { get; set; }\n\n    public Employee(double salary) {\n        Salary = salary;\n    }\n\n    public virtual void DisplayRole() {\n        Console.WriteLine(\"Role: General Employee, Salary: \" + Salary);\n    }\n}\n\nclass Manager : Employee {\n    public string Department { get; set; }\n\n    public Manager(double salary, string dept) : base(salary) {\n        Department = dept;\n    }\n\n    public override void DisplayRole() {\n        Console.WriteLine(\"Role: Manager, Salary: \" + Salary + \", Department: \" + Department);\n    }\n}\n\nclass SeniorManager : Manager, IPromotable {\n    public SeniorManager(double salary, string dept) : base(salary, dept) {}\n\n    public override void DisplayRole() {\n        Console.WriteLine(\"Role: Senior Manager, Salary: \" + Salary + \", Department: \" + Department);\n    }\n\n    public void Promote() {\n        Salary += 5000;\n        Console.WriteLine(\"Promoted! New Salary: \" + Salary);\n    }\n}\n\nclass Program {\n    static void Main() {\n        Employee emp = new Employee(30000);\n        Employee mgr = new Manager(50000, \"Sales\");\n        SeniorManager seniorMgr = new SeniorManager(70000, \"Marketing\");\n\n        emp.DisplayRole();\n        mgr.DisplayRole();\n        seniorMgr.DisplayRole();\n        seniorMgr.Promote();\n\n        Console.WriteLine(\"\\nPolymorphic calls:\");\n        Employee[] employees = { emp, mgr, seniorMgr };\n        foreach (var e in employees) {\n            e.DisplayRole();\n        }\n    }\n}"
    },
    "explanation": "This program combines ***multilevel inheritance***, ***method overriding***, and ***interfaces*** with ***polymorphism***:\n- ```Employee``` is the base class with a ***Salary*** property and a ***virtual*** method ```DisplayRole```.\n- ```Manager``` inherits from ```Employee``` (single inheritance), adds a ***Department*** property, and overrides ```DisplayRole```.\n- ```SeniorManager``` inherits from ```Manager``` (multilevel inheritance) and implements the ```IPromotable``` ***interface*** with the ```Promote``` method, also overriding ```DisplayRole```.\n- In ```Main```:\n  - Objects are created at each level, and ```DisplayRole``` is called, showing overridden behavior.\n  - ```Promote``` is called on ```SeniorManager```, demonstrating interface implementation.\n  - An array of ```Employee``` references holds all objects, and a loop calls ```DisplayRole``` polymorphically, executing the appropriate overridden method based on the actual object type.\nThis exercise ties together the subtopics into a practical example."
  },
  {
    "title": "Abstract Class with Sealed Method Override",
    "ques": "Write a C# program that uses an abstract class with a virtual method and a derived class that overrides it with a sealed modifier. Create an abstract class 'Gadget' with a virtual method 'GetPowerSource' and an abstract method 'Operate'. Derive a class 'Phone' that provides a sealed override for 'GetPowerSource' and implements 'Operate'. Then, attempt to further derive a class 'SmartPhone' to demonstrate the sealed restriction, and use polymorphism to call methods on an array of Gadget references.",
    "answer": {
      "type": "code",
      "lang": "c#",
      "content": "using System;\n\nabstract class Gadget {\n    public virtual string GetPowerSource() {\n        return \"Unknown power source\";\n    }\n\n    public abstract void Operate();\n}\n\nclass Phone : Gadget {\n    public override sealed string GetPowerSource() {\n        return \"Battery\";\n    }\n\n    public override void Operate() {\n        Console.WriteLine(\"Phone is making a call.\");\n    }\n}\n\n// Uncommenting the below will cause a compilation error due to sealed method\n/*\nclass SmartPhone : Phone {\n    public override string GetPowerSource() { // Error: Cannot override sealed method\n        return \"Advanced Battery\";\n    }\n\n    public override void Operate() {\n        Console.WriteLine(\"SmartPhone is browsing the web.\");\n    }\n}\n*/\n\nclass Program {\n    static void Main() {\n        Gadget[] gadgets = new Gadget[] {\n            new Phone()\n            // Add SmartPhone here if uncommented above\n        };\n\n        foreach (var gadget in gadgets) {\n            Console.WriteLine(\"Power Source: \" + gadget.GetPowerSource());\n            gadget.Operate();\n            Console.WriteLine();\n        }\n    }\n}"
    },
    "explanation": "This program integrates ***abstract classes***, ***method overriding***, ***sealed methods***, and ***polymorphism***:\n- ```Gadget``` is an ***abstract class*** with:\n  - A ***virtual*** method ```GetPowerSource``` providing a default implementation.\n  - An ***abstract*** method ```Operate``` that must be implemented by derived classes.\n- ```Phone``` inherits from ```Gadget```:\n  - Overrides ```GetPowerSource``` with the ```sealed``` keyword, preventing further overrides, and returns \"Battery\".\n  - Implements ```Operate``` to describe phone functionality.\n- ```SmartPhone``` (commented out) attempts to override the ***sealed*** ```GetPowerSource```, which would result in a compilation error, demonstrating the restriction.\n- In ```Main```, an array of ```Gadget``` references holds a ```Phone``` object. A loop calls both methods polymorphically:\n  - ```GetPowerSource``` uses the sealed override from ```Phone```.\n  - ```Operate``` uses the specific implementation from ```Phone```.\nThis exercise uniquely combines an abstract base with a sealed method override, showcasing how sealing affects inheritance hierarchies while enabling polymorphic behavior."
  },
  {
    "title": "Sealed Class with Virtual Method in Polymorphic Hierarchy",
    "ques": "Create a C# program that demonstrates a sealed class within an inheritance hierarchy. Define a base class 'Device' with a virtual method 'GetStatus', a derived class 'Laptop' that overrides it, and a sealed class 'Tablet' that also overrides it. Use an array of 'Device' references to call the method polymorphically, and attempt to derive from 'Tablet' to show the sealed restriction.",
    "answer": {
      "type": "code",
      "lang": "c#",
      "content": "using System;\n\nclass Device {\n    public virtual string GetStatus() {\n        return \"Device status: Unknown\";\n    }\n}\n\nclass Laptop : Device {\n    public override string GetStatus() {\n        return \"Laptop status: Running on battery\";\n    }\n}\n\nsealed class Tablet : Device {\n    public override string GetStatus() {\n        return \"Tablet status: Touchscreen active\";\n    }\n}\n\n// Uncommenting the below will cause a compilation error due to sealed class\n/*\nclass SmartTablet : Tablet {\n    public override string GetStatus() { // Error: Cannot inherit from sealed class\n        return \"SmartTablet status: Voice-activated\";\n    }\n}\n*/\n\nclass Program {\n    static void Main() {\n        Device[] devices = new Device[] {\n            new Device(),\n            new Laptop(),\n            new Tablet()\n        };\n\n        foreach (var device in devices) {\n            Console.WriteLine(device.GetStatus());\n        }\n    }\n}"
    },
    "explanation": "This program showcases a ***sealed class*** within an inheritance hierarchy with ***virtual method overriding*** and ***polymorphism***:\n- ```Device``` is the base class with a ***virtual*** method ```GetStatus``` providing a default status.\n- ```Laptop``` inherits from ```Device``` and ***overrides*** ```GetStatus``` to specify its status.\n- ```Tablet``` is a ***sealed class*** that also inherits from ```Device``` and overrides ```GetStatus```. The ```sealed``` keyword prevents further inheritance.\n- A commented-out ```SmartTablet``` class attempts to derive from ```Tablet```, which would fail due to the ***sealed*** restriction.\n- In ```Main```, an array of ```Device``` references holds objects of ```Device```, ```Laptop```, and ```Tablet```. A loop calls ```GetStatus``` polymorphically:\n  - For ```Device```, the base implementation runs.\n  - For ```Laptop``` and ```Tablet```, their overridden implementations are executed.\nThis demonstrates how a ***sealed class*** can participate in a polymorphic hierarchy while enforcing a boundary on further derivation."
  },
  {
    "title": "Sealed Class Implementing Interface in Multilevel Inheritance",
    "ques": "Write a C# program that demonstrates multilevel inheritance with an interface and a sealed class. Define an interface 'IConfigurable' with a method 'Configure', a base class 'Machine' with a virtual method 'GetType', a derived class 'Printer' that overrides it, and a sealed class 'LaserPrinter' that inherits from 'Printer' and implements 'IConfigurable'. Use polymorphic calls through both the base class and interface types, and attempt to derive from 'LaserPrinter' to show the sealed restriction.",
    "answer": {
      "type": "code",
      "lang": "c#",
      "content": "using System;\n\ninterface IConfigurable {\n    void Configure();\n}\n\nclass Machine {\n    public virtual string GetType() {\n        return \"Generic Machine\";\n    }\n}\n\nclass Printer : Machine {\n    public override string GetType() {\n        return \"Printer Machine\";\n    }\n}\n\nsealed class LaserPrinter : Printer, IConfigurable {\n    public override string GetType() {\n        return \"Laser Printer Machine\";\n    }\n\n    public void Configure() {\n        Console.WriteLine(\"Configuring laser printer settings.\");\n    }\n}\n\n// Uncommenting the below will cause a compilation error due to sealed class\n/*\nclass AdvancedLaserPrinter : LaserPrinter {\n    public override string GetType() { // Error: Cannot inherit from sealed class\n        return \"Advanced Laser Printer\";\n    }\n}\n*/\n\nclass Program {\n    static void Main() {\n        Machine[] machines = new Machine[] {\n            new Machine(),\n            new Printer(),\n            new LaserPrinter()\n        };\n\n        Console.WriteLine(\"Polymorphic calls via Machine type:\");\n        foreach (var machine in machines) {\n            Console.WriteLine(machine.GetType());\n        }\n\n        Console.WriteLine(\"\\nInterface-based call:\");\n        IConfigurable configurable = new LaserPrinter();\n        configurable.Configure();\n\n        Console.WriteLine(\"\\nCombined access:\");\n        LaserPrinter laser = new LaserPrinter();\n        Console.WriteLine(laser.GetType());\n        laser.Configure();\n    }\n}"
    },
    "explanation": "This program integrates ***multilevel inheritance***, ***method overriding***, an ***interface***, and a ***sealed class*** with ***polymorphism***:\n- ```IConfigurable``` is an ***interface*** defining a ```Configure``` method.\n- ```Machine``` is the base class with a ***virtual*** method ```GetType```.\n- ```Printer``` inherits from ```Machine``` (single inheritance) and ***overrides*** ```GetType```.\n- ```LaserPrinter``` inherits from ```Printer``` (multilevel inheritance), is marked ***sealed*** to prevent further derivation, overrides ```GetType```, and implements ```IConfigurable``` with ```Configure```.\n- A commented-out ```AdvancedLaserPrinter``` shows that attempting to inherit from the ***sealed*** ```LaserPrinter``` would fail.\n- In ```Main```:\n  - An array of ```Machine``` references demonstrates ***polymorphism*** by calling ```GetType``` on each object, reflecting the overridden method at each level.\n  - An ```IConfigurable``` reference calls ```Configure``` on a ```LaserPrinter```, showing interface-based polymorphism.\n  - Direct access to a ```LaserPrinter``` object shows both its overridden method and interface method.\nThis exercise uniquely combines a sealed class as the endpoint of a multilevel hierarchy with interface implementation, highlighting design flexibility and restrictions."
  }
]